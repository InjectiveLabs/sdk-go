// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/permissions/v1beta1/permissions.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// each Action enum value should be a power of two
type Action int32

const (
	// 0 is reserved for ACTION_UNSPECIFIED
	Action_UNSPECIFIED Action = 0
	// 1 is reserved for MINT
	Action_MINT Action = 1
	// 2 is reserved for RECEIVE
	Action_RECEIVE Action = 2
	// 4 is reserved for BURN
	Action_BURN Action = 4
	// 8 is reserved for SEND
	Action_SEND Action = 8
	// 16 is reserved for SUPER_BURN
	Action_SUPER_BURN Action = 16
	// 134217728 is reserved for MODIFY_POLICY_MANAGERS
	Action_MODIFY_POLICY_MANAGERS Action = 134217728
	// 268435456 is reserved for MODIFY_CONTRACT_HOOK
	Action_MODIFY_CONTRACT_HOOK Action = 268435456
	// 536870912 is reserved for MODIFY_ROLE_PERMISSIONS
	Action_MODIFY_ROLE_PERMISSIONS Action = 536870912
	// 1073741824 is reserved for MODIFY_ROLE_MANAGERS
	Action_MODIFY_ROLE_MANAGERS Action = 1073741824
)

var Action_name = map[int32]string{
	0:          "UNSPECIFIED",
	1:          "MINT",
	2:          "RECEIVE",
	4:          "BURN",
	8:          "SEND",
	16:         "SUPER_BURN",
	134217728:  "MODIFY_POLICY_MANAGERS",
	268435456:  "MODIFY_CONTRACT_HOOK",
	536870912:  "MODIFY_ROLE_PERMISSIONS",
	1073741824: "MODIFY_ROLE_MANAGERS",
}

var Action_value = map[string]int32{
	"UNSPECIFIED":             0,
	"MINT":                    1,
	"RECEIVE":                 2,
	"BURN":                    4,
	"SEND":                    8,
	"SUPER_BURN":              16,
	"MODIFY_POLICY_MANAGERS":  134217728,
	"MODIFY_CONTRACT_HOOK":    268435456,
	"MODIFY_ROLE_PERMISSIONS": 536870912,
	"MODIFY_ROLE_MANAGERS":    1073741824,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{0}
}

// Namespace defines a permissions namespace
type Namespace struct {
	Denom                     string                     `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	ContractHook              string                     `protobuf:"bytes,2,opt,name=contract_hook,json=contractHook,proto3" json:"contract_hook,omitempty"`
	RolePermissions           []*Role                    `protobuf:"bytes,3,rep,name=role_permissions,json=rolePermissions,proto3" json:"role_permissions,omitempty"`
	ActorRoles                []*ActorRoles              `protobuf:"bytes,4,rep,name=actor_roles,json=actorRoles,proto3" json:"actor_roles,omitempty"`
	RoleManagers              []*RoleManager             `protobuf:"bytes,5,rep,name=role_managers,json=roleManagers,proto3" json:"role_managers,omitempty"`
	PolicyStatuses            []*PolicyStatus            `protobuf:"bytes,6,rep,name=policy_statuses,json=policyStatuses,proto3" json:"policy_statuses,omitempty"`
	PolicyManagerCapabilities []*PolicyManagerCapability `protobuf:"bytes,7,rep,name=policy_manager_capabilities,json=policyManagerCapabilities,proto3" json:"policy_manager_capabilities,omitempty"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{0}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Namespace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

func (m *Namespace) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *Namespace) GetContractHook() string {
	if m != nil {
		return m.ContractHook
	}
	return ""
}

func (m *Namespace) GetRolePermissions() []*Role {
	if m != nil {
		return m.RolePermissions
	}
	return nil
}

func (m *Namespace) GetActorRoles() []*ActorRoles {
	if m != nil {
		return m.ActorRoles
	}
	return nil
}

func (m *Namespace) GetRoleManagers() []*RoleManager {
	if m != nil {
		return m.RoleManagers
	}
	return nil
}

func (m *Namespace) GetPolicyStatuses() []*PolicyStatus {
	if m != nil {
		return m.PolicyStatuses
	}
	return nil
}

func (m *Namespace) GetPolicyManagerCapabilities() []*PolicyManagerCapability {
	if m != nil {
		return m.PolicyManagerCapabilities
	}
	return nil
}

// AddressRoles defines roles for an actor
type ActorRoles struct {
	Actor string   `protobuf:"bytes,1,opt,name=actor,proto3" json:"actor,omitempty"`
	Roles []string `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *ActorRoles) Reset()         { *m = ActorRoles{} }
func (m *ActorRoles) String() string { return proto.CompactTextString(m) }
func (*ActorRoles) ProtoMessage()    {}
func (*ActorRoles) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{1}
}
func (m *ActorRoles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActorRoles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActorRoles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActorRoles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActorRoles.Merge(m, src)
}
func (m *ActorRoles) XXX_Size() int {
	return m.Size()
}
func (m *ActorRoles) XXX_DiscardUnknown() {
	xxx_messageInfo_ActorRoles.DiscardUnknown(m)
}

var xxx_messageInfo_ActorRoles proto.InternalMessageInfo

func (m *ActorRoles) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *ActorRoles) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// RoleActors defines actors for a role
type RoleActors struct {
	Role   string   `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	Actors []string `protobuf:"bytes,2,rep,name=actors,proto3" json:"actors,omitempty"`
}

func (m *RoleActors) Reset()         { *m = RoleActors{} }
func (m *RoleActors) String() string { return proto.CompactTextString(m) }
func (*RoleActors) ProtoMessage()    {}
func (*RoleActors) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{2}
}
func (m *RoleActors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleActors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleActors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleActors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleActors.Merge(m, src)
}
func (m *RoleActors) XXX_Size() int {
	return m.Size()
}
func (m *RoleActors) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleActors.DiscardUnknown(m)
}

var xxx_messageInfo_RoleActors proto.InternalMessageInfo

func (m *RoleActors) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *RoleActors) GetActors() []string {
	if m != nil {
		return m.Actors
	}
	return nil
}

// RoleManager defines roles for a manager address
type RoleManager struct {
	Manager string   `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	Roles   []string `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *RoleManager) Reset()         { *m = RoleManager{} }
func (m *RoleManager) String() string { return proto.CompactTextString(m) }
func (*RoleManager) ProtoMessage()    {}
func (*RoleManager) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{3}
}
func (m *RoleManager) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleManager) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleManager.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleManager) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleManager.Merge(m, src)
}
func (m *RoleManager) XXX_Size() int {
	return m.Size()
}
func (m *RoleManager) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleManager.DiscardUnknown(m)
}

var xxx_messageInfo_RoleManager proto.InternalMessageInfo

func (m *RoleManager) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func (m *RoleManager) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// PolicyStatus defines the status of a policy
type PolicyStatus struct {
	Action     Action `protobuf:"varint,1,opt,name=action,proto3,enum=injective.permissions.v1beta1.Action" json:"action,omitempty"`
	IsDisabled bool   `protobuf:"varint,2,opt,name=is_disabled,json=isDisabled,proto3" json:"is_disabled,omitempty"`
	IsSealed   bool   `protobuf:"varint,3,opt,name=is_sealed,json=isSealed,proto3" json:"is_sealed,omitempty"`
}

func (m *PolicyStatus) Reset()         { *m = PolicyStatus{} }
func (m *PolicyStatus) String() string { return proto.CompactTextString(m) }
func (*PolicyStatus) ProtoMessage()    {}
func (*PolicyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{4}
}
func (m *PolicyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyStatus.Merge(m, src)
}
func (m *PolicyStatus) XXX_Size() int {
	return m.Size()
}
func (m *PolicyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyStatus proto.InternalMessageInfo

func (m *PolicyStatus) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_UNSPECIFIED
}

func (m *PolicyStatus) GetIsDisabled() bool {
	if m != nil {
		return m.IsDisabled
	}
	return false
}

func (m *PolicyStatus) GetIsSealed() bool {
	if m != nil {
		return m.IsSealed
	}
	return false
}

// Role is only used for storage
type Role struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RoleId      uint32 `protobuf:"varint,2,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	Permissions uint32 `protobuf:"varint,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (m *Role) Reset()         { *m = Role{} }
func (m *Role) String() string { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()    {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{5}
}
func (m *Role) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Role.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return m.Size()
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Role) GetRoleId() uint32 {
	if m != nil {
		return m.RoleId
	}
	return 0
}

func (m *Role) GetPermissions() uint32 {
	if m != nil {
		return m.Permissions
	}
	return 0
}

// PolicyManagerCapability defines the capabilities of a manager for a policy
type PolicyManagerCapability struct {
	Manager    string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	Action     Action `protobuf:"varint,2,opt,name=action,proto3,enum=injective.permissions.v1beta1.Action" json:"action,omitempty"`
	CanDisable bool   `protobuf:"varint,3,opt,name=can_disable,json=canDisable,proto3" json:"can_disable,omitempty"`
	CanSeal    bool   `protobuf:"varint,4,opt,name=can_seal,json=canSeal,proto3" json:"can_seal,omitempty"`
}

func (m *PolicyManagerCapability) Reset()         { *m = PolicyManagerCapability{} }
func (m *PolicyManagerCapability) String() string { return proto.CompactTextString(m) }
func (*PolicyManagerCapability) ProtoMessage()    {}
func (*PolicyManagerCapability) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{6}
}
func (m *PolicyManagerCapability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyManagerCapability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyManagerCapability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyManagerCapability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyManagerCapability.Merge(m, src)
}
func (m *PolicyManagerCapability) XXX_Size() int {
	return m.Size()
}
func (m *PolicyManagerCapability) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyManagerCapability.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyManagerCapability proto.InternalMessageInfo

func (m *PolicyManagerCapability) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func (m *PolicyManagerCapability) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_UNSPECIFIED
}

func (m *PolicyManagerCapability) GetCanDisable() bool {
	if m != nil {
		return m.CanDisable
	}
	return false
}

func (m *PolicyManagerCapability) GetCanSeal() bool {
	if m != nil {
		return m.CanSeal
	}
	return false
}

// used in storage
type RoleIDs struct {
	RoleIds []uint32 `protobuf:"varint,1,rep,packed,name=role_ids,json=roleIds,proto3" json:"role_ids,omitempty"`
}

func (m *RoleIDs) Reset()         { *m = RoleIDs{} }
func (m *RoleIDs) String() string { return proto.CompactTextString(m) }
func (*RoleIDs) ProtoMessage()    {}
func (*RoleIDs) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{7}
}
func (m *RoleIDs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleIDs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleIDs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleIDs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleIDs.Merge(m, src)
}
func (m *RoleIDs) XXX_Size() int {
	return m.Size()
}
func (m *RoleIDs) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleIDs.DiscardUnknown(m)
}

var xxx_messageInfo_RoleIDs proto.InternalMessageInfo

func (m *RoleIDs) GetRoleIds() []uint32 {
	if m != nil {
		return m.RoleIds
	}
	return nil
}

// Voucher is used to represent a voucher
type Voucher struct {
	Coins github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=coins,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"coins"`
}

func (m *Voucher) Reset()         { *m = Voucher{} }
func (m *Voucher) String() string { return proto.CompactTextString(m) }
func (*Voucher) ProtoMessage()    {}
func (*Voucher) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{8}
}
func (m *Voucher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Voucher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Voucher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Voucher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Voucher.Merge(m, src)
}
func (m *Voucher) XXX_Size() int {
	return m.Size()
}
func (m *Voucher) XXX_DiscardUnknown() {
	xxx_messageInfo_Voucher.DiscardUnknown(m)
}

var xxx_messageInfo_Voucher proto.InternalMessageInfo

func (m *Voucher) GetCoins() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Coins
	}
	return nil
}

// AddressVoucher is used to represent a voucher for a specific address
type AddressVoucher struct {
	Address string                                  `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Voucher github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,2,opt,name=voucher,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"voucher,omitempty"`
}

func (m *AddressVoucher) Reset()         { *m = AddressVoucher{} }
func (m *AddressVoucher) String() string { return proto.CompactTextString(m) }
func (*AddressVoucher) ProtoMessage()    {}
func (*AddressVoucher) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{9}
}
func (m *AddressVoucher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressVoucher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressVoucher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressVoucher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressVoucher.Merge(m, src)
}
func (m *AddressVoucher) XXX_Size() int {
	return m.Size()
}
func (m *AddressVoucher) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressVoucher.DiscardUnknown(m)
}

var xxx_messageInfo_AddressVoucher proto.InternalMessageInfo

func (m *AddressVoucher) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterEnum("injective.permissions.v1beta1.Action", Action_name, Action_value)
	proto.RegisterType((*Namespace)(nil), "injective.permissions.v1beta1.Namespace")
	proto.RegisterType((*ActorRoles)(nil), "injective.permissions.v1beta1.ActorRoles")
	proto.RegisterType((*RoleActors)(nil), "injective.permissions.v1beta1.RoleActors")
	proto.RegisterType((*RoleManager)(nil), "injective.permissions.v1beta1.RoleManager")
	proto.RegisterType((*PolicyStatus)(nil), "injective.permissions.v1beta1.PolicyStatus")
	proto.RegisterType((*Role)(nil), "injective.permissions.v1beta1.Role")
	proto.RegisterType((*PolicyManagerCapability)(nil), "injective.permissions.v1beta1.PolicyManagerCapability")
	proto.RegisterType((*RoleIDs)(nil), "injective.permissions.v1beta1.RoleIDs")
	proto.RegisterType((*Voucher)(nil), "injective.permissions.v1beta1.Voucher")
	proto.RegisterType((*AddressVoucher)(nil), "injective.permissions.v1beta1.AddressVoucher")
}

func init() {
	proto.RegisterFile("injective/permissions/v1beta1/permissions.proto", fileDescriptor_6d25f3ecf3806c6c)
}

var fileDescriptor_6d25f3ecf3806c6c = []byte{
	// 901 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xda, 0x8e, 0xd7, 0x79, 0xce, 0x0f, 0x33, 0x8a, 0x9a, 0x4d, 0x4b, 0x6d, 0xcb, 0x05,
	0x11, 0x0a, 0xb5, 0x69, 0x90, 0x10, 0x97, 0x4a, 0x38, 0xf6, 0x96, 0x2e, 0xc4, 0x3f, 0x18, 0x27,
	0x95, 0xca, 0x65, 0x35, 0x5e, 0x8f, 0x92, 0x21, 0xde, 0x1d, 0x6b, 0x67, 0x13, 0xc9, 0x37, 0x73,
	0xe6, 0xc2, 0x3f, 0xc1, 0x85, 0x03, 0x7f, 0x47, 0x8f, 0x39, 0x22, 0x0e, 0x01, 0x25, 0x37, 0xfe,
	0x0a, 0x34, 0xb3, 0xb3, 0xf6, 0x56, 0x22, 0x3f, 0xd4, 0x93, 0xe7, 0xbd, 0x6f, 0xbe, 0xef, 0xbd,
	0xf9, 0xf6, 0x79, 0x06, 0x9a, 0x2c, 0xf8, 0x89, 0x7a, 0x11, 0x3b, 0xa7, 0xcd, 0x29, 0x0d, 0x7d,
	0x26, 0x04, 0xe3, 0x81, 0x68, 0x9e, 0x3f, 0x1f, 0xd1, 0x88, 0x3c, 0x4f, 0xe7, 0x1a, 0xd3, 0x90,
	0x47, 0x1c, 0x3d, 0x5e, 0x10, 0x1a, 0x69, 0x50, 0x13, 0x1e, 0x56, 0x3c, 0x2e, 0x7c, 0x2e, 0x9a,
	0x23, 0x22, 0xe8, 0x42, 0xc5, 0xe3, 0x2c, 0x88, 0xe9, 0x0f, 0xb7, 0x8e, 0xf9, 0x31, 0x57, 0xcb,
	0xa6, 0x5c, 0xc5, 0xd9, 0xfa, 0xcf, 0x79, 0x58, 0xed, 0x11, 0x9f, 0x8a, 0x29, 0xf1, 0x28, 0xda,
	0x82, 0x95, 0x31, 0x0d, 0xb8, 0x6f, 0x19, 0x35, 0x63, 0x77, 0x15, 0xc7, 0x01, 0x7a, 0x02, 0xeb,
	0x1e, 0x0f, 0xa2, 0x90, 0x78, 0x91, 0x7b, 0xc2, 0xf9, 0xa9, 0x95, 0x55, 0xe8, 0x5a, 0x92, 0x7c,
	0xc5, 0xf9, 0x29, 0xea, 0x41, 0x39, 0xe4, 0x13, 0xea, 0xa6, 0x5a, 0xb3, 0x72, 0xb5, 0xdc, 0x6e,
	0x69, 0xef, 0x49, 0xe3, 0xd6, 0xc6, 0x1b, 0x98, 0x4f, 0x28, 0xde, 0x94, 0xe4, 0xc1, 0x12, 0x45,
	0xdf, 0x41, 0x89, 0x78, 0x11, 0x0f, 0x5d, 0x09, 0x08, 0x2b, 0xaf, 0xa4, 0x3e, 0xbd, 0x43, 0xaa,
	0x25, 0x19, 0x52, 0x4f, 0x60, 0x20, 0x8b, 0x35, 0xea, 0xc3, 0xba, 0xea, 0xcd, 0x27, 0x01, 0x39,
	0xa6, 0xa1, 0xb0, 0x56, 0x94, 0xda, 0xd3, 0x7b, 0x34, 0xd6, 0x8d, 0x29, 0x78, 0x2d, 0x5c, 0x06,
	0x02, 0x1d, 0xc2, 0xe6, 0x94, 0x4f, 0x98, 0x37, 0x73, 0x45, 0x44, 0xa2, 0x33, 0x41, 0x85, 0x55,
	0x50, 0x92, 0x9f, 0xdd, 0x21, 0x39, 0x50, 0xac, 0xa1, 0x22, 0xe1, 0x8d, 0x69, 0x2a, 0xa2, 0x02,
	0x9d, 0xc3, 0x23, 0xad, 0xaa, 0x1b, 0x75, 0x3d, 0x32, 0x25, 0x23, 0x36, 0x61, 0x11, 0xa3, 0xc2,
	0x32, 0x55, 0x85, 0xaf, 0xee, 0x55, 0x41, 0x77, 0xda, 0x4e, 0xf8, 0x33, 0xbc, 0x33, 0xfd, 0x5f,
	0x80, 0x51, 0x51, 0xff, 0x1a, 0x60, 0x69, 0x9c, 0x9c, 0x01, 0x65, 0x5d, 0x32, 0x03, 0x2a, 0x90,
	0xd9, 0xf8, 0x43, 0x64, 0x6b, 0x39, 0x99, 0x55, 0x81, 0x64, 0x4a, 0x92, 0x62, 0x0b, 0x84, 0x20,
	0x2f, 0xd3, 0x9a, 0xa8, 0xd6, 0xe8, 0x01, 0x14, 0x94, 0x40, 0x42, 0xd4, 0x51, 0xfd, 0x05, 0x94,
	0x52, 0xf6, 0x22, 0x0b, 0x4c, 0x7d, 0x66, 0xcd, 0x4e, 0xc2, 0x1b, 0x0a, 0xff, 0x62, 0xc0, 0x5a,
	0xda, 0x4b, 0xf4, 0x42, 0xd5, 0x61, 0x3c, 0x50, 0xfc, 0x8d, 0xbd, 0x8f, 0xef, 0x9e, 0x14, 0xc6,
	0x03, 0xac, 0x49, 0xa8, 0x0a, 0x25, 0x26, 0xdc, 0x31, 0x13, 0x64, 0x34, 0xa1, 0x63, 0x35, 0xe0,
	0x45, 0x0c, 0x4c, 0x74, 0x74, 0x06, 0x3d, 0x82, 0x55, 0x26, 0x5c, 0x41, 0x89, 0x84, 0x73, 0x0a,
	0x2e, 0x32, 0x31, 0x54, 0x71, 0xfd, 0x08, 0xf2, 0xf2, 0x30, 0xd2, 0x80, 0x80, 0xf8, 0x0b, 0x03,
	0xe4, 0x1a, 0x6d, 0x83, 0xa9, 0x66, 0x8f, 0xc5, 0xaa, 0xeb, 0xb8, 0x20, 0x43, 0x67, 0x8c, 0x6a,
	0x50, 0x7a, 0xf7, 0xbf, 0x22, 0xc1, 0x74, 0xaa, 0xfe, 0x87, 0x01, 0xdb, 0x37, 0x7c, 0xce, 0x5b,
	0x0c, 0x5b, 0x3a, 0x91, 0x7d, 0x4f, 0x27, 0x3c, 0x12, 0x24, 0x56, 0xe8, 0xa3, 0x82, 0x47, 0x02,
	0x6d, 0x05, 0xda, 0x81, 0xa2, 0xdc, 0x20, 0xad, 0xb0, 0xf2, 0x0a, 0x35, 0x3d, 0x12, 0x48, 0x27,
	0xea, 0x1f, 0x81, 0x29, 0x7d, 0x70, 0x3a, 0x42, 0xee, 0xd2, 0xc7, 0x16, 0x96, 0x51, 0xcb, 0xed,
	0xae, 0x63, 0x33, 0x3e, 0xb7, 0xa8, 0x4f, 0xc0, 0x7c, 0xcd, 0xcf, 0xbc, 0x13, 0x1a, 0x22, 0x02,
	0x2b, 0xf2, 0x86, 0x8a, 0xb7, 0x94, 0xf6, 0x76, 0x1a, 0xf1, 0x1d, 0xd6, 0x90, 0x77, 0xd8, 0xa2,
	0xc1, 0x36, 0x67, 0xc1, 0xfe, 0x17, 0x6f, 0x2f, 0xab, 0x99, 0xdf, 0xff, 0xae, 0xee, 0x1e, 0xb3,
	0xe8, 0xe4, 0x6c, 0xd4, 0xf0, 0xb8, 0xdf, 0xd4, 0x17, 0x5e, 0xfc, 0xf3, 0x4c, 0x8c, 0x4f, 0x9b,
	0xd1, 0x6c, 0x4a, 0x85, 0x22, 0x08, 0x1c, 0x2b, 0xd7, 0x7f, 0x33, 0x60, 0xa3, 0x35, 0x1e, 0x87,
	0x54, 0x88, 0xa4, 0xaa, 0x05, 0x26, 0x89, 0x33, 0x89, 0x77, 0x3a, 0x44, 0x33, 0x30, 0xcf, 0xe3,
	0x4d, 0xca, 0xbc, 0x5b, 0x3b, 0xea, 0xc8, 0x8e, 0xfe, 0xba, 0xac, 0x7e, 0x72, 0xcf, 0x8e, 0xfe,
	0xbd, 0xac, 0x7e, 0xa0, 0xc5, 0x3f, 0xe7, 0x3e, 0x8b, 0xa8, 0x3f, 0x8d, 0x66, 0x38, 0xa9, 0xf7,
	0xf4, 0xc2, 0x80, 0x42, 0xfc, 0x29, 0xd0, 0x26, 0x94, 0x8e, 0x7a, 0xc3, 0x81, 0xdd, 0x76, 0x5e,
	0x3a, 0x76, 0xa7, 0x9c, 0x41, 0x45, 0xc8, 0x77, 0x9d, 0xde, 0x61, 0xd9, 0x40, 0x25, 0x30, 0xb1,
	0xdd, 0xb6, 0x9d, 0xd7, 0x76, 0x39, 0x2b, 0xd3, 0xfb, 0x47, 0xb8, 0x57, 0xce, 0xcb, 0xd5, 0xd0,
	0xee, 0x75, 0xca, 0x45, 0xb4, 0x01, 0x30, 0x3c, 0x1a, 0xd8, 0xd8, 0x55, 0x48, 0x19, 0x3d, 0x86,
	0x07, 0xdd, 0x7e, 0xc7, 0x79, 0xf9, 0xc6, 0x1d, 0xf4, 0x0f, 0x9c, 0xf6, 0x1b, 0xb7, 0xdb, 0xea,
	0xb5, 0xbe, 0xb5, 0xf1, 0xb0, 0x3c, 0x9f, 0xcf, 0xbf, 0x41, 0x1f, 0xc2, 0x96, 0x86, 0xdb, 0xfd,
	0xde, 0x21, 0x6e, 0xb5, 0x0f, 0xdd, 0x57, 0xfd, 0xfe, 0xf7, 0x12, 0x9c, 0x1b, 0xa8, 0x0a, 0xdb,
	0x1a, 0xc5, 0xfd, 0x03, 0xdb, 0x1d, 0xd8, 0xb8, 0xeb, 0x0c, 0x87, 0x4e, 0xbf, 0xa7, 0xd8, 0xf3,
	0x6c, 0x8a, 0xae, 0x36, 0xa4, 0xb5, 0xe7, 0xf9, 0xfd, 0xd3, 0xb7, 0x57, 0x15, 0xe3, 0xe2, 0xaa,
	0x62, 0xfc, 0x73, 0x55, 0x31, 0x7e, 0xbd, 0xae, 0x64, 0x2e, 0xae, 0x2b, 0x99, 0x3f, 0xaf, 0x2b,
	0x99, 0x1f, 0x7f, 0x48, 0x79, 0xe6, 0x24, 0xd3, 0x79, 0x40, 0x46, 0x62, 0xf9, 0x28, 0x3e, 0xf3,
	0x78, 0x48, 0xd3, 0xe1, 0x09, 0x61, 0x41, 0xd3, 0xe7, 0xe3, 0xb3, 0x09, 0x15, 0xef, 0xbc, 0x98,
	0xca, 0xe2, 0x51, 0x41, 0xbd, 0x67, 0x5f, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0x9b, 0xcd, 0x22,
	0x33, 0x57, 0x07, 0x00, 0x00,
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PolicyManagerCapabilities) > 0 {
		for iNdEx := len(m.PolicyManagerCapabilities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PolicyManagerCapabilities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PolicyStatuses) > 0 {
		for iNdEx := len(m.PolicyStatuses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PolicyStatuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RoleManagers) > 0 {
		for iNdEx := len(m.RoleManagers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoleManagers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ActorRoles) > 0 {
		for iNdEx := len(m.ActorRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActorRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RolePermissions) > 0 {
		for iNdEx := len(m.RolePermissions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RolePermissions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ContractHook) > 0 {
		i -= len(m.ContractHook)
		copy(dAtA[i:], m.ContractHook)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ContractHook)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActorRoles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorRoles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActorRoles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintPermissions(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleActors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleActors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleActors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Actors) > 0 {
		for iNdEx := len(m.Actors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Actors[iNdEx])
			copy(dAtA[i:], m.Actors[iNdEx])
			i = encodeVarintPermissions(dAtA, i, uint64(len(m.Actors[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleManager) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleManager) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintPermissions(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSealed {
		i--
		if m.IsSealed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsDisabled {
		i--
		if m.IsDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Action != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Role) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x18
	}
	if m.RoleId != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.RoleId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyManagerCapability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyManagerCapability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyManagerCapability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CanSeal {
		i--
		if m.CanSeal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CanDisable {
		i--
		if m.CanDisable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Action != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleIDs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleIDs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoleIds) > 0 {
		dAtA2 := make([]byte, len(m.RoleIds)*10)
		var j1 int
		for _, num := range m.RoleIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPermissions(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Voucher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Voucher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Voucher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddressVoucher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressVoucher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressVoucher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Voucher.Size()
		i -= size
		if _, err := m.Voucher.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPermissions(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ContractHook)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.RolePermissions) > 0 {
		for _, e := range m.RolePermissions {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ActorRoles) > 0 {
		for _, e := range m.ActorRoles {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.RoleManagers) > 0 {
		for _, e := range m.RoleManagers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PolicyStatuses) > 0 {
		for _, e := range m.PolicyStatuses {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PolicyManagerCapabilities) > 0 {
		for _, e := range m.PolicyManagerCapabilities {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActorRoles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *RoleActors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Actors) > 0 {
		for _, s := range m.Actors {
			l = len(s)
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *RoleManager) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *PolicyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovPermissions(uint64(m.Action))
	}
	if m.IsDisabled {
		n += 2
	}
	if m.IsSealed {
		n += 2
	}
	return n
}

func (m *Role) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.RoleId != 0 {
		n += 1 + sovPermissions(uint64(m.RoleId))
	}
	if m.Permissions != 0 {
		n += 1 + sovPermissions(uint64(m.Permissions))
	}
	return n
}

func (m *PolicyManagerCapability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPermissions(uint64(m.Action))
	}
	if m.CanDisable {
		n += 2
	}
	if m.CanSeal {
		n += 2
	}
	return n
}

func (m *RoleIDs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoleIds) > 0 {
		l = 0
		for _, e := range m.RoleIds {
			l += sovPermissions(uint64(e))
		}
		n += 1 + sovPermissions(uint64(l)) + l
	}
	return n
}

func (m *Voucher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *AddressVoucher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = m.Voucher.Size()
	n += 1 + l + sovPermissions(uint64(l))
	return n
}

func sovPermissions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissions(x uint64) (n int) {
	return sovPermissions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractHook", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractHook = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RolePermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RolePermissions = append(m.RolePermissions, &Role{})
			if err := m.RolePermissions[len(m.RolePermissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActorRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActorRoles = append(m.ActorRoles, &ActorRoles{})
			if err := m.ActorRoles[len(m.ActorRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleManagers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleManagers = append(m.RoleManagers, &RoleManager{})
			if err := m.RoleManagers[len(m.RoleManagers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyStatuses = append(m.PolicyStatuses, &PolicyStatus{})
			if err := m.PolicyStatuses[len(m.PolicyStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyManagerCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyManagerCapabilities = append(m.PolicyManagerCapabilities, &PolicyManagerCapability{})
			if err := m.PolicyManagerCapabilities[len(m.PolicyManagerCapabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorRoles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorRoles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorRoles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleActors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleActors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleActors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actors = append(m.Actors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDisabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSealed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSealed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			m.RoleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyManagerCapability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyManagerCapability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyManagerCapability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDisable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDisable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSeal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSeal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermissions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoleIds = append(m.RoleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermissions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPermissions
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPermissions
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoleIds) == 0 {
					m.RoleIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPermissions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoleIds = append(m.RoleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Voucher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Voucher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Voucher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, types.Coin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressVoucher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressVoucher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressVoucher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voucher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Voucher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissions = fmt.Errorf("proto: unexpected end of group")
)
