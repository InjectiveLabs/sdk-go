// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/permissions/v1beta1/permissions.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// each Action enum value should be a power of two
type Action int32

const (
	// 0 is reserved for ACTION_UNSPECIFIED
	Action_UNSPECIFIED Action = 0
	// 1 is reserved for MINT
	Action_MINT Action = 1
	// 2 is reserved for RECEIVE
	Action_RECEIVE Action = 2
	// 4 is reserved for BURN
	Action_BURN Action = 4
	// 8 is reserved for SEND
	Action_SEND Action = 8
	// 16 is reserved for SUPER_BURN
	Action_SUPER_BURN Action = 16
	// 2^27 is reserved for MODIFY_POLICY_MANAGERS
	Action_MODIFY_POLICY_MANAGERS Action = 134217728
	// 2^28 is reserved for MODIFY_CONTRACT_HOOK
	Action_MODIFY_CONTRACT_HOOK Action = 268435456
	// 2^29 is reserved for MODIFY_ROLE_PERMISSIONS
	Action_MODIFY_ROLE_PERMISSIONS Action = 536870912
	// 2^30 is reserved for MODIFY_ROLE_MANAGERS
	Action_MODIFY_ROLE_MANAGERS Action = 1073741824
)

var Action_name = map[int32]string{
	0:          "UNSPECIFIED",
	1:          "MINT",
	2:          "RECEIVE",
	4:          "BURN",
	8:          "SEND",
	16:         "SUPER_BURN",
	134217728:  "MODIFY_POLICY_MANAGERS",
	268435456:  "MODIFY_CONTRACT_HOOK",
	536870912:  "MODIFY_ROLE_PERMISSIONS",
	1073741824: "MODIFY_ROLE_MANAGERS",
}

var Action_value = map[string]int32{
	"UNSPECIFIED":             0,
	"MINT":                    1,
	"RECEIVE":                 2,
	"BURN":                    4,
	"SEND":                    8,
	"SUPER_BURN":              16,
	"MODIFY_POLICY_MANAGERS":  134217728,
	"MODIFY_CONTRACT_HOOK":    268435456,
	"MODIFY_ROLE_PERMISSIONS": 536870912,
	"MODIFY_ROLE_MANAGERS":    1073741824,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{0}
}

// Namespace defines a permissions namespace
type Namespace struct {
	// The tokenfactory denom to which this namespace applies to
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// The address of smart contract to apply code-based restrictions
	ContractHook string `protobuf:"bytes,2,opt,name=contract_hook,json=contractHook,proto3" json:"contract_hook,omitempty"`
	// permissions for each role
	RolePermissions []*Role `protobuf:"bytes,3,rep,name=role_permissions,json=rolePermissions,proto3" json:"role_permissions,omitempty"`
	// roles for each actor
	ActorRoles []*ActorRoles `protobuf:"bytes,4,rep,name=actor_roles,json=actorRoles,proto3" json:"actor_roles,omitempty"`
	// managers for each role
	RoleManagers []*RoleManager `protobuf:"bytes,5,rep,name=role_managers,json=roleManagers,proto3" json:"role_managers,omitempty"`
	// status for each policy
	PolicyStatuses []*PolicyStatus `protobuf:"bytes,6,rep,name=policy_statuses,json=policyStatuses,proto3" json:"policy_statuses,omitempty"`
	// capabilities for each manager for each policy
	PolicyManagerCapabilities []*PolicyManagerCapability `protobuf:"bytes,7,rep,name=policy_manager_capabilities,json=policyManagerCapabilities,proto3" json:"policy_manager_capabilities,omitempty"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{0}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Namespace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

func (m *Namespace) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *Namespace) GetContractHook() string {
	if m != nil {
		return m.ContractHook
	}
	return ""
}

func (m *Namespace) GetRolePermissions() []*Role {
	if m != nil {
		return m.RolePermissions
	}
	return nil
}

func (m *Namespace) GetActorRoles() []*ActorRoles {
	if m != nil {
		return m.ActorRoles
	}
	return nil
}

func (m *Namespace) GetRoleManagers() []*RoleManager {
	if m != nil {
		return m.RoleManagers
	}
	return nil
}

func (m *Namespace) GetPolicyStatuses() []*PolicyStatus {
	if m != nil {
		return m.PolicyStatuses
	}
	return nil
}

func (m *Namespace) GetPolicyManagerCapabilities() []*PolicyManagerCapability {
	if m != nil {
		return m.PolicyManagerCapabilities
	}
	return nil
}

// AddressRoles defines roles for an actor
type ActorRoles struct {
	// The actor name
	Actor string `protobuf:"bytes,1,opt,name=actor,proto3" json:"actor,omitempty"`
	// The roles for the actor
	Roles []string `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *ActorRoles) Reset()         { *m = ActorRoles{} }
func (m *ActorRoles) String() string { return proto.CompactTextString(m) }
func (*ActorRoles) ProtoMessage()    {}
func (*ActorRoles) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{1}
}
func (m *ActorRoles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActorRoles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActorRoles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActorRoles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActorRoles.Merge(m, src)
}
func (m *ActorRoles) XXX_Size() int {
	return m.Size()
}
func (m *ActorRoles) XXX_DiscardUnknown() {
	xxx_messageInfo_ActorRoles.DiscardUnknown(m)
}

var xxx_messageInfo_ActorRoles proto.InternalMessageInfo

func (m *ActorRoles) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *ActorRoles) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// RoleActors defines actors for a role
type RoleActors struct {
	// The role name
	Role string `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	// List of actor names associated with the role
	Actors []string `protobuf:"bytes,2,rep,name=actors,proto3" json:"actors,omitempty"`
}

func (m *RoleActors) Reset()         { *m = RoleActors{} }
func (m *RoleActors) String() string { return proto.CompactTextString(m) }
func (*RoleActors) ProtoMessage()    {}
func (*RoleActors) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{2}
}
func (m *RoleActors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleActors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleActors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleActors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleActors.Merge(m, src)
}
func (m *RoleActors) XXX_Size() int {
	return m.Size()
}
func (m *RoleActors) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleActors.DiscardUnknown(m)
}

var xxx_messageInfo_RoleActors proto.InternalMessageInfo

func (m *RoleActors) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *RoleActors) GetActors() []string {
	if m != nil {
		return m.Actors
	}
	return nil
}

// RoleManager defines roles for a manager address
type RoleManager struct {
	// The manager name
	Manager string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	// List of roles associated with the manager
	Roles []string `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *RoleManager) Reset()         { *m = RoleManager{} }
func (m *RoleManager) String() string { return proto.CompactTextString(m) }
func (*RoleManager) ProtoMessage()    {}
func (*RoleManager) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{3}
}
func (m *RoleManager) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleManager) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleManager.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleManager) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleManager.Merge(m, src)
}
func (m *RoleManager) XXX_Size() int {
	return m.Size()
}
func (m *RoleManager) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleManager.DiscardUnknown(m)
}

var xxx_messageInfo_RoleManager proto.InternalMessageInfo

func (m *RoleManager) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func (m *RoleManager) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// PolicyStatus defines the status of a policy
type PolicyStatus struct {
	// The action code number
	Action Action `protobuf:"varint,1,opt,name=action,proto3,enum=injective.permissions.v1beta1.Action" json:"action,omitempty"`
	// Whether the policy is disabled
	IsDisabled bool `protobuf:"varint,2,opt,name=is_disabled,json=isDisabled,proto3" json:"is_disabled,omitempty"`
	// Whether the policy is sealed
	IsSealed bool `protobuf:"varint,3,opt,name=is_sealed,json=isSealed,proto3" json:"is_sealed,omitempty"`
}

func (m *PolicyStatus) Reset()         { *m = PolicyStatus{} }
func (m *PolicyStatus) String() string { return proto.CompactTextString(m) }
func (*PolicyStatus) ProtoMessage()    {}
func (*PolicyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{4}
}
func (m *PolicyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyStatus.Merge(m, src)
}
func (m *PolicyStatus) XXX_Size() int {
	return m.Size()
}
func (m *PolicyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyStatus proto.InternalMessageInfo

func (m *PolicyStatus) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_UNSPECIFIED
}

func (m *PolicyStatus) GetIsDisabled() bool {
	if m != nil {
		return m.IsDisabled
	}
	return false
}

func (m *PolicyStatus) GetIsSealed() bool {
	if m != nil {
		return m.IsSealed
	}
	return false
}

// Role is only used for storage
type Role struct {
	// The role name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The role ID
	RoleId uint32 `protobuf:"varint,2,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// Integer representing the bitwise combination of all actions assigned to the
	// role
	Permissions uint32 `protobuf:"varint,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (m *Role) Reset()         { *m = Role{} }
func (m *Role) String() string { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()    {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{5}
}
func (m *Role) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Role.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return m.Size()
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Role) GetRoleId() uint32 {
	if m != nil {
		return m.RoleId
	}
	return 0
}

func (m *Role) GetPermissions() uint32 {
	if m != nil {
		return m.Permissions
	}
	return 0
}

// PolicyManagerCapability defines the capabilities of a manager for a policy
type PolicyManagerCapability struct {
	// The manager name
	Manager string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	// The action code number
	Action Action `protobuf:"varint,2,opt,name=action,proto3,enum=injective.permissions.v1beta1.Action" json:"action,omitempty"`
	// Whether the manager can disable the policy
	CanDisable bool `protobuf:"varint,3,opt,name=can_disable,json=canDisable,proto3" json:"can_disable,omitempty"`
	// Whether the manager can seal the policy
	CanSeal bool `protobuf:"varint,4,opt,name=can_seal,json=canSeal,proto3" json:"can_seal,omitempty"`
}

func (m *PolicyManagerCapability) Reset()         { *m = PolicyManagerCapability{} }
func (m *PolicyManagerCapability) String() string { return proto.CompactTextString(m) }
func (*PolicyManagerCapability) ProtoMessage()    {}
func (*PolicyManagerCapability) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{6}
}
func (m *PolicyManagerCapability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyManagerCapability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyManagerCapability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyManagerCapability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyManagerCapability.Merge(m, src)
}
func (m *PolicyManagerCapability) XXX_Size() int {
	return m.Size()
}
func (m *PolicyManagerCapability) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyManagerCapability.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyManagerCapability proto.InternalMessageInfo

func (m *PolicyManagerCapability) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func (m *PolicyManagerCapability) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_UNSPECIFIED
}

func (m *PolicyManagerCapability) GetCanDisable() bool {
	if m != nil {
		return m.CanDisable
	}
	return false
}

func (m *PolicyManagerCapability) GetCanSeal() bool {
	if m != nil {
		return m.CanSeal
	}
	return false
}

// used in storage
type RoleIDs struct {
	RoleIds []uint32 `protobuf:"varint,1,rep,packed,name=role_ids,json=roleIds,proto3" json:"role_ids,omitempty"`
}

func (m *RoleIDs) Reset()         { *m = RoleIDs{} }
func (m *RoleIDs) String() string { return proto.CompactTextString(m) }
func (*RoleIDs) ProtoMessage()    {}
func (*RoleIDs) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{7}
}
func (m *RoleIDs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleIDs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleIDs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleIDs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleIDs.Merge(m, src)
}
func (m *RoleIDs) XXX_Size() int {
	return m.Size()
}
func (m *RoleIDs) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleIDs.DiscardUnknown(m)
}

var xxx_messageInfo_RoleIDs proto.InternalMessageInfo

func (m *RoleIDs) GetRoleIds() []uint32 {
	if m != nil {
		return m.RoleIds
	}
	return nil
}

// AddressVoucher is used to represent a voucher for a specific address
type AddressVoucher struct {
	// The Injective address that the voucher is for
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The voucher amount
	Voucher github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,2,opt,name=voucher,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"voucher,omitempty"`
}

func (m *AddressVoucher) Reset()         { *m = AddressVoucher{} }
func (m *AddressVoucher) String() string { return proto.CompactTextString(m) }
func (*AddressVoucher) ProtoMessage()    {}
func (*AddressVoucher) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d25f3ecf3806c6c, []int{8}
}
func (m *AddressVoucher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressVoucher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressVoucher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressVoucher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressVoucher.Merge(m, src)
}
func (m *AddressVoucher) XXX_Size() int {
	return m.Size()
}
func (m *AddressVoucher) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressVoucher.DiscardUnknown(m)
}

var xxx_messageInfo_AddressVoucher proto.InternalMessageInfo

func (m *AddressVoucher) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterEnum("injective.permissions.v1beta1.Action", Action_name, Action_value)
	proto.RegisterType((*Namespace)(nil), "injective.permissions.v1beta1.Namespace")
	proto.RegisterType((*ActorRoles)(nil), "injective.permissions.v1beta1.ActorRoles")
	proto.RegisterType((*RoleActors)(nil), "injective.permissions.v1beta1.RoleActors")
	proto.RegisterType((*RoleManager)(nil), "injective.permissions.v1beta1.RoleManager")
	proto.RegisterType((*PolicyStatus)(nil), "injective.permissions.v1beta1.PolicyStatus")
	proto.RegisterType((*Role)(nil), "injective.permissions.v1beta1.Role")
	proto.RegisterType((*PolicyManagerCapability)(nil), "injective.permissions.v1beta1.PolicyManagerCapability")
	proto.RegisterType((*RoleIDs)(nil), "injective.permissions.v1beta1.RoleIDs")
	proto.RegisterType((*AddressVoucher)(nil), "injective.permissions.v1beta1.AddressVoucher")
}

func init() {
	proto.RegisterFile("injective/permissions/v1beta1/permissions.proto", fileDescriptor_6d25f3ecf3806c6c)
}

var fileDescriptor_6d25f3ecf3806c6c = []byte{
	// 871 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4d, 0x6f, 0xdb, 0x46,
	0x10, 0x15, 0x25, 0x45, 0x92, 0x47, 0xfe, 0x50, 0x17, 0x46, 0x4c, 0x27, 0x8d, 0x24, 0x28, 0x2d,
	0xea, 0xa6, 0x8d, 0x84, 0xb8, 0x40, 0xd1, 0x4b, 0x80, 0xca, 0x12, 0xd3, 0xb0, 0xb5, 0x28, 0x75,
	0x65, 0x07, 0x48, 0x2f, 0xc4, 0x8a, 0x5a, 0xd8, 0x5b, 0x8b, 0x5c, 0x82, 0x4b, 0x0b, 0xd0, 0x4d,
	0x3d, 0xf7, 0xd2, 0x3f, 0xd1, 0x6b, 0x7f, 0x47, 0x8e, 0x3e, 0x16, 0x3d, 0x18, 0x85, 0x7d, 0xeb,
	0xaf, 0x28, 0x76, 0xb9, 0x94, 0x18, 0xa0, 0x89, 0x83, 0x9e, 0x34, 0x33, 0x6f, 0xdf, 0xdb, 0x99,
	0xc7, 0x11, 0x09, 0x1d, 0x16, 0xfc, 0x4c, 0xbd, 0x98, 0xcd, 0x69, 0x27, 0xa4, 0x91, 0xcf, 0x84,
	0x60, 0x3c, 0x10, 0x9d, 0xf9, 0xb3, 0x09, 0x8d, 0xc9, 0xb3, 0x6c, 0xad, 0x1d, 0x46, 0x3c, 0xe6,
	0xe8, 0xd1, 0x8a, 0xd0, 0xce, 0x82, 0x9a, 0xf0, 0xa0, 0xee, 0x71, 0xe1, 0x73, 0xd1, 0x99, 0x10,
	0x41, 0x57, 0x2a, 0x1e, 0x67, 0x41, 0x42, 0x7f, 0xb0, 0x7b, 0xc6, 0xcf, 0xb8, 0x0a, 0x3b, 0x32,
	0x4a, 0xaa, 0xad, 0x5f, 0x8a, 0xb0, 0xe1, 0x10, 0x9f, 0x8a, 0x90, 0x78, 0x14, 0xed, 0xc2, 0xbd,
	0x29, 0x0d, 0xb8, 0x6f, 0x1a, 0x4d, 0xe3, 0x60, 0x03, 0x27, 0x09, 0x7a, 0x0c, 0x5b, 0x1e, 0x0f,
	0xe2, 0x88, 0x78, 0xb1, 0x7b, 0xce, 0xf9, 0x85, 0x99, 0x57, 0xe8, 0x66, 0x5a, 0x7c, 0xc9, 0xf9,
	0x05, 0x72, 0xa0, 0x16, 0xf1, 0x19, 0x75, 0x33, 0xad, 0x99, 0x85, 0x66, 0xe1, 0xa0, 0x7a, 0xf8,
	0xb8, 0xfd, 0xde, 0xc6, 0xdb, 0x98, 0xcf, 0x28, 0xde, 0x91, 0xe4, 0xd1, 0x1a, 0x45, 0xdf, 0x43,
	0x95, 0x78, 0x31, 0x8f, 0x5c, 0x09, 0x08, 0xb3, 0xa8, 0xa4, 0x3e, 0xbf, 0x43, 0xaa, 0x2b, 0x19,
	0x52, 0x4f, 0x60, 0x20, 0xab, 0x18, 0x0d, 0x61, 0x4b, 0xf5, 0xe6, 0x93, 0x80, 0x9c, 0xd1, 0x48,
	0x98, 0xf7, 0x94, 0xda, 0x93, 0x0f, 0x68, 0x6c, 0x90, 0x50, 0xf0, 0x66, 0xb4, 0x4e, 0x04, 0x3a,
	0x81, 0x9d, 0x90, 0xcf, 0x98, 0xb7, 0x70, 0x45, 0x4c, 0xe2, 0x4b, 0x41, 0x85, 0x59, 0x52, 0x92,
	0x5f, 0xdc, 0x21, 0x39, 0x52, 0xac, 0xb1, 0x22, 0xe1, 0xed, 0x30, 0x93, 0x51, 0x81, 0xe6, 0xf0,
	0x50, 0xab, 0xea, 0x46, 0x5d, 0x8f, 0x84, 0x64, 0xc2, 0x66, 0x2c, 0x66, 0x54, 0x98, 0x65, 0x75,
	0xc3, 0xd7, 0x1f, 0x74, 0x83, 0xee, 0xb4, 0x97, 0xf2, 0x17, 0x78, 0x3f, 0xfc, 0x4f, 0x80, 0x51,
	0xd1, 0xfa, 0x06, 0x60, 0x6d, 0x9c, 0xdc, 0x01, 0x65, 0x5d, 0xba, 0x03, 0x2a, 0x91, 0xd5, 0xe4,
	0x41, 0xe4, 0x9b, 0x05, 0x59, 0x55, 0x89, 0x64, 0x4a, 0x92, 0x62, 0x0b, 0x84, 0xa0, 0x28, 0xcb,
	0x9a, 0xa8, 0x62, 0x74, 0x1f, 0x4a, 0x4a, 0x20, 0x25, 0xea, 0xac, 0xf5, 0x1c, 0xaa, 0x19, 0x7b,
	0x91, 0x09, 0x65, 0x3d, 0xb3, 0x66, 0xa7, 0xe9, 0x3b, 0x2e, 0xfe, 0xd5, 0x80, 0xcd, 0xac, 0x97,
	0xe8, 0xb9, 0xba, 0x87, 0xf1, 0x40, 0xf1, 0xb7, 0x0f, 0x3f, 0xbd, 0x7b, 0x53, 0x18, 0x0f, 0xb0,
	0x26, 0xa1, 0x06, 0x54, 0x99, 0x70, 0xa7, 0x4c, 0x90, 0xc9, 0x8c, 0x4e, 0xd5, 0x82, 0x57, 0x30,
	0x30, 0xd1, 0xd7, 0x15, 0xf4, 0x10, 0x36, 0x98, 0x70, 0x05, 0x25, 0x12, 0x2e, 0x28, 0xb8, 0xc2,
	0xc4, 0x58, 0xe5, 0xad, 0x53, 0x28, 0xca, 0x61, 0xa4, 0x01, 0x01, 0xf1, 0x57, 0x06, 0xc8, 0x18,
	0xed, 0x41, 0x59, 0xed, 0x1e, 0x4b, 0x54, 0xb7, 0x70, 0x49, 0xa6, 0xf6, 0x14, 0x35, 0xa1, 0xfa,
	0xf6, 0x7f, 0x45, 0x82, 0xd9, 0x52, 0xeb, 0x0f, 0x03, 0xf6, 0xde, 0xf1, 0x38, 0xdf, 0x63, 0xd8,
	0xda, 0x89, 0xfc, 0xff, 0x74, 0xc2, 0x23, 0x41, 0x6a, 0x85, 0x1e, 0x15, 0x3c, 0x12, 0x68, 0x2b,
	0xd0, 0x3e, 0x54, 0xe4, 0x01, 0x69, 0x85, 0x59, 0x54, 0x68, 0xd9, 0x23, 0x81, 0x74, 0xa2, 0xf5,
	0x09, 0x94, 0xa5, 0x0f, 0x76, 0x5f, 0xc8, 0x53, 0x7a, 0x6c, 0x61, 0x1a, 0xcd, 0xc2, 0xc1, 0x16,
	0x2e, 0x27, 0x73, 0x8b, 0xd6, 0xef, 0x06, 0x6c, 0x77, 0xa7, 0xd3, 0x88, 0x0a, 0xf1, 0x8a, 0x5f,
	0x7a, 0xe7, 0xc9, 0xe3, 0x27, 0x49, 0x25, 0x9d, 0x46, 0xa7, 0x68, 0x01, 0xe5, 0x79, 0x72, 0x48,
	0x8d, 0x53, 0x3d, 0xdc, 0x6f, 0x27, 0xef, 0xb9, 0xb6, 0x7c, 0xcf, 0xad, 0x86, 0xe8, 0x71, 0x16,
	0x1c, 0xf5, 0xdf, 0x5c, 0x37, 0x72, 0x7f, 0x5d, 0x37, 0x3e, 0x3b, 0x63, 0xf1, 0xf9, 0xe5, 0xa4,
	0xed, 0x71, 0xbf, 0xa3, 0x5f, 0x8a, 0xc9, 0xcf, 0x53, 0x31, 0xbd, 0xe8, 0xc4, 0x8b, 0x90, 0x0a,
	0x45, 0xf8, 0xe7, 0xba, 0xf1, 0x91, 0x16, 0xff, 0x92, 0xfb, 0x2c, 0xa6, 0x7e, 0x18, 0x2f, 0x70,
	0x7a, 0xdf, 0x93, 0x2b, 0x03, 0x4a, 0x89, 0x39, 0x68, 0x07, 0xaa, 0xa7, 0xce, 0x78, 0x64, 0xf5,
	0xec, 0x17, 0xb6, 0xd5, 0xaf, 0xe5, 0x50, 0x05, 0x8a, 0x03, 0xdb, 0x39, 0xa9, 0x19, 0xa8, 0x0a,
	0x65, 0x6c, 0xf5, 0x2c, 0xfb, 0x95, 0x55, 0xcb, 0xcb, 0xf2, 0xd1, 0x29, 0x76, 0x6a, 0x45, 0x19,
	0x8d, 0x2d, 0xa7, 0x5f, 0xab, 0xa0, 0x6d, 0x80, 0xf1, 0xe9, 0xc8, 0xc2, 0xae, 0x42, 0x6a, 0xe8,
	0x11, 0xdc, 0x1f, 0x0c, 0xfb, 0xf6, 0x8b, 0xd7, 0xee, 0x68, 0x78, 0x6c, 0xf7, 0x5e, 0xbb, 0x83,
	0xae, 0xd3, 0xfd, 0xce, 0xc2, 0xe3, 0xda, 0x72, 0xb9, 0xfc, 0x16, 0x7d, 0x0c, 0xbb, 0x1a, 0xee,
	0x0d, 0x9d, 0x13, 0xdc, 0xed, 0x9d, 0xb8, 0x2f, 0x87, 0xc3, 0x1f, 0x24, 0xb8, 0x34, 0x50, 0x03,
	0xf6, 0x34, 0x8a, 0x87, 0xc7, 0x96, 0x3b, 0xb2, 0xf0, 0xc0, 0x1e, 0x8f, 0xed, 0xa1, 0xa3, 0xd8,
	0xcb, 0x7c, 0x86, 0xae, 0x0e, 0x64, 0xb5, 0x97, 0xc5, 0xa3, 0x8b, 0x37, 0x37, 0x75, 0xe3, 0xea,
	0xa6, 0x6e, 0xfc, 0x7d, 0x53, 0x37, 0x7e, 0xbb, 0xad, 0xe7, 0xae, 0x6e, 0xeb, 0xb9, 0x3f, 0x6f,
	0xeb, 0xb9, 0x9f, 0x7e, 0xcc, 0x78, 0x66, 0xa7, 0xfb, 0x72, 0x4c, 0x26, 0x62, 0xfd, 0x99, 0x7a,
	0xea, 0xf1, 0x88, 0x66, 0xd3, 0x73, 0xc2, 0x82, 0x8e, 0xcf, 0xa7, 0x97, 0x33, 0x2a, 0xde, 0xfa,
	0x86, 0x29, 0x8b, 0x27, 0x25, 0xf5, 0x85, 0xf9, 0xea, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x62,
	0x3a, 0xbf, 0x78, 0xe9, 0x06, 0x00, 0x00,
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PolicyManagerCapabilities) > 0 {
		for iNdEx := len(m.PolicyManagerCapabilities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PolicyManagerCapabilities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PolicyStatuses) > 0 {
		for iNdEx := len(m.PolicyStatuses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PolicyStatuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RoleManagers) > 0 {
		for iNdEx := len(m.RoleManagers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoleManagers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ActorRoles) > 0 {
		for iNdEx := len(m.ActorRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActorRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RolePermissions) > 0 {
		for iNdEx := len(m.RolePermissions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RolePermissions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ContractHook) > 0 {
		i -= len(m.ContractHook)
		copy(dAtA[i:], m.ContractHook)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ContractHook)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActorRoles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorRoles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActorRoles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintPermissions(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleActors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleActors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleActors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Actors) > 0 {
		for iNdEx := len(m.Actors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Actors[iNdEx])
			copy(dAtA[i:], m.Actors[iNdEx])
			i = encodeVarintPermissions(dAtA, i, uint64(len(m.Actors[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleManager) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleManager) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintPermissions(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSealed {
		i--
		if m.IsSealed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsDisabled {
		i--
		if m.IsDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Action != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Role) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x18
	}
	if m.RoleId != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.RoleId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyManagerCapability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyManagerCapability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyManagerCapability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CanSeal {
		i--
		if m.CanSeal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CanDisable {
		i--
		if m.CanDisable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Action != 0 {
		i = encodeVarintPermissions(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleIDs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleIDs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoleIds) > 0 {
		dAtA2 := make([]byte, len(m.RoleIds)*10)
		var j1 int
		for _, num := range m.RoleIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPermissions(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddressVoucher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressVoucher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressVoucher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Voucher.Size()
		i -= size
		if _, err := m.Voucher.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPermissions(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ContractHook)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.RolePermissions) > 0 {
		for _, e := range m.RolePermissions {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ActorRoles) > 0 {
		for _, e := range m.ActorRoles {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.RoleManagers) > 0 {
		for _, e := range m.RoleManagers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PolicyStatuses) > 0 {
		for _, e := range m.PolicyStatuses {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PolicyManagerCapabilities) > 0 {
		for _, e := range m.PolicyManagerCapabilities {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActorRoles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *RoleActors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Actors) > 0 {
		for _, s := range m.Actors {
			l = len(s)
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *RoleManager) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *PolicyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovPermissions(uint64(m.Action))
	}
	if m.IsDisabled {
		n += 2
	}
	if m.IsSealed {
		n += 2
	}
	return n
}

func (m *Role) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.RoleId != 0 {
		n += 1 + sovPermissions(uint64(m.RoleId))
	}
	if m.Permissions != 0 {
		n += 1 + sovPermissions(uint64(m.Permissions))
	}
	return n
}

func (m *PolicyManagerCapability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPermissions(uint64(m.Action))
	}
	if m.CanDisable {
		n += 2
	}
	if m.CanSeal {
		n += 2
	}
	return n
}

func (m *RoleIDs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoleIds) > 0 {
		l = 0
		for _, e := range m.RoleIds {
			l += sovPermissions(uint64(e))
		}
		n += 1 + sovPermissions(uint64(l)) + l
	}
	return n
}

func (m *AddressVoucher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = m.Voucher.Size()
	n += 1 + l + sovPermissions(uint64(l))
	return n
}

func sovPermissions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissions(x uint64) (n int) {
	return sovPermissions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractHook", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractHook = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RolePermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RolePermissions = append(m.RolePermissions, &Role{})
			if err := m.RolePermissions[len(m.RolePermissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActorRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActorRoles = append(m.ActorRoles, &ActorRoles{})
			if err := m.ActorRoles[len(m.ActorRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleManagers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleManagers = append(m.RoleManagers, &RoleManager{})
			if err := m.RoleManagers[len(m.RoleManagers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyStatuses = append(m.PolicyStatuses, &PolicyStatus{})
			if err := m.PolicyStatuses[len(m.PolicyStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyManagerCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyManagerCapabilities = append(m.PolicyManagerCapabilities, &PolicyManagerCapability{})
			if err := m.PolicyManagerCapabilities[len(m.PolicyManagerCapabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorRoles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorRoles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorRoles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleActors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleActors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleActors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actors = append(m.Actors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDisabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSealed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSealed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			m.RoleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyManagerCapability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyManagerCapability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyManagerCapability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDisable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDisable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSeal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSeal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermissions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoleIds = append(m.RoleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPermissions
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPermissions
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPermissions
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoleIds) == 0 {
					m.RoleIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPermissions
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoleIds = append(m.RoleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressVoucher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressVoucher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressVoucher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voucher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Voucher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissions = fmt.Errorf("proto: unexpected end of group")
)
