// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/exchange/v1beta1/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/InjectiveLabs/sdk-go/chain/oracle/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventBatchSpotExecution struct {
	MarketId      string        `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsBuy         bool          `protobuf:"varint,2,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	ExecutionType ExecutionType `protobuf:"varint,3,opt,name=executionType,proto3,enum=injective.exchange.v1beta1.ExecutionType" json:"executionType,omitempty"`
	Trades        []*TradeLog   `protobuf:"bytes,4,rep,name=trades,proto3" json:"trades,omitempty"`
}

func (m *EventBatchSpotExecution) Reset()         { *m = EventBatchSpotExecution{} }
func (m *EventBatchSpotExecution) String() string { return proto.CompactTextString(m) }
func (*EventBatchSpotExecution) ProtoMessage()    {}
func (*EventBatchSpotExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{0}
}
func (m *EventBatchSpotExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBatchSpotExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBatchSpotExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBatchSpotExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBatchSpotExecution.Merge(m, src)
}
func (m *EventBatchSpotExecution) XXX_Size() int {
	return m.Size()
}
func (m *EventBatchSpotExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBatchSpotExecution.DiscardUnknown(m)
}

var xxx_messageInfo_EventBatchSpotExecution proto.InternalMessageInfo

func (m *EventBatchSpotExecution) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventBatchSpotExecution) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *EventBatchSpotExecution) GetExecutionType() ExecutionType {
	if m != nil {
		return m.ExecutionType
	}
	return ExecutionType_UnspecifiedExecutionType
}

func (m *EventBatchSpotExecution) GetTrades() []*TradeLog {
	if m != nil {
		return m.Trades
	}
	return nil
}

type EventBatchDerivativeExecution struct {
	MarketId      string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsBuy         bool   `protobuf:"varint,2,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	IsLiquidation bool   `protobuf:"varint,3,opt,name=is_liquidation,json=isLiquidation,proto3" json:"is_liquidation,omitempty"`
	// nil for time expiry futures
	CumulativeFunding *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=cumulative_funding,json=cumulativeFunding,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"cumulative_funding,omitempty"`
	ExecutionType     ExecutionType                           `protobuf:"varint,5,opt,name=executionType,proto3,enum=injective.exchange.v1beta1.ExecutionType" json:"executionType,omitempty"`
	Trades            []*DerivativeTradeLog                   `protobuf:"bytes,6,rep,name=trades,proto3" json:"trades,omitempty"`
}

func (m *EventBatchDerivativeExecution) Reset()         { *m = EventBatchDerivativeExecution{} }
func (m *EventBatchDerivativeExecution) String() string { return proto.CompactTextString(m) }
func (*EventBatchDerivativeExecution) ProtoMessage()    {}
func (*EventBatchDerivativeExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{1}
}
func (m *EventBatchDerivativeExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBatchDerivativeExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBatchDerivativeExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBatchDerivativeExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBatchDerivativeExecution.Merge(m, src)
}
func (m *EventBatchDerivativeExecution) XXX_Size() int {
	return m.Size()
}
func (m *EventBatchDerivativeExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBatchDerivativeExecution.DiscardUnknown(m)
}

var xxx_messageInfo_EventBatchDerivativeExecution proto.InternalMessageInfo

func (m *EventBatchDerivativeExecution) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventBatchDerivativeExecution) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *EventBatchDerivativeExecution) GetIsLiquidation() bool {
	if m != nil {
		return m.IsLiquidation
	}
	return false
}

func (m *EventBatchDerivativeExecution) GetExecutionType() ExecutionType {
	if m != nil {
		return m.ExecutionType
	}
	return ExecutionType_UnspecifiedExecutionType
}

func (m *EventBatchDerivativeExecution) GetTrades() []*DerivativeTradeLog {
	if m != nil {
		return m.Trades
	}
	return nil
}

type EventLostFundsFromLiquidation struct {
	MarketId                           string                                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId                       []byte                                 `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	LostFundsFromAvailableDuringPayout github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=lost_funds_from_available_during_payout,json=lostFundsFromAvailableDuringPayout,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"lost_funds_from_available_during_payout"`
	LostFundsFromOrderCancels          github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=lost_funds_from_order_cancels,json=lostFundsFromOrderCancels,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"lost_funds_from_order_cancels"`
}

func (m *EventLostFundsFromLiquidation) Reset()         { *m = EventLostFundsFromLiquidation{} }
func (m *EventLostFundsFromLiquidation) String() string { return proto.CompactTextString(m) }
func (*EventLostFundsFromLiquidation) ProtoMessage()    {}
func (*EventLostFundsFromLiquidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{2}
}
func (m *EventLostFundsFromLiquidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLostFundsFromLiquidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLostFundsFromLiquidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLostFundsFromLiquidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLostFundsFromLiquidation.Merge(m, src)
}
func (m *EventLostFundsFromLiquidation) XXX_Size() int {
	return m.Size()
}
func (m *EventLostFundsFromLiquidation) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLostFundsFromLiquidation.DiscardUnknown(m)
}

var xxx_messageInfo_EventLostFundsFromLiquidation proto.InternalMessageInfo

func (m *EventLostFundsFromLiquidation) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventLostFundsFromLiquidation) GetSubaccountId() []byte {
	if m != nil {
		return m.SubaccountId
	}
	return nil
}

type EventBatchDerivativePosition struct {
	MarketId  string                `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Positions []*SubaccountPosition `protobuf:"bytes,2,rep,name=positions,proto3" json:"positions,omitempty"`
}

func (m *EventBatchDerivativePosition) Reset()         { *m = EventBatchDerivativePosition{} }
func (m *EventBatchDerivativePosition) String() string { return proto.CompactTextString(m) }
func (*EventBatchDerivativePosition) ProtoMessage()    {}
func (*EventBatchDerivativePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{3}
}
func (m *EventBatchDerivativePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBatchDerivativePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBatchDerivativePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBatchDerivativePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBatchDerivativePosition.Merge(m, src)
}
func (m *EventBatchDerivativePosition) XXX_Size() int {
	return m.Size()
}
func (m *EventBatchDerivativePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBatchDerivativePosition.DiscardUnknown(m)
}

var xxx_messageInfo_EventBatchDerivativePosition proto.InternalMessageInfo

func (m *EventBatchDerivativePosition) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventBatchDerivativePosition) GetPositions() []*SubaccountPosition {
	if m != nil {
		return m.Positions
	}
	return nil
}

type EventDerivativeMarketPaused struct {
	MarketId          string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SettlePrice       string `protobuf:"bytes,2,opt,name=settle_price,json=settlePrice,proto3" json:"settle_price,omitempty"`
	TotalMissingFunds string `protobuf:"bytes,3,opt,name=total_missing_funds,json=totalMissingFunds,proto3" json:"total_missing_funds,omitempty"`
	MissingFundsRate  string `protobuf:"bytes,4,opt,name=missing_funds_rate,json=missingFundsRate,proto3" json:"missing_funds_rate,omitempty"`
}

func (m *EventDerivativeMarketPaused) Reset()         { *m = EventDerivativeMarketPaused{} }
func (m *EventDerivativeMarketPaused) String() string { return proto.CompactTextString(m) }
func (*EventDerivativeMarketPaused) ProtoMessage()    {}
func (*EventDerivativeMarketPaused) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{4}
}
func (m *EventDerivativeMarketPaused) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDerivativeMarketPaused) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDerivativeMarketPaused.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDerivativeMarketPaused) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDerivativeMarketPaused.Merge(m, src)
}
func (m *EventDerivativeMarketPaused) XXX_Size() int {
	return m.Size()
}
func (m *EventDerivativeMarketPaused) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDerivativeMarketPaused.DiscardUnknown(m)
}

var xxx_messageInfo_EventDerivativeMarketPaused proto.InternalMessageInfo

func (m *EventDerivativeMarketPaused) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventDerivativeMarketPaused) GetSettlePrice() string {
	if m != nil {
		return m.SettlePrice
	}
	return ""
}

func (m *EventDerivativeMarketPaused) GetTotalMissingFunds() string {
	if m != nil {
		return m.TotalMissingFunds
	}
	return ""
}

func (m *EventDerivativeMarketPaused) GetMissingFundsRate() string {
	if m != nil {
		return m.MissingFundsRate
	}
	return ""
}

type EventMarketBeyondBankruptcy struct {
	MarketId           string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SettlePrice        string `protobuf:"bytes,2,opt,name=settle_price,json=settlePrice,proto3" json:"settle_price,omitempty"`
	MissingMarketFunds string `protobuf:"bytes,3,opt,name=missing_market_funds,json=missingMarketFunds,proto3" json:"missing_market_funds,omitempty"`
}

func (m *EventMarketBeyondBankruptcy) Reset()         { *m = EventMarketBeyondBankruptcy{} }
func (m *EventMarketBeyondBankruptcy) String() string { return proto.CompactTextString(m) }
func (*EventMarketBeyondBankruptcy) ProtoMessage()    {}
func (*EventMarketBeyondBankruptcy) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{5}
}
func (m *EventMarketBeyondBankruptcy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMarketBeyondBankruptcy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMarketBeyondBankruptcy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMarketBeyondBankruptcy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMarketBeyondBankruptcy.Merge(m, src)
}
func (m *EventMarketBeyondBankruptcy) XXX_Size() int {
	return m.Size()
}
func (m *EventMarketBeyondBankruptcy) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMarketBeyondBankruptcy.DiscardUnknown(m)
}

var xxx_messageInfo_EventMarketBeyondBankruptcy proto.InternalMessageInfo

func (m *EventMarketBeyondBankruptcy) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventMarketBeyondBankruptcy) GetSettlePrice() string {
	if m != nil {
		return m.SettlePrice
	}
	return ""
}

func (m *EventMarketBeyondBankruptcy) GetMissingMarketFunds() string {
	if m != nil {
		return m.MissingMarketFunds
	}
	return ""
}

type EventAllPositionsHaircut struct {
	MarketId         string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SettlePrice      string `protobuf:"bytes,2,opt,name=settle_price,json=settlePrice,proto3" json:"settle_price,omitempty"`
	MissingFundsRate string `protobuf:"bytes,3,opt,name=missing_funds_rate,json=missingFundsRate,proto3" json:"missing_funds_rate,omitempty"`
}

func (m *EventAllPositionsHaircut) Reset()         { *m = EventAllPositionsHaircut{} }
func (m *EventAllPositionsHaircut) String() string { return proto.CompactTextString(m) }
func (*EventAllPositionsHaircut) ProtoMessage()    {}
func (*EventAllPositionsHaircut) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{6}
}
func (m *EventAllPositionsHaircut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAllPositionsHaircut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAllPositionsHaircut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAllPositionsHaircut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAllPositionsHaircut.Merge(m, src)
}
func (m *EventAllPositionsHaircut) XXX_Size() int {
	return m.Size()
}
func (m *EventAllPositionsHaircut) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAllPositionsHaircut.DiscardUnknown(m)
}

var xxx_messageInfo_EventAllPositionsHaircut proto.InternalMessageInfo

func (m *EventAllPositionsHaircut) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventAllPositionsHaircut) GetSettlePrice() string {
	if m != nil {
		return m.SettlePrice
	}
	return ""
}

func (m *EventAllPositionsHaircut) GetMissingFundsRate() string {
	if m != nil {
		return m.MissingFundsRate
	}
	return ""
}

type EventBinaryOptionsMarketUpdate struct {
	Market BinaryOptionsMarket `protobuf:"bytes,1,opt,name=market,proto3" json:"market"`
}

func (m *EventBinaryOptionsMarketUpdate) Reset()         { *m = EventBinaryOptionsMarketUpdate{} }
func (m *EventBinaryOptionsMarketUpdate) String() string { return proto.CompactTextString(m) }
func (*EventBinaryOptionsMarketUpdate) ProtoMessage()    {}
func (*EventBinaryOptionsMarketUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{7}
}
func (m *EventBinaryOptionsMarketUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBinaryOptionsMarketUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBinaryOptionsMarketUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBinaryOptionsMarketUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBinaryOptionsMarketUpdate.Merge(m, src)
}
func (m *EventBinaryOptionsMarketUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventBinaryOptionsMarketUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBinaryOptionsMarketUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventBinaryOptionsMarketUpdate proto.InternalMessageInfo

func (m *EventBinaryOptionsMarketUpdate) GetMarket() BinaryOptionsMarket {
	if m != nil {
		return m.Market
	}
	return BinaryOptionsMarket{}
}

type EventNewSpotOrders struct {
	MarketId   string            `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	BuyOrders  []*SpotLimitOrder `protobuf:"bytes,2,rep,name=buy_orders,json=buyOrders,proto3" json:"buy_orders,omitempty"`
	SellOrders []*SpotLimitOrder `protobuf:"bytes,3,rep,name=sell_orders,json=sellOrders,proto3" json:"sell_orders,omitempty"`
}

func (m *EventNewSpotOrders) Reset()         { *m = EventNewSpotOrders{} }
func (m *EventNewSpotOrders) String() string { return proto.CompactTextString(m) }
func (*EventNewSpotOrders) ProtoMessage()    {}
func (*EventNewSpotOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{8}
}
func (m *EventNewSpotOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNewSpotOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNewSpotOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNewSpotOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNewSpotOrders.Merge(m, src)
}
func (m *EventNewSpotOrders) XXX_Size() int {
	return m.Size()
}
func (m *EventNewSpotOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNewSpotOrders.DiscardUnknown(m)
}

var xxx_messageInfo_EventNewSpotOrders proto.InternalMessageInfo

func (m *EventNewSpotOrders) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventNewSpotOrders) GetBuyOrders() []*SpotLimitOrder {
	if m != nil {
		return m.BuyOrders
	}
	return nil
}

func (m *EventNewSpotOrders) GetSellOrders() []*SpotLimitOrder {
	if m != nil {
		return m.SellOrders
	}
	return nil
}

type EventNewDerivativeOrders struct {
	MarketId   string                  `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	BuyOrders  []*DerivativeLimitOrder `protobuf:"bytes,2,rep,name=buy_orders,json=buyOrders,proto3" json:"buy_orders,omitempty"`
	SellOrders []*DerivativeLimitOrder `protobuf:"bytes,3,rep,name=sell_orders,json=sellOrders,proto3" json:"sell_orders,omitempty"`
}

func (m *EventNewDerivativeOrders) Reset()         { *m = EventNewDerivativeOrders{} }
func (m *EventNewDerivativeOrders) String() string { return proto.CompactTextString(m) }
func (*EventNewDerivativeOrders) ProtoMessage()    {}
func (*EventNewDerivativeOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{9}
}
func (m *EventNewDerivativeOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNewDerivativeOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNewDerivativeOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNewDerivativeOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNewDerivativeOrders.Merge(m, src)
}
func (m *EventNewDerivativeOrders) XXX_Size() int {
	return m.Size()
}
func (m *EventNewDerivativeOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNewDerivativeOrders.DiscardUnknown(m)
}

var xxx_messageInfo_EventNewDerivativeOrders proto.InternalMessageInfo

func (m *EventNewDerivativeOrders) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventNewDerivativeOrders) GetBuyOrders() []*DerivativeLimitOrder {
	if m != nil {
		return m.BuyOrders
	}
	return nil
}

func (m *EventNewDerivativeOrders) GetSellOrders() []*DerivativeLimitOrder {
	if m != nil {
		return m.SellOrders
	}
	return nil
}

type EventCancelSpotOrder struct {
	MarketId string         `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Order    SpotLimitOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *EventCancelSpotOrder) Reset()         { *m = EventCancelSpotOrder{} }
func (m *EventCancelSpotOrder) String() string { return proto.CompactTextString(m) }
func (*EventCancelSpotOrder) ProtoMessage()    {}
func (*EventCancelSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{10}
}
func (m *EventCancelSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelSpotOrder.Merge(m, src)
}
func (m *EventCancelSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelSpotOrder proto.InternalMessageInfo

func (m *EventCancelSpotOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventCancelSpotOrder) GetOrder() SpotLimitOrder {
	if m != nil {
		return m.Order
	}
	return SpotLimitOrder{}
}

type EventSpotMarketUpdate struct {
	Market SpotMarket `protobuf:"bytes,1,opt,name=market,proto3" json:"market"`
}

func (m *EventSpotMarketUpdate) Reset()         { *m = EventSpotMarketUpdate{} }
func (m *EventSpotMarketUpdate) String() string { return proto.CompactTextString(m) }
func (*EventSpotMarketUpdate) ProtoMessage()    {}
func (*EventSpotMarketUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{11}
}
func (m *EventSpotMarketUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSpotMarketUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSpotMarketUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSpotMarketUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSpotMarketUpdate.Merge(m, src)
}
func (m *EventSpotMarketUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventSpotMarketUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSpotMarketUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventSpotMarketUpdate proto.InternalMessageInfo

func (m *EventSpotMarketUpdate) GetMarket() SpotMarket {
	if m != nil {
		return m.Market
	}
	return SpotMarket{}
}

type EventPerpetualMarketUpdate struct {
	Market              DerivativeMarket        `protobuf:"bytes,1,opt,name=market,proto3" json:"market"`
	PerpetualMarketInfo *PerpetualMarketInfo    `protobuf:"bytes,2,opt,name=perpetual_market_info,json=perpetualMarketInfo,proto3" json:"perpetual_market_info,omitempty"`
	Funding             *PerpetualMarketFunding `protobuf:"bytes,3,opt,name=funding,proto3" json:"funding,omitempty"`
}

func (m *EventPerpetualMarketUpdate) Reset()         { *m = EventPerpetualMarketUpdate{} }
func (m *EventPerpetualMarketUpdate) String() string { return proto.CompactTextString(m) }
func (*EventPerpetualMarketUpdate) ProtoMessage()    {}
func (*EventPerpetualMarketUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{12}
}
func (m *EventPerpetualMarketUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPerpetualMarketUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPerpetualMarketUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPerpetualMarketUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPerpetualMarketUpdate.Merge(m, src)
}
func (m *EventPerpetualMarketUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventPerpetualMarketUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPerpetualMarketUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventPerpetualMarketUpdate proto.InternalMessageInfo

func (m *EventPerpetualMarketUpdate) GetMarket() DerivativeMarket {
	if m != nil {
		return m.Market
	}
	return DerivativeMarket{}
}

func (m *EventPerpetualMarketUpdate) GetPerpetualMarketInfo() *PerpetualMarketInfo {
	if m != nil {
		return m.PerpetualMarketInfo
	}
	return nil
}

func (m *EventPerpetualMarketUpdate) GetFunding() *PerpetualMarketFunding {
	if m != nil {
		return m.Funding
	}
	return nil
}

type EventExpiryFuturesMarketUpdate struct {
	Market                  DerivativeMarket         `protobuf:"bytes,1,opt,name=market,proto3" json:"market"`
	ExpiryFuturesMarketInfo *ExpiryFuturesMarketInfo `protobuf:"bytes,3,opt,name=expiry_futures_market_info,json=expiryFuturesMarketInfo,proto3" json:"expiry_futures_market_info,omitempty"`
}

func (m *EventExpiryFuturesMarketUpdate) Reset()         { *m = EventExpiryFuturesMarketUpdate{} }
func (m *EventExpiryFuturesMarketUpdate) String() string { return proto.CompactTextString(m) }
func (*EventExpiryFuturesMarketUpdate) ProtoMessage()    {}
func (*EventExpiryFuturesMarketUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{13}
}
func (m *EventExpiryFuturesMarketUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventExpiryFuturesMarketUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventExpiryFuturesMarketUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventExpiryFuturesMarketUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventExpiryFuturesMarketUpdate.Merge(m, src)
}
func (m *EventExpiryFuturesMarketUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventExpiryFuturesMarketUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventExpiryFuturesMarketUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventExpiryFuturesMarketUpdate proto.InternalMessageInfo

func (m *EventExpiryFuturesMarketUpdate) GetMarket() DerivativeMarket {
	if m != nil {
		return m.Market
	}
	return DerivativeMarket{}
}

func (m *EventExpiryFuturesMarketUpdate) GetExpiryFuturesMarketInfo() *ExpiryFuturesMarketInfo {
	if m != nil {
		return m.ExpiryFuturesMarketInfo
	}
	return nil
}

type EventPerpetualMarketFundingUpdate struct {
	MarketId        string                                  `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Funding         PerpetualMarketFunding                  `protobuf:"bytes,2,opt,name=funding,proto3" json:"funding"`
	IsHourlyFunding bool                                    `protobuf:"varint,3,opt,name=is_hourly_funding,json=isHourlyFunding,proto3" json:"is_hourly_funding,omitempty"`
	FundingRate     *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=funding_rate,json=fundingRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"funding_rate,omitempty"`
	MarkPrice       *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=mark_price,json=markPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mark_price,omitempty"`
}

func (m *EventPerpetualMarketFundingUpdate) Reset()         { *m = EventPerpetualMarketFundingUpdate{} }
func (m *EventPerpetualMarketFundingUpdate) String() string { return proto.CompactTextString(m) }
func (*EventPerpetualMarketFundingUpdate) ProtoMessage()    {}
func (*EventPerpetualMarketFundingUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{14}
}
func (m *EventPerpetualMarketFundingUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPerpetualMarketFundingUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPerpetualMarketFundingUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPerpetualMarketFundingUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPerpetualMarketFundingUpdate.Merge(m, src)
}
func (m *EventPerpetualMarketFundingUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventPerpetualMarketFundingUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPerpetualMarketFundingUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventPerpetualMarketFundingUpdate proto.InternalMessageInfo

func (m *EventPerpetualMarketFundingUpdate) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventPerpetualMarketFundingUpdate) GetFunding() PerpetualMarketFunding {
	if m != nil {
		return m.Funding
	}
	return PerpetualMarketFunding{}
}

func (m *EventPerpetualMarketFundingUpdate) GetIsHourlyFunding() bool {
	if m != nil {
		return m.IsHourlyFunding
	}
	return false
}

type EventSubaccountDeposit struct {
	SrcAddress   string     `protobuf:"bytes,1,opt,name=src_address,json=srcAddress,proto3" json:"src_address,omitempty"`
	SubaccountId []byte     `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Amount       types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *EventSubaccountDeposit) Reset()         { *m = EventSubaccountDeposit{} }
func (m *EventSubaccountDeposit) String() string { return proto.CompactTextString(m) }
func (*EventSubaccountDeposit) ProtoMessage()    {}
func (*EventSubaccountDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{15}
}
func (m *EventSubaccountDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSubaccountDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSubaccountDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSubaccountDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSubaccountDeposit.Merge(m, src)
}
func (m *EventSubaccountDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventSubaccountDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSubaccountDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventSubaccountDeposit proto.InternalMessageInfo

func (m *EventSubaccountDeposit) GetSrcAddress() string {
	if m != nil {
		return m.SrcAddress
	}
	return ""
}

func (m *EventSubaccountDeposit) GetSubaccountId() []byte {
	if m != nil {
		return m.SubaccountId
	}
	return nil
}

func (m *EventSubaccountDeposit) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

type EventSubaccountWithdraw struct {
	SubaccountId []byte     `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	DstAddress   string     `protobuf:"bytes,2,opt,name=dst_address,json=dstAddress,proto3" json:"dst_address,omitempty"`
	Amount       types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *EventSubaccountWithdraw) Reset()         { *m = EventSubaccountWithdraw{} }
func (m *EventSubaccountWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventSubaccountWithdraw) ProtoMessage()    {}
func (*EventSubaccountWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{16}
}
func (m *EventSubaccountWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSubaccountWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSubaccountWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSubaccountWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSubaccountWithdraw.Merge(m, src)
}
func (m *EventSubaccountWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventSubaccountWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSubaccountWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventSubaccountWithdraw proto.InternalMessageInfo

func (m *EventSubaccountWithdraw) GetSubaccountId() []byte {
	if m != nil {
		return m.SubaccountId
	}
	return nil
}

func (m *EventSubaccountWithdraw) GetDstAddress() string {
	if m != nil {
		return m.DstAddress
	}
	return ""
}

func (m *EventSubaccountWithdraw) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

type EventSubaccountBalanceTransfer struct {
	SrcSubaccountId string     `protobuf:"bytes,1,opt,name=src_subaccount_id,json=srcSubaccountId,proto3" json:"src_subaccount_id,omitempty"`
	DstSubaccountId string     `protobuf:"bytes,2,opt,name=dst_subaccount_id,json=dstSubaccountId,proto3" json:"dst_subaccount_id,omitempty"`
	Amount          types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *EventSubaccountBalanceTransfer) Reset()         { *m = EventSubaccountBalanceTransfer{} }
func (m *EventSubaccountBalanceTransfer) String() string { return proto.CompactTextString(m) }
func (*EventSubaccountBalanceTransfer) ProtoMessage()    {}
func (*EventSubaccountBalanceTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{17}
}
func (m *EventSubaccountBalanceTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSubaccountBalanceTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSubaccountBalanceTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSubaccountBalanceTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSubaccountBalanceTransfer.Merge(m, src)
}
func (m *EventSubaccountBalanceTransfer) XXX_Size() int {
	return m.Size()
}
func (m *EventSubaccountBalanceTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSubaccountBalanceTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_EventSubaccountBalanceTransfer proto.InternalMessageInfo

func (m *EventSubaccountBalanceTransfer) GetSrcSubaccountId() string {
	if m != nil {
		return m.SrcSubaccountId
	}
	return ""
}

func (m *EventSubaccountBalanceTransfer) GetDstSubaccountId() string {
	if m != nil {
		return m.DstSubaccountId
	}
	return ""
}

func (m *EventSubaccountBalanceTransfer) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

type EventBatchDepositUpdate struct {
	DepositUpdates []*DepositUpdate `protobuf:"bytes,1,rep,name=deposit_updates,json=depositUpdates,proto3" json:"deposit_updates,omitempty"`
}

func (m *EventBatchDepositUpdate) Reset()         { *m = EventBatchDepositUpdate{} }
func (m *EventBatchDepositUpdate) String() string { return proto.CompactTextString(m) }
func (*EventBatchDepositUpdate) ProtoMessage()    {}
func (*EventBatchDepositUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{18}
}
func (m *EventBatchDepositUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBatchDepositUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBatchDepositUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBatchDepositUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBatchDepositUpdate.Merge(m, src)
}
func (m *EventBatchDepositUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventBatchDepositUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBatchDepositUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventBatchDepositUpdate proto.InternalMessageInfo

func (m *EventBatchDepositUpdate) GetDepositUpdates() []*DepositUpdate {
	if m != nil {
		return m.DepositUpdates
	}
	return nil
}

type DerivativeMarketOrderCancel struct {
	MarketOrder    *DerivativeMarketOrder                 `protobuf:"bytes,1,opt,name=market_order,json=marketOrder,proto3" json:"market_order,omitempty"`
	CancelQuantity github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=cancel_quantity,json=cancelQuantity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"cancel_quantity"`
}

func (m *DerivativeMarketOrderCancel) Reset()         { *m = DerivativeMarketOrderCancel{} }
func (m *DerivativeMarketOrderCancel) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarketOrderCancel) ProtoMessage()    {}
func (*DerivativeMarketOrderCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{19}
}
func (m *DerivativeMarketOrderCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarketOrderCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarketOrderCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarketOrderCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarketOrderCancel.Merge(m, src)
}
func (m *DerivativeMarketOrderCancel) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarketOrderCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarketOrderCancel.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarketOrderCancel proto.InternalMessageInfo

func (m *DerivativeMarketOrderCancel) GetMarketOrder() *DerivativeMarketOrder {
	if m != nil {
		return m.MarketOrder
	}
	return nil
}

type EventCancelDerivativeOrder struct {
	MarketId          string                       `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsLimitCancel     bool                         `protobuf:"varint,2,opt,name=isLimitCancel,proto3" json:"isLimitCancel,omitempty"`
	LimitOrder        *DerivativeLimitOrder        `protobuf:"bytes,3,opt,name=limit_order,json=limitOrder,proto3" json:"limit_order,omitempty"`
	MarketOrderCancel *DerivativeMarketOrderCancel `protobuf:"bytes,4,opt,name=market_order_cancel,json=marketOrderCancel,proto3" json:"market_order_cancel,omitempty"`
}

func (m *EventCancelDerivativeOrder) Reset()         { *m = EventCancelDerivativeOrder{} }
func (m *EventCancelDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*EventCancelDerivativeOrder) ProtoMessage()    {}
func (*EventCancelDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{20}
}
func (m *EventCancelDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelDerivativeOrder.Merge(m, src)
}
func (m *EventCancelDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelDerivativeOrder proto.InternalMessageInfo

func (m *EventCancelDerivativeOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventCancelDerivativeOrder) GetIsLimitCancel() bool {
	if m != nil {
		return m.IsLimitCancel
	}
	return false
}

func (m *EventCancelDerivativeOrder) GetLimitOrder() *DerivativeLimitOrder {
	if m != nil {
		return m.LimitOrder
	}
	return nil
}

func (m *EventCancelDerivativeOrder) GetMarketOrderCancel() *DerivativeMarketOrderCancel {
	if m != nil {
		return m.MarketOrderCancel
	}
	return nil
}

type EventFeeDiscountSchedule struct {
	Schedule *FeeDiscountSchedule `protobuf:"bytes,1,opt,name=schedule,proto3" json:"schedule,omitempty"`
}

func (m *EventFeeDiscountSchedule) Reset()         { *m = EventFeeDiscountSchedule{} }
func (m *EventFeeDiscountSchedule) String() string { return proto.CompactTextString(m) }
func (*EventFeeDiscountSchedule) ProtoMessage()    {}
func (*EventFeeDiscountSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{21}
}
func (m *EventFeeDiscountSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFeeDiscountSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFeeDiscountSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFeeDiscountSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFeeDiscountSchedule.Merge(m, src)
}
func (m *EventFeeDiscountSchedule) XXX_Size() int {
	return m.Size()
}
func (m *EventFeeDiscountSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFeeDiscountSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_EventFeeDiscountSchedule proto.InternalMessageInfo

func (m *EventFeeDiscountSchedule) GetSchedule() *FeeDiscountSchedule {
	if m != nil {
		return m.Schedule
	}
	return nil
}

type EventTradingRewardCampaignUpdate struct {
	CampaignInfo        *TradingRewardCampaignInfo `protobuf:"bytes,1,opt,name=campaign_info,json=campaignInfo,proto3" json:"campaign_info,omitempty"`
	CampaignRewardPools []*CampaignRewardPool      `protobuf:"bytes,2,rep,name=campaign_reward_pools,json=campaignRewardPools,proto3" json:"campaign_reward_pools,omitempty"`
}

func (m *EventTradingRewardCampaignUpdate) Reset()         { *m = EventTradingRewardCampaignUpdate{} }
func (m *EventTradingRewardCampaignUpdate) String() string { return proto.CompactTextString(m) }
func (*EventTradingRewardCampaignUpdate) ProtoMessage()    {}
func (*EventTradingRewardCampaignUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{22}
}
func (m *EventTradingRewardCampaignUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradingRewardCampaignUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradingRewardCampaignUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradingRewardCampaignUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradingRewardCampaignUpdate.Merge(m, src)
}
func (m *EventTradingRewardCampaignUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventTradingRewardCampaignUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradingRewardCampaignUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradingRewardCampaignUpdate proto.InternalMessageInfo

func (m *EventTradingRewardCampaignUpdate) GetCampaignInfo() *TradingRewardCampaignInfo {
	if m != nil {
		return m.CampaignInfo
	}
	return nil
}

func (m *EventTradingRewardCampaignUpdate) GetCampaignRewardPools() []*CampaignRewardPool {
	if m != nil {
		return m.CampaignRewardPools
	}
	return nil
}

type EventTradingRewardDistribution struct {
	AccountRewards []*AccountRewards `protobuf:"bytes,1,rep,name=account_rewards,json=accountRewards,proto3" json:"account_rewards,omitempty"`
}

func (m *EventTradingRewardDistribution) Reset()         { *m = EventTradingRewardDistribution{} }
func (m *EventTradingRewardDistribution) String() string { return proto.CompactTextString(m) }
func (*EventTradingRewardDistribution) ProtoMessage()    {}
func (*EventTradingRewardDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{23}
}
func (m *EventTradingRewardDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradingRewardDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradingRewardDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradingRewardDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradingRewardDistribution.Merge(m, src)
}
func (m *EventTradingRewardDistribution) XXX_Size() int {
	return m.Size()
}
func (m *EventTradingRewardDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradingRewardDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradingRewardDistribution proto.InternalMessageInfo

func (m *EventTradingRewardDistribution) GetAccountRewards() []*AccountRewards {
	if m != nil {
		return m.AccountRewards
	}
	return nil
}

type EventNewConditionalDerivativeOrder struct {
	MarketId string           `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Order    *DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
	Hash     []byte           `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	IsMarket bool             `protobuf:"varint,4,opt,name=is_market,json=isMarket,proto3" json:"is_market,omitempty"`
}

func (m *EventNewConditionalDerivativeOrder) Reset()         { *m = EventNewConditionalDerivativeOrder{} }
func (m *EventNewConditionalDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*EventNewConditionalDerivativeOrder) ProtoMessage()    {}
func (*EventNewConditionalDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{24}
}
func (m *EventNewConditionalDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNewConditionalDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNewConditionalDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNewConditionalDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNewConditionalDerivativeOrder.Merge(m, src)
}
func (m *EventNewConditionalDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *EventNewConditionalDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNewConditionalDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_EventNewConditionalDerivativeOrder proto.InternalMessageInfo

func (m *EventNewConditionalDerivativeOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventNewConditionalDerivativeOrder) GetOrder() *DerivativeOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *EventNewConditionalDerivativeOrder) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *EventNewConditionalDerivativeOrder) GetIsMarket() bool {
	if m != nil {
		return m.IsMarket
	}
	return false
}

type EventCancelConditionalDerivativeOrder struct {
	MarketId      string                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsLimitCancel bool                   `protobuf:"varint,2,opt,name=isLimitCancel,proto3" json:"isLimitCancel,omitempty"`
	LimitOrder    *DerivativeLimitOrder  `protobuf:"bytes,3,opt,name=limit_order,json=limitOrder,proto3" json:"limit_order,omitempty"`
	MarketOrder   *DerivativeMarketOrder `protobuf:"bytes,4,opt,name=market_order,json=marketOrder,proto3" json:"market_order,omitempty"`
}

func (m *EventCancelConditionalDerivativeOrder) Reset()         { *m = EventCancelConditionalDerivativeOrder{} }
func (m *EventCancelConditionalDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*EventCancelConditionalDerivativeOrder) ProtoMessage()    {}
func (*EventCancelConditionalDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{25}
}
func (m *EventCancelConditionalDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelConditionalDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelConditionalDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelConditionalDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelConditionalDerivativeOrder.Merge(m, src)
}
func (m *EventCancelConditionalDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelConditionalDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelConditionalDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelConditionalDerivativeOrder proto.InternalMessageInfo

func (m *EventCancelConditionalDerivativeOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *EventCancelConditionalDerivativeOrder) GetIsLimitCancel() bool {
	if m != nil {
		return m.IsLimitCancel
	}
	return false
}

func (m *EventCancelConditionalDerivativeOrder) GetLimitOrder() *DerivativeLimitOrder {
	if m != nil {
		return m.LimitOrder
	}
	return nil
}

func (m *EventCancelConditionalDerivativeOrder) GetMarketOrder() *DerivativeMarketOrder {
	if m != nil {
		return m.MarketOrder
	}
	return nil
}

type EventConditionalDerivativeOrderTrigger struct {
	MarketId           []byte `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsLimitTrigger     bool   `protobuf:"varint,2,opt,name=isLimitTrigger,proto3" json:"isLimitTrigger,omitempty"`
	TriggeredOrderHash []byte `protobuf:"bytes,3,opt,name=triggered_order_hash,json=triggeredOrderHash,proto3" json:"triggered_order_hash,omitempty"`
	PlacedOrderHash    []byte `protobuf:"bytes,4,opt,name=placed_order_hash,json=placedOrderHash,proto3" json:"placed_order_hash,omitempty"`
}

func (m *EventConditionalDerivativeOrderTrigger) Reset() {
	*m = EventConditionalDerivativeOrderTrigger{}
}
func (m *EventConditionalDerivativeOrderTrigger) String() string { return proto.CompactTextString(m) }
func (*EventConditionalDerivativeOrderTrigger) ProtoMessage()    {}
func (*EventConditionalDerivativeOrderTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{26}
}
func (m *EventConditionalDerivativeOrderTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventConditionalDerivativeOrderTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventConditionalDerivativeOrderTrigger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventConditionalDerivativeOrderTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventConditionalDerivativeOrderTrigger.Merge(m, src)
}
func (m *EventConditionalDerivativeOrderTrigger) XXX_Size() int {
	return m.Size()
}
func (m *EventConditionalDerivativeOrderTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_EventConditionalDerivativeOrderTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_EventConditionalDerivativeOrderTrigger proto.InternalMessageInfo

func (m *EventConditionalDerivativeOrderTrigger) GetMarketId() []byte {
	if m != nil {
		return m.MarketId
	}
	return nil
}

func (m *EventConditionalDerivativeOrderTrigger) GetIsLimitTrigger() bool {
	if m != nil {
		return m.IsLimitTrigger
	}
	return false
}

func (m *EventConditionalDerivativeOrderTrigger) GetTriggeredOrderHash() []byte {
	if m != nil {
		return m.TriggeredOrderHash
	}
	return nil
}

func (m *EventConditionalDerivativeOrderTrigger) GetPlacedOrderHash() []byte {
	if m != nil {
		return m.PlacedOrderHash
	}
	return nil
}

type EventOrderFail struct {
	Account []byte   `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	Hashes  [][]byte `protobuf:"bytes,2,rep,name=hashes,proto3" json:"hashes,omitempty"`
	Flags   []uint32 `protobuf:"varint,3,rep,packed,name=flags,proto3" json:"flags,omitempty"`
}

func (m *EventOrderFail) Reset()         { *m = EventOrderFail{} }
func (m *EventOrderFail) String() string { return proto.CompactTextString(m) }
func (*EventOrderFail) ProtoMessage()    {}
func (*EventOrderFail) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{27}
}
func (m *EventOrderFail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderFail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderFail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderFail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderFail.Merge(m, src)
}
func (m *EventOrderFail) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderFail) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderFail.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderFail proto.InternalMessageInfo

func (m *EventOrderFail) GetAccount() []byte {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *EventOrderFail) GetHashes() [][]byte {
	if m != nil {
		return m.Hashes
	}
	return nil
}

func (m *EventOrderFail) GetFlags() []uint32 {
	if m != nil {
		return m.Flags
	}
	return nil
}

type EventAtomicMarketOrderFeeMultipliersUpdated struct {
	MarketFeeMultipliers []*MarketFeeMultiplier `protobuf:"bytes,1,rep,name=market_fee_multipliers,json=marketFeeMultipliers,proto3" json:"market_fee_multipliers,omitempty"`
}

func (m *EventAtomicMarketOrderFeeMultipliersUpdated) Reset() {
	*m = EventAtomicMarketOrderFeeMultipliersUpdated{}
}
func (m *EventAtomicMarketOrderFeeMultipliersUpdated) String() string {
	return proto.CompactTextString(m)
}
func (*EventAtomicMarketOrderFeeMultipliersUpdated) ProtoMessage() {}
func (*EventAtomicMarketOrderFeeMultipliersUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{28}
}
func (m *EventAtomicMarketOrderFeeMultipliersUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAtomicMarketOrderFeeMultipliersUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAtomicMarketOrderFeeMultipliersUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAtomicMarketOrderFeeMultipliersUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAtomicMarketOrderFeeMultipliersUpdated.Merge(m, src)
}
func (m *EventAtomicMarketOrderFeeMultipliersUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventAtomicMarketOrderFeeMultipliersUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAtomicMarketOrderFeeMultipliersUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventAtomicMarketOrderFeeMultipliersUpdated proto.InternalMessageInfo

func (m *EventAtomicMarketOrderFeeMultipliersUpdated) GetMarketFeeMultipliers() []*MarketFeeMultiplier {
	if m != nil {
		return m.MarketFeeMultipliers
	}
	return nil
}

type EventOrderbookUpdate struct {
	SpotUpdates       []*OrderbookUpdate `protobuf:"bytes,1,rep,name=spot_updates,json=spotUpdates,proto3" json:"spot_updates,omitempty"`
	DerivativeUpdates []*OrderbookUpdate `protobuf:"bytes,2,rep,name=derivative_updates,json=derivativeUpdates,proto3" json:"derivative_updates,omitempty"`
}

func (m *EventOrderbookUpdate) Reset()         { *m = EventOrderbookUpdate{} }
func (m *EventOrderbookUpdate) String() string { return proto.CompactTextString(m) }
func (*EventOrderbookUpdate) ProtoMessage()    {}
func (*EventOrderbookUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{29}
}
func (m *EventOrderbookUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOrderbookUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOrderbookUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOrderbookUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOrderbookUpdate.Merge(m, src)
}
func (m *EventOrderbookUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventOrderbookUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOrderbookUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventOrderbookUpdate proto.InternalMessageInfo

func (m *EventOrderbookUpdate) GetSpotUpdates() []*OrderbookUpdate {
	if m != nil {
		return m.SpotUpdates
	}
	return nil
}

func (m *EventOrderbookUpdate) GetDerivativeUpdates() []*OrderbookUpdate {
	if m != nil {
		return m.DerivativeUpdates
	}
	return nil
}

type OrderbookUpdate struct {
	Seq       uint64     `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Orderbook *Orderbook `protobuf:"bytes,2,opt,name=orderbook,proto3" json:"orderbook,omitempty"`
}

func (m *OrderbookUpdate) Reset()         { *m = OrderbookUpdate{} }
func (m *OrderbookUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderbookUpdate) ProtoMessage()    {}
func (*OrderbookUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{30}
}
func (m *OrderbookUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderbookUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderbookUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderbookUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderbookUpdate.Merge(m, src)
}
func (m *OrderbookUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderbookUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderbookUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderbookUpdate proto.InternalMessageInfo

func (m *OrderbookUpdate) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *OrderbookUpdate) GetOrderbook() *Orderbook {
	if m != nil {
		return m.Orderbook
	}
	return nil
}

type Orderbook struct {
	MarketId   []byte   `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	BuyLevels  []*Level `protobuf:"bytes,2,rep,name=buy_levels,json=buyLevels,proto3" json:"buy_levels,omitempty"`
	SellLevels []*Level `protobuf:"bytes,3,rep,name=sell_levels,json=sellLevels,proto3" json:"sell_levels,omitempty"`
}

func (m *Orderbook) Reset()         { *m = Orderbook{} }
func (m *Orderbook) String() string { return proto.CompactTextString(m) }
func (*Orderbook) ProtoMessage()    {}
func (*Orderbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_20dda602b6b13fd3, []int{31}
}
func (m *Orderbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Orderbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Orderbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Orderbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Orderbook.Merge(m, src)
}
func (m *Orderbook) XXX_Size() int {
	return m.Size()
}
func (m *Orderbook) XXX_DiscardUnknown() {
	xxx_messageInfo_Orderbook.DiscardUnknown(m)
}

var xxx_messageInfo_Orderbook proto.InternalMessageInfo

func (m *Orderbook) GetMarketId() []byte {
	if m != nil {
		return m.MarketId
	}
	return nil
}

func (m *Orderbook) GetBuyLevels() []*Level {
	if m != nil {
		return m.BuyLevels
	}
	return nil
}

func (m *Orderbook) GetSellLevels() []*Level {
	if m != nil {
		return m.SellLevels
	}
	return nil
}

func init() {
	proto.RegisterType((*EventBatchSpotExecution)(nil), "injective.exchange.v1beta1.EventBatchSpotExecution")
	proto.RegisterType((*EventBatchDerivativeExecution)(nil), "injective.exchange.v1beta1.EventBatchDerivativeExecution")
	proto.RegisterType((*EventLostFundsFromLiquidation)(nil), "injective.exchange.v1beta1.EventLostFundsFromLiquidation")
	proto.RegisterType((*EventBatchDerivativePosition)(nil), "injective.exchange.v1beta1.EventBatchDerivativePosition")
	proto.RegisterType((*EventDerivativeMarketPaused)(nil), "injective.exchange.v1beta1.EventDerivativeMarketPaused")
	proto.RegisterType((*EventMarketBeyondBankruptcy)(nil), "injective.exchange.v1beta1.EventMarketBeyondBankruptcy")
	proto.RegisterType((*EventAllPositionsHaircut)(nil), "injective.exchange.v1beta1.EventAllPositionsHaircut")
	proto.RegisterType((*EventBinaryOptionsMarketUpdate)(nil), "injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate")
	proto.RegisterType((*EventNewSpotOrders)(nil), "injective.exchange.v1beta1.EventNewSpotOrders")
	proto.RegisterType((*EventNewDerivativeOrders)(nil), "injective.exchange.v1beta1.EventNewDerivativeOrders")
	proto.RegisterType((*EventCancelSpotOrder)(nil), "injective.exchange.v1beta1.EventCancelSpotOrder")
	proto.RegisterType((*EventSpotMarketUpdate)(nil), "injective.exchange.v1beta1.EventSpotMarketUpdate")
	proto.RegisterType((*EventPerpetualMarketUpdate)(nil), "injective.exchange.v1beta1.EventPerpetualMarketUpdate")
	proto.RegisterType((*EventExpiryFuturesMarketUpdate)(nil), "injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate")
	proto.RegisterType((*EventPerpetualMarketFundingUpdate)(nil), "injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate")
	proto.RegisterType((*EventSubaccountDeposit)(nil), "injective.exchange.v1beta1.EventSubaccountDeposit")
	proto.RegisterType((*EventSubaccountWithdraw)(nil), "injective.exchange.v1beta1.EventSubaccountWithdraw")
	proto.RegisterType((*EventSubaccountBalanceTransfer)(nil), "injective.exchange.v1beta1.EventSubaccountBalanceTransfer")
	proto.RegisterType((*EventBatchDepositUpdate)(nil), "injective.exchange.v1beta1.EventBatchDepositUpdate")
	proto.RegisterType((*DerivativeMarketOrderCancel)(nil), "injective.exchange.v1beta1.DerivativeMarketOrderCancel")
	proto.RegisterType((*EventCancelDerivativeOrder)(nil), "injective.exchange.v1beta1.EventCancelDerivativeOrder")
	proto.RegisterType((*EventFeeDiscountSchedule)(nil), "injective.exchange.v1beta1.EventFeeDiscountSchedule")
	proto.RegisterType((*EventTradingRewardCampaignUpdate)(nil), "injective.exchange.v1beta1.EventTradingRewardCampaignUpdate")
	proto.RegisterType((*EventTradingRewardDistribution)(nil), "injective.exchange.v1beta1.EventTradingRewardDistribution")
	proto.RegisterType((*EventNewConditionalDerivativeOrder)(nil), "injective.exchange.v1beta1.EventNewConditionalDerivativeOrder")
	proto.RegisterType((*EventCancelConditionalDerivativeOrder)(nil), "injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder")
	proto.RegisterType((*EventConditionalDerivativeOrderTrigger)(nil), "injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger")
	proto.RegisterType((*EventOrderFail)(nil), "injective.exchange.v1beta1.EventOrderFail")
	proto.RegisterType((*EventAtomicMarketOrderFeeMultipliersUpdated)(nil), "injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated")
	proto.RegisterType((*EventOrderbookUpdate)(nil), "injective.exchange.v1beta1.EventOrderbookUpdate")
	proto.RegisterType((*OrderbookUpdate)(nil), "injective.exchange.v1beta1.OrderbookUpdate")
	proto.RegisterType((*Orderbook)(nil), "injective.exchange.v1beta1.Orderbook")
}

func init() {
	proto.RegisterFile("injective/exchange/v1beta1/events.proto", fileDescriptor_20dda602b6b13fd3)
}

var fileDescriptor_20dda602b6b13fd3 = []byte{
	// 1909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcb, 0x6f, 0x1c, 0xc7,
	0xf1, 0xe6, 0xf0, 0x65, 0xb2, 0x76, 0x49, 0x9a, 0x23, 0x4a, 0xa6, 0xa9, 0x9f, 0x29, 0x6a, 0x7e,
	0x96, 0x2c, 0xc9, 0xf6, 0xae, 0x45, 0x23, 0xf0, 0x25, 0x87, 0x70, 0x49, 0x11, 0x62, 0x4c, 0x49,
	0x54, 0x53, 0x81, 0x02, 0x01, 0xc6, 0xa0, 0x77, 0xa6, 0xb9, 0xdb, 0xd1, 0xcc, 0xf4, 0x68, 0xba,
	0x87, 0xd2, 0x22, 0xc7, 0x5c, 0x92, 0x53, 0x72, 0x08, 0x90, 0xdc, 0x72, 0xcc, 0x2d, 0x40, 0x0e,
	0x39, 0xe5, 0x96, 0x93, 0x83, 0x5c, 0x8c, 0x9c, 0xf2, 0x82, 0x11, 0x50, 0xf9, 0x0b, 0xf2, 0x17,
	0x04, 0xfd, 0x98, 0xc7, 0x3e, 0x34, 0xda, 0x15, 0x1d, 0xe4, 0xc4, 0x99, 0x9e, 0xea, 0xaf, 0xbe,
	0xfe, 0xba, 0xba, 0xba, 0x6a, 0x09, 0x1f, 0xd0, 0xe8, 0x07, 0xc4, 0x13, 0xf4, 0x94, 0x34, 0xc9,
	0x0b, 0xaf, 0x8b, 0xa3, 0x0e, 0x69, 0x9e, 0xde, 0x6e, 0x13, 0x81, 0x6f, 0x37, 0xc9, 0x29, 0x89,
	0x04, 0x6f, 0xc4, 0x09, 0x13, 0xcc, 0xde, 0xc8, 0x0d, 0x1b, 0x99, 0x61, 0xc3, 0x18, 0x6e, 0xac,
	0x75, 0x58, 0x87, 0x29, 0xb3, 0xa6, 0x7c, 0xd2, 0x33, 0x36, 0x36, 0x3d, 0xc6, 0x43, 0xc6, 0x9b,
	0x6d, 0xcc, 0x0b, 0x4c, 0x8f, 0xd1, 0xc8, 0x7c, 0xbf, 0x56, 0xb8, 0x66, 0x09, 0xf6, 0x82, 0xc2,
	0x48, 0xbf, 0x1a, 0xb3, 0x9b, 0x55, 0x0c, 0x33, 0x26, 0xca, 0xd4, 0xf9, 0x87, 0x05, 0xef, 0xdc,
	0x91, 0xa4, 0x5b, 0x58, 0x78, 0xdd, 0xe3, 0x98, 0x89, 0x3b, 0x2f, 0x88, 0x97, 0x0a, 0xca, 0x22,
	0xfb, 0x32, 0x2c, 0x86, 0x38, 0x79, 0x4a, 0x84, 0x4b, 0xfd, 0x75, 0x6b, 0xcb, 0xba, 0xb1, 0x88,
	0x16, 0xf4, 0xc0, 0x81, 0x6f, 0x5f, 0x84, 0x79, 0xca, 0xdd, 0x76, 0xda, 0x5b, 0x9f, 0xde, 0xb2,
	0x6e, 0x2c, 0xa0, 0x39, 0xca, 0x5b, 0x69, 0xcf, 0x7e, 0x00, 0x4b, 0x24, 0x03, 0x78, 0xd4, 0x8b,
	0xc9, 0xfa, 0xcc, 0x96, 0x75, 0x63, 0x79, 0xfb, 0x66, 0xe3, 0xd5, 0x5a, 0x34, 0xee, 0x94, 0x27,
	0xa0, 0xfe, 0xf9, 0xf6, 0xb7, 0x61, 0x5e, 0x24, 0xd8, 0x27, 0x7c, 0x7d, 0x76, 0x6b, 0xe6, 0x46,
	0x6d, 0xfb, 0xfd, 0x2a, 0xa4, 0x47, 0xd2, 0xf2, 0x90, 0x75, 0x90, 0x99, 0xe3, 0xfc, 0x7b, 0x1a,
	0xde, 0x2b, 0x96, 0xb7, 0x47, 0x12, 0x7a, 0x8a, 0xe5, 0xd4, 0xf3, 0x2d, 0xf2, 0x1a, 0x2c, 0x53,
	0xee, 0x06, 0xf4, 0x59, 0x4a, 0x7d, 0x2c, 0x51, 0xd4, 0x2a, 0x17, 0xd0, 0x12, 0xe5, 0x87, 0xc5,
	0xa0, 0xfd, 0x05, 0xd8, 0x5e, 0x1a, 0xa6, 0x81, 0xf2, 0xe8, 0x9e, 0xa4, 0x91, 0x4f, 0xa3, 0xce,
	0xfa, 0xac, 0xf4, 0xd1, 0x6a, 0x7c, 0xf9, 0xf5, 0x15, 0xeb, 0x6f, 0x5f, 0x5f, 0xb9, 0xde, 0xa1,
	0xa2, 0x9b, 0xb6, 0x1b, 0x1e, 0x0b, 0x9b, 0x66, 0xf3, 0xf5, 0x9f, 0x8f, 0xb9, 0xff, 0xb4, 0x29,
	0x7a, 0x31, 0xe1, 0x8d, 0x3d, 0xe2, 0xa1, 0xd5, 0x02, 0x69, 0x5f, 0x03, 0x0d, 0x4b, 0x3d, 0x77,
	0x4e, 0xa9, 0xf7, 0x73, 0xa9, 0xe7, 0x95, 0xd4, 0x8d, 0x2a, 0xa4, 0x42, 0xcb, 0x21, 0xd1, 0xff,
	0x9a, 0x89, 0x7e, 0xc8, 0xb8, 0x90, 0x6c, 0xf9, 0x7e, 0xc2, 0xc2, 0xb2, 0x32, 0x95, 0xa2, 0xff,
	0x3f, 0x2c, 0xf1, 0xb4, 0x8d, 0x3d, 0x8f, 0xa5, 0x91, 0x32, 0x90, 0xda, 0xd7, 0x51, 0xbd, 0x18,
	0x3c, 0xf0, 0xed, 0x1f, 0x59, 0xf0, 0x41, 0xc0, 0xb8, 0x50, 0xb2, 0x72, 0xf7, 0x24, 0x61, 0xa1,
	0x8b, 0x4f, 0x31, 0x0d, 0x70, 0x3b, 0x20, 0xae, 0x9f, 0x26, 0x34, 0xea, 0xb8, 0x31, 0xee, 0xb1,
	0x54, 0xa8, 0xcd, 0xd1, 0x8a, 0x4f, 0x4d, 0xa0, 0xb8, 0x13, 0x94, 0xd9, 0xef, 0x64, 0xd8, 0x7b,
	0x0a, 0xfa, 0x48, 0x21, 0xdb, 0x31, 0xbc, 0x37, 0x48, 0x82, 0x25, 0x3e, 0x49, 0x5c, 0x0f, 0x47,
	0x1e, 0x09, 0x78, 0x69, 0xb3, 0x27, 0x71, 0xfd, 0x6e, 0x9f, 0xeb, 0x07, 0x12, 0x71, 0x57, 0x03,
	0x3a, 0x3f, 0xb1, 0xe0, 0xff, 0x46, 0x05, 0xf4, 0x11, 0xe3, 0xf4, 0xf5, 0xd2, 0x1e, 0xc2, 0x62,
	0x6c, 0x0c, 0xf9, 0xfa, 0xf4, 0xeb, 0x37, 0xf9, 0x38, 0x97, 0x3c, 0xc3, 0x47, 0x05, 0x80, 0xf3,
	0x7b, 0x0b, 0x2e, 0x2b, 0x2e, 0x05, 0x8d, 0x7b, 0xca, 0xd3, 0x11, 0x4e, 0x39, 0xf1, 0xab, 0xa9,
	0x5c, 0x85, 0x3a, 0x27, 0x42, 0x04, 0xc4, 0x8d, 0x13, 0xea, 0x11, 0xb5, 0xc9, 0x8b, 0xa8, 0xa6,
	0xc7, 0x8e, 0xe4, 0x90, 0xdd, 0x80, 0x0b, 0x82, 0x09, 0x1c, 0xb8, 0x21, 0xe5, 0x5c, 0xee, 0xa7,
	0x92, 0x59, 0x6f, 0x27, 0x5a, 0x55, 0x9f, 0xee, 0xe9, 0x2f, 0x4a, 0x2b, 0xfb, 0x23, 0xb0, 0xfb,
	0x2c, 0xdd, 0x04, 0x0b, 0xa2, 0xb7, 0x00, 0xbd, 0x1d, 0x96, 0x2c, 0x11, 0x16, 0xc4, 0xf9, 0x69,
	0xc6, 0x5e, 0x73, 0x6e, 0x91, 0x1e, 0x8b, 0xfc, 0x16, 0x8e, 0x9e, 0x26, 0x69, 0x2c, 0xbc, 0xde,
	0xb9, 0xd9, 0x7f, 0x02, 0x6b, 0x19, 0x1b, 0x83, 0x53, 0xa6, 0x9f, 0x31, 0xd5, 0xce, 0x15, 0x2b,
	0xe7, 0xc7, 0x16, 0xac, 0x2b, 0x46, 0x3b, 0x41, 0x90, 0xe9, 0xcd, 0xef, 0x62, 0x9a, 0x78, 0xa9,
	0x38, 0x37, 0x9d, 0xd1, 0xe2, 0xcc, 0xbc, 0x42, 0x1c, 0x06, 0x9b, 0x3a, 0xca, 0x68, 0x84, 0x93,
	0xde, 0x83, 0x58, 0x51, 0xd1, 0x5c, 0xbf, 0x17, 0xfb, 0x58, 0x10, 0xfb, 0x1e, 0xcc, 0x6b, 0xf7,
	0x8a, 0x4c, 0x6d, 0xbb, 0x59, 0x15, 0x47, 0x23, 0x60, 0x5a, 0xb3, 0xf2, 0x50, 0x20, 0x03, 0xe2,
	0xfc, 0xd1, 0x02, 0x5b, 0x79, 0xbc, 0x4f, 0x9e, 0xcb, 0x5b, 0x48, 0x05, 0x3d, 0xaf, 0x5e, 0xf5,
	0x01, 0x40, 0x3b, 0xed, 0xe9, 0x13, 0x97, 0x85, 0xf3, 0xad, 0xca, 0x70, 0x8e, 0x99, 0x38, 0xa4,
	0x21, 0xd5, 0xe8, 0x68, 0xb1, 0x9d, 0xf6, 0x8c, 0x9f, 0xcf, 0xa1, 0xc6, 0x49, 0x10, 0x64, 0x58,
	0x33, 0x13, 0x63, 0x81, 0x9c, 0xae, 0xc1, 0x9c, 0xbf, 0x67, 0xfb, 0x78, 0x9f, 0x3c, 0x2f, 0x8e,
	0xc6, 0x38, 0x2b, 0x7a, 0x30, 0x62, 0x45, 0x9f, 0x8c, 0x97, 0x85, 0x47, 0xaf, 0xeb, 0xe1, 0xa8,
	0x75, 0x4d, 0x8e, 0x58, 0x5e, 0xdd, 0x0f, 0x61, 0x4d, 0x2d, 0x4e, 0x67, 0xa4, 0x7c, 0xaf, 0xaa,
	0x17, 0xb6, 0x0f, 0x73, 0x8a, 0x82, 0x8a, 0xcc, 0x89, 0x94, 0x35, 0x71, 0xa2, 0xa7, 0x3b, 0x5f,
	0xc0, 0x45, 0xe5, 0x5c, 0xda, 0xf4, 0x85, 0xe3, 0xde, 0x40, 0x38, 0x5e, 0x7f, 0x9d, 0x87, 0x91,
	0x51, 0xf8, 0xeb, 0x69, 0xd8, 0x50, 0xf8, 0x47, 0x24, 0x89, 0x89, 0x48, 0x71, 0xd0, 0xe7, 0xe4,
	0xbb, 0x03, 0x4e, 0x3e, 0x1a, 0x4f, 0xc8, 0x51, 0xae, 0x6c, 0x0a, 0x17, 0xe3, 0xcc, 0x49, 0x96,
	0x20, 0x68, 0x74, 0xc2, 0x8c, 0x42, 0x95, 0xc7, 0x69, 0x80, 0xdd, 0x41, 0x74, 0xc2, 0x14, 0xba,
	0x85, 0x2e, 0xc4, 0xc3, 0x9f, 0x6c, 0x04, 0x6f, 0x65, 0xc5, 0xc7, 0x8c, 0x02, 0xdf, 0x9e, 0x00,
	0xdc, 0x54, 0x1b, 0x06, 0x3f, 0x03, 0x72, 0xfe, 0x65, 0x99, 0x0c, 0x71, 0xe7, 0x45, 0x4c, 0x93,
	0xde, 0x7e, 0x2a, 0xd2, 0x84, 0xf0, 0xff, 0x9a, 0x5a, 0xa7, 0xb0, 0x41, 0x94, 0x23, 0xf7, 0x44,
	0x7b, 0xea, 0x93, 0x4c, 0xaf, 0xea, 0xd3, 0xea, 0xc2, 0x67, 0x88, 0x66, 0x49, 0xb6, 0x77, 0xc8,
	0xe8, 0xcf, 0xce, 0xd9, 0x34, 0x5c, 0x1d, 0x15, 0x10, 0x46, 0x15, 0xb3, 0xd2, 0xca, 0xd0, 0x2f,
	0xa9, 0x3f, 0x7d, 0x2e, 0xf5, 0xa7, 0x72, 0xf5, 0xed, 0x5b, 0xb0, 0x4a, 0xb9, 0xdb, 0x65, 0x69,
	0x12, 0xf4, 0xdc, 0xf2, 0xde, 0x2e, 0xa0, 0x15, 0xca, 0xef, 0xaa, 0xf1, 0xac, 0x4c, 0x7c, 0x08,
	0x75, 0x63, 0x51, 0xba, 0x0f, 0x27, 0xae, 0x3f, 0x6b, 0x06, 0x03, 0xe9, 0xdc, 0x0f, 0x72, 0x79,
	0xe6, 0xb2, 0x99, 0x7b, 0x23, 0x40, 0xa5, 0x98, 0xba, 0x9a, 0x9c, 0x5f, 0x58, 0x70, 0x49, 0x9f,
	0xea, 0xbc, 0xdc, 0xd8, 0x23, 0xaa, 0xcc, 0xb0, 0xaf, 0x40, 0x8d, 0x27, 0x9e, 0x8b, 0x7d, 0x3f,
	0x21, 0x9c, 0x1b, 0x6d, 0x81, 0x27, 0xde, 0x8e, 0x1e, 0x19, 0xaf, 0x58, 0xfc, 0x0c, 0xe6, 0x71,
	0x28, 0x9f, 0x4d, 0xa4, 0xbc, 0xdb, 0xd0, 0x94, 0x1a, 0xb2, 0xcf, 0xca, 0xa5, 0xdf, 0x65, 0x34,
	0xca, 0xc2, 0x4e, 0x9b, 0x3b, 0xbf, 0xcc, 0xba, 0xa3, 0x82, 0xd9, 0x63, 0x2a, 0xba, 0x7e, 0x82,
	0x9f, 0x0f, 0x7b, 0xb6, 0x46, 0x78, 0xbe, 0x02, 0x35, 0x9f, 0x8b, 0x9c, 0xbf, 0xbe, 0x97, 0xc1,
	0xe7, 0x22, 0xe3, 0xff, 0xc6, 0xd4, 0x7e, 0x9b, 0x1d, 0xc0, 0x82, 0x5a, 0x0b, 0x07, 0x32, 0x27,
	0x3f, 0x4a, 0x70, 0xc4, 0x4f, 0x48, 0x22, 0xa3, 0x44, 0x8a, 0x37, 0xcc, 0x72, 0x11, 0xad, 0xf0,
	0xc4, 0x3b, 0x2e, 0x13, 0xbd, 0x05, 0xab, 0x92, 0xe8, 0xb0, 0x96, 0x8b, 0x68, 0xc5, 0xe7, 0xe2,
	0xf8, 0x1b, 0x91, 0x33, 0x2c, 0xf7, 0x9a, 0x66, 0x8b, 0xcd, 0x11, 0x42, 0xb0, 0xe2, 0xeb, 0x01,
	0x37, 0x55, 0x23, 0x72, 0xb3, 0xe5, 0x65, 0x75, 0xb3, 0x3a, 0x6b, 0x94, 0x30, 0xd0, 0xb2, 0x5f,
	0x7e, 0xe5, 0xce, 0x9f, 0x2d, 0xb8, 0x3c, 0x98, 0x57, 0x4a, 0xc5, 0xb4, 0xfd, 0x04, 0xea, 0xe6,
	0xd8, 0xea, 0xbb, 0x49, 0xa7, 0xa9, 0xdb, 0x93, 0xa4, 0xa9, 0xe2, 0x8a, 0xb2, 0x50, 0x2d, 0x2c,
	0x86, 0xec, 0xc7, 0xb0, 0xa2, 0x7b, 0x00, 0xf7, 0x59, 0x8a, 0x23, 0x41, 0x85, 0x6e, 0x21, 0x27,
	0xef, 0x05, 0x96, 0x35, 0xcc, 0x43, 0x83, 0x52, 0x5c, 0x51, 0x7a, 0x11, 0x03, 0xf5, 0x45, 0x75,
	0x2a, 0x7a, 0x1f, 0x54, 0x87, 0x1a, 0x52, 0x33, 0xd9, 0x74, 0xb5, 0xfd, 0x83, 0xf6, 0x63, 0xa8,
	0x05, 0xf2, 0xd5, 0xa8, 0xa2, 0xf7, 0x78, 0xe2, 0x9a, 0xc1, 0x88, 0x02, 0x41, 0x3e, 0x62, 0x87,
	0x70, 0xa1, 0xac, 0xb7, 0x69, 0x92, 0x54, 0x42, 0xaa, 0x6d, 0x7f, 0x36, 0xb1, 0xec, 0x9a, 0xae,
	0xf1, 0xb3, 0x1a, 0x0e, 0x7e, 0x70, 0x3a, 0xa6, 0x0a, 0xdb, 0x27, 0x64, 0x8f, 0x72, 0x15, 0xbc,
	0xc7, 0x5e, 0x97, 0xf8, 0x69, 0x40, 0xec, 0xcf, 0x61, 0x81, 0x9b, 0xe7, 0x71, 0xea, 0xd7, 0x11,
	0x10, 0x28, 0x07, 0x70, 0xce, 0x2c, 0xd8, 0x52, 0x9e, 0x64, 0x27, 0x2c, 0x73, 0x24, 0x79, 0x8e,
	0x13, 0x7f, 0x17, 0x87, 0x31, 0xa6, 0x9d, 0xc8, 0x04, 0xf8, 0x13, 0x58, 0xf2, 0xcc, 0x88, 0xbe,
	0xb4, 0xb4, 0xdb, 0x6f, 0xbd, 0xee, 0xe7, 0x8c, 0x21, 0x3c, 0x79, 0x2f, 0xa1, 0xba, 0x57, 0x7a,
	0xb3, 0xdb, 0x70, 0x31, 0xc7, 0x4e, 0x94, 0xb1, 0x1b, 0x33, 0x16, 0x8c, 0xd5, 0xe2, 0x65, 0xb0,
	0xda, 0xc9, 0x11, 0x63, 0x01, 0xba, 0xe0, 0x0d, 0x8d, 0x71, 0x27, 0x35, 0xe9, 0xa6, 0x8f, 0xd3,
	0x1e, 0xe5, 0x22, 0xa1, 0x6d, 0xfd, 0x4b, 0xca, 0x31, 0xac, 0x64, 0xb9, 0x43, 0x93, 0xc8, 0x8e,
	0x70, 0x65, 0xb5, 0xb7, 0xa3, 0xa7, 0x68, 0x3c, 0x8e, 0x96, 0x71, 0xdf, 0xbb, 0xf3, 0x3b, 0x0b,
	0x9c, 0xac, 0x96, 0xde, 0x65, 0x91, 0xaf, 0x9a, 0x22, 0x3c, 0x59, 0xd8, 0xef, 0xf4, 0x17, 0x9f,
	0x1f, 0x8e, 0x17, 0x69, 0xba, 0xf2, 0xd5, 0x33, 0x6d, 0x1b, 0x66, 0xbb, 0x98, 0x77, 0xd5, 0x61,
	0xa8, 0x23, 0xf5, 0x2c, 0x7d, 0xd2, 0xac, 0x0e, 0x51, 0x41, 0xbc, 0x80, 0x16, 0xa8, 0x29, 0x1e,
	0x9c, 0x5f, 0x4d, 0xc3, 0xb5, 0xd2, 0x31, 0x7d, 0x53, 0xea, 0xff, 0xe3, 0x13, 0x3b, 0x98, 0x21,
	0x67, 0xbf, 0xb9, 0x0c, 0xe9, 0xfc, 0xc9, 0x82, 0xeb, 0x5a, 0xa1, 0x57, 0x6a, 0xf3, 0x28, 0xa1,
	0x9d, 0xce, 0x28, 0x89, 0xea, 0x25, 0x89, 0xae, 0xc3, 0xb2, 0x51, 0xc3, 0x98, 0x1b, 0x8d, 0x06,
	0x46, 0x65, 0x3f, 0x2e, 0xf4, 0x23, 0xf1, 0x4d, 0x02, 0x2a, 0x6d, 0xa9, 0x9d, 0x7f, 0x53, 0x9e,
	0xef, 0xca, 0x0d, 0xbe, 0x05, 0xab, 0x71, 0x80, 0xbd, 0x7e, 0xf3, 0x59, 0x65, 0xbe, 0xa2, 0x3f,
	0xe4, 0xb6, 0xce, 0xf7, 0x61, 0x59, 0x2d, 0x46, 0x8d, 0xec, 0x63, 0x1a, 0xd8, 0xeb, 0xf0, 0x96,
	0x89, 0x65, 0x43, 0x39, 0x7b, 0xb5, 0x2f, 0xc1, 0xbc, 0x84, 0x22, 0xfa, 0x7c, 0xd6, 0x91, 0x79,
	0xb3, 0xd7, 0x60, 0xee, 0x24, 0xc0, 0x1d, 0xdd, 0xa6, 0x2d, 0x21, 0xfd, 0xe2, 0xfc, 0xdc, 0x82,
	0x0f, 0xf5, 0xaf, 0x02, 0x82, 0x85, 0xd4, 0x2b, 0xa9, 0xba, 0x4f, 0xc8, 0xbd, 0x34, 0x10, 0x34,
	0x0e, 0x28, 0x49, 0xb8, 0xce, 0x33, 0xbe, 0x4d, 0xe0, 0x52, 0xf6, 0x7b, 0x03, 0x21, 0x6e, 0x58,
	0x18, 0x98, 0xd3, 0x58, 0x99, 0xe8, 0x4c, 0xd5, 0x59, 0x06, 0x46, 0x6b, 0xe1, 0xf0, 0x20, 0x77,
	0xfe, 0x60, 0x99, 0x3e, 0x50, 0x51, 0x69, 0x33, 0xf6, 0xd4, 0x24, 0xba, 0xfb, 0x50, 0xe7, 0x31,
	0x1b, 0xbc, 0xc6, 0x2b, 0x0f, 0xdd, 0x00, 0x04, 0xaa, 0x49, 0x00, 0x73, 0x8b, 0xdb, 0x4f, 0xc0,
	0xf6, 0xf3, 0xb0, 0xc8, 0x51, 0xa7, 0x27, 0x47, 0x5d, 0x2d, 0x60, 0xb2, 0x0a, 0xa1, 0x0b, 0x2b,
	0x83, 0xf4, 0xdf, 0x86, 0x19, 0x4e, 0x9e, 0xa9, 0x2d, 0x9b, 0x45, 0xf2, 0xd1, 0xde, 0x85, 0x45,
	0x96, 0x19, 0x99, 0x14, 0x72, 0x6d, 0x2c, 0xbf, 0xa8, 0x98, 0xe7, 0xfc, 0xc6, 0x82, 0xc5, 0xfc,
	0x43, 0x75, 0x40, 0x7f, 0x47, 0xff, 0x08, 0x10, 0x90, 0x53, 0x92, 0xa7, 0xf0, 0xab, 0x55, 0x0e,
	0x0f, 0xa5, 0xa5, 0xea, 0xfa, 0xd5, 0x13, 0xb7, 0x5b, 0xa6, 0xeb, 0x37, 0x10, 0x33, 0xe3, 0x42,
	0xa8, 0x36, 0x5f, 0x63, 0xb4, 0xba, 0x5f, 0x9e, 0x6d, 0x5a, 0x5f, 0x9d, 0x6d, 0x5a, 0xff, 0x3c,
	0xdb, 0xb4, 0x7e, 0xf6, 0x72, 0x73, 0xea, 0xab, 0x97, 0x9b, 0x53, 0x7f, 0x79, 0xb9, 0x39, 0xf5,
	0xe4, 0x7e, 0xa9, 0x72, 0x39, 0xc8, 0x20, 0x0f, 0x71, 0x9b, 0x37, 0x73, 0x07, 0x1f, 0x7b, 0x2c,
	0x21, 0xe5, 0xd7, 0x2e, 0xa6, 0x51, 0x33, 0x64, 0xf2, 0xba, 0xe4, 0xc5, 0xff, 0x24, 0x54, 0x95,
	0xd3, 0x9e, 0x57, 0xff, 0x89, 0xf8, 0xf4, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe2, 0xc0, 0xc6,
	0x87, 0x58, 0x19, 0x00, 0x00,
}

func (m *EventBatchSpotExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBatchSpotExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBatchSpotExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for iNdEx := len(m.Trades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ExecutionType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExecutionType))
		i--
		dAtA[i] = 0x18
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBatchDerivativeExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBatchDerivativeExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBatchDerivativeExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for iNdEx := len(m.Trades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Trades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ExecutionType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExecutionType))
		i--
		dAtA[i] = 0x28
	}
	if m.CumulativeFunding != nil {
		{
			size := m.CumulativeFunding.Size()
			i -= size
			if _, err := m.CumulativeFunding.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsLiquidation {
		i--
		if m.IsLiquidation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventLostFundsFromLiquidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLostFundsFromLiquidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLostFundsFromLiquidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LostFundsFromOrderCancels.Size()
		i -= size
		if _, err := m.LostFundsFromOrderCancels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.LostFundsFromAvailableDuringPayout.Size()
		i -= size
		if _, err := m.LostFundsFromAvailableDuringPayout.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBatchDerivativePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBatchDerivativePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBatchDerivativePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDerivativeMarketPaused) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDerivativeMarketPaused) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDerivativeMarketPaused) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingFundsRate) > 0 {
		i -= len(m.MissingFundsRate)
		copy(dAtA[i:], m.MissingFundsRate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MissingFundsRate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TotalMissingFunds) > 0 {
		i -= len(m.TotalMissingFunds)
		copy(dAtA[i:], m.TotalMissingFunds)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TotalMissingFunds)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SettlePrice) > 0 {
		i -= len(m.SettlePrice)
		copy(dAtA[i:], m.SettlePrice)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SettlePrice)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMarketBeyondBankruptcy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMarketBeyondBankruptcy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMarketBeyondBankruptcy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingMarketFunds) > 0 {
		i -= len(m.MissingMarketFunds)
		copy(dAtA[i:], m.MissingMarketFunds)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MissingMarketFunds)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SettlePrice) > 0 {
		i -= len(m.SettlePrice)
		copy(dAtA[i:], m.SettlePrice)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SettlePrice)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAllPositionsHaircut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAllPositionsHaircut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAllPositionsHaircut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingFundsRate) > 0 {
		i -= len(m.MissingFundsRate)
		copy(dAtA[i:], m.MissingFundsRate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MissingFundsRate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SettlePrice) > 0 {
		i -= len(m.SettlePrice)
		copy(dAtA[i:], m.SettlePrice)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SettlePrice)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBinaryOptionsMarketUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBinaryOptionsMarketUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBinaryOptionsMarketUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventNewSpotOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNewSpotOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNewSpotOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SellOrders) > 0 {
		for iNdEx := len(m.SellOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SellOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BuyOrders) > 0 {
		for iNdEx := len(m.BuyOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuyOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventNewDerivativeOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNewDerivativeOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNewDerivativeOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SellOrders) > 0 {
		for iNdEx := len(m.SellOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SellOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BuyOrders) > 0 {
		for iNdEx := len(m.BuyOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuyOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSpotMarketUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSpotMarketUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSpotMarketUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPerpetualMarketUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPerpetualMarketUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPerpetualMarketUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Funding != nil {
		{
			size, err := m.Funding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PerpetualMarketInfo != nil {
		{
			size, err := m.PerpetualMarketInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventExpiryFuturesMarketUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventExpiryFuturesMarketUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventExpiryFuturesMarketUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryFuturesMarketInfo != nil {
		{
			size, err := m.ExpiryFuturesMarketInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPerpetualMarketFundingUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPerpetualMarketFundingUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPerpetualMarketFundingUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarkPrice != nil {
		{
			size := m.MarkPrice.Size()
			i -= size
			if _, err := m.MarkPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FundingRate != nil {
		{
			size := m.FundingRate.Size()
			i -= size
			if _, err := m.FundingRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsHourlyFunding {
		i--
		if m.IsHourlyFunding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Funding.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSubaccountDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSubaccountDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSubaccountDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SrcAddress) > 0 {
		i -= len(m.SrcAddress)
		copy(dAtA[i:], m.SrcAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SrcAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSubaccountWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSubaccountWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSubaccountWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.DstAddress) > 0 {
		i -= len(m.DstAddress)
		copy(dAtA[i:], m.DstAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DstAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSubaccountBalanceTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSubaccountBalanceTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSubaccountBalanceTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.DstSubaccountId) > 0 {
		i -= len(m.DstSubaccountId)
		copy(dAtA[i:], m.DstSubaccountId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DstSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SrcSubaccountId) > 0 {
		i -= len(m.SrcSubaccountId)
		copy(dAtA[i:], m.SrcSubaccountId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SrcSubaccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBatchDepositUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBatchDepositUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBatchDepositUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DepositUpdates) > 0 {
		for iNdEx := len(m.DepositUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DepositUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeMarketOrderCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarketOrderCancel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarketOrderCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CancelQuantity.Size()
		i -= size
		if _, err := m.CancelQuantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MarketOrder != nil {
		{
			size, err := m.MarketOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketOrderCancel != nil {
		{
			size, err := m.MarketOrderCancel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LimitOrder != nil {
		{
			size, err := m.LimitOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsLimitCancel {
		i--
		if m.IsLimitCancel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFeeDiscountSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFeeDiscountSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFeeDiscountSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTradingRewardCampaignUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradingRewardCampaignUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradingRewardCampaignUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CampaignRewardPools) > 0 {
		for iNdEx := len(m.CampaignRewardPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CampaignRewardPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CampaignInfo != nil {
		{
			size, err := m.CampaignInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTradingRewardDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradingRewardDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradingRewardDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountRewards) > 0 {
		for iNdEx := len(m.AccountRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccountRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventNewConditionalDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNewConditionalDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNewConditionalDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMarket {
		i--
		if m.IsMarket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelConditionalDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelConditionalDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelConditionalDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketOrder != nil {
		{
			size, err := m.MarketOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LimitOrder != nil {
		{
			size, err := m.LimitOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsLimitCancel {
		i--
		if m.IsLimitCancel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventConditionalDerivativeOrderTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventConditionalDerivativeOrderTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventConditionalDerivativeOrderTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PlacedOrderHash) > 0 {
		i -= len(m.PlacedOrderHash)
		copy(dAtA[i:], m.PlacedOrderHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PlacedOrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TriggeredOrderHash) > 0 {
		i -= len(m.TriggeredOrderHash)
		copy(dAtA[i:], m.TriggeredOrderHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TriggeredOrderHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsLimitTrigger {
		i--
		if m.IsLimitTrigger {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderFail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderFail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderFail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Flags) > 0 {
		dAtA22 := make([]byte, len(m.Flags)*10)
		var j21 int
		for _, num := range m.Flags {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintEvents(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hashes) > 0 {
		for iNdEx := len(m.Hashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hashes[iNdEx])
			copy(dAtA[i:], m.Hashes[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.Hashes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAtomicMarketOrderFeeMultipliersUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAtomicMarketOrderFeeMultipliersUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAtomicMarketOrderFeeMultipliersUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketFeeMultipliers) > 0 {
		for iNdEx := len(m.MarketFeeMultipliers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MarketFeeMultipliers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventOrderbookUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOrderbookUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOrderbookUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DerivativeUpdates) > 0 {
		for iNdEx := len(m.DerivativeUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SpotUpdates) > 0 {
		for iNdEx := len(m.SpotUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderbookUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderbookUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderbookUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Orderbook != nil {
		{
			size, err := m.Orderbook.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Orderbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Orderbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Orderbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SellLevels) > 0 {
		for iNdEx := len(m.SellLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SellLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BuyLevels) > 0 {
		for iNdEx := len(m.BuyLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuyLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventBatchSpotExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.IsBuy {
		n += 2
	}
	if m.ExecutionType != 0 {
		n += 1 + sovEvents(uint64(m.ExecutionType))
	}
	if len(m.Trades) > 0 {
		for _, e := range m.Trades {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventBatchDerivativeExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.IsBuy {
		n += 2
	}
	if m.IsLiquidation {
		n += 2
	}
	if m.CumulativeFunding != nil {
		l = m.CumulativeFunding.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ExecutionType != 0 {
		n += 1 + sovEvents(uint64(m.ExecutionType))
	}
	if len(m.Trades) > 0 {
		for _, e := range m.Trades {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventLostFundsFromLiquidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.LostFundsFromAvailableDuringPayout.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.LostFundsFromOrderCancels.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventBatchDerivativePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventDerivativeMarketPaused) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SettlePrice)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TotalMissingFunds)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MissingFundsRate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMarketBeyondBankruptcy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SettlePrice)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MissingMarketFunds)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventAllPositionsHaircut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SettlePrice)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MissingFundsRate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventBinaryOptionsMarketUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Market.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventNewSpotOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.BuyOrders) > 0 {
		for _, e := range m.BuyOrders {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.SellOrders) > 0 {
		for _, e := range m.SellOrders {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventNewDerivativeOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.BuyOrders) > 0 {
		for _, e := range m.BuyOrders {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.SellOrders) > 0 {
		for _, e := range m.SellOrders {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventCancelSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventSpotMarketUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Market.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventPerpetualMarketUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Market.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.PerpetualMarketInfo != nil {
		l = m.PerpetualMarketInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Funding != nil {
		l = m.Funding.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventExpiryFuturesMarketUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Market.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.ExpiryFuturesMarketInfo != nil {
		l = m.ExpiryFuturesMarketInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPerpetualMarketFundingUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Funding.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.IsHourlyFunding {
		n += 2
	}
	if m.FundingRate != nil {
		l = m.FundingRate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarkPrice != nil {
		l = m.MarkPrice.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSubaccountDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventSubaccountWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DstAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventSubaccountBalanceTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcSubaccountId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DstSubaccountId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventBatchDepositUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DepositUpdates) > 0 {
		for _, e := range m.DepositUpdates {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *DerivativeMarketOrderCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketOrder != nil {
		l = m.MarketOrder.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.CancelQuantity.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventCancelDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.IsLimitCancel {
		n += 2
	}
	if m.LimitOrder != nil {
		l = m.LimitOrder.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketOrderCancel != nil {
		l = m.MarketOrderCancel.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventFeeDiscountSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventTradingRewardCampaignUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CampaignInfo != nil {
		l = m.CampaignInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.CampaignRewardPools) > 0 {
		for _, e := range m.CampaignRewardPools {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventTradingRewardDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AccountRewards) > 0 {
		for _, e := range m.AccountRewards {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventNewConditionalDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.IsMarket {
		n += 2
	}
	return n
}

func (m *EventCancelConditionalDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.IsLimitCancel {
		n += 2
	}
	if m.LimitOrder != nil {
		l = m.LimitOrder.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MarketOrder != nil {
		l = m.MarketOrder.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventConditionalDerivativeOrderTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.IsLimitTrigger {
		n += 2
	}
	l = len(m.TriggeredOrderHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.PlacedOrderHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventOrderFail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Hashes) > 0 {
		for _, b := range m.Hashes {
			l = len(b)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.Flags) > 0 {
		l = 0
		for _, e := range m.Flags {
			l += sovEvents(uint64(e))
		}
		n += 1 + sovEvents(uint64(l)) + l
	}
	return n
}

func (m *EventAtomicMarketOrderFeeMultipliersUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MarketFeeMultipliers) > 0 {
		for _, e := range m.MarketFeeMultipliers {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventOrderbookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpotUpdates) > 0 {
		for _, e := range m.SpotUpdates {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.DerivativeUpdates) > 0 {
		for _, e := range m.DerivativeUpdates {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *OrderbookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovEvents(uint64(m.Seq))
	}
	if m.Orderbook != nil {
		l = m.Orderbook.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *Orderbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.BuyLevels) > 0 {
		for _, e := range m.BuyLevels {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.SellLevels) > 0 {
		for _, e := range m.SellLevels {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventBatchSpotExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBatchSpotExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBatchSpotExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionType", wireType)
			}
			m.ExecutionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionType |= ExecutionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trades = append(m.Trades, &TradeLog{})
			if err := m.Trades[len(m.Trades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBatchDerivativeExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBatchDerivativeExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBatchDerivativeExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLiquidation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLiquidation = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeFunding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.CumulativeFunding = &v
			if err := m.CumulativeFunding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionType", wireType)
			}
			m.ExecutionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionType |= ExecutionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trades = append(m.Trades, &DerivativeTradeLog{})
			if err := m.Trades[len(m.Trades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLostFundsFromLiquidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLostFundsFromLiquidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLostFundsFromLiquidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = append(m.SubaccountId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubaccountId == nil {
				m.SubaccountId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostFundsFromAvailableDuringPayout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LostFundsFromAvailableDuringPayout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostFundsFromOrderCancels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LostFundsFromOrderCancels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBatchDerivativePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBatchDerivativePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBatchDerivativePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &SubaccountPosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDerivativeMarketPaused) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDerivativeMarketPaused: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDerivativeMarketPaused: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlePrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMissingFunds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalMissingFunds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingFundsRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingFundsRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMarketBeyondBankruptcy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMarketBeyondBankruptcy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMarketBeyondBankruptcy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlePrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingMarketFunds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingMarketFunds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAllPositionsHaircut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAllPositionsHaircut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAllPositionsHaircut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlePrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingFundsRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingFundsRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBinaryOptionsMarketUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBinaryOptionsMarketUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBinaryOptionsMarketUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNewSpotOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNewSpotOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNewSpotOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyOrders = append(m.BuyOrders, &SpotLimitOrder{})
			if err := m.BuyOrders[len(m.BuyOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SellOrders = append(m.SellOrders, &SpotLimitOrder{})
			if err := m.SellOrders[len(m.SellOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNewDerivativeOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNewDerivativeOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNewDerivativeOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyOrders = append(m.BuyOrders, &DerivativeLimitOrder{})
			if err := m.BuyOrders[len(m.BuyOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SellOrders = append(m.SellOrders, &DerivativeLimitOrder{})
			if err := m.SellOrders[len(m.SellOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSpotMarketUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSpotMarketUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSpotMarketUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPerpetualMarketUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPerpetualMarketUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPerpetualMarketUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualMarketInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerpetualMarketInfo == nil {
				m.PerpetualMarketInfo = &PerpetualMarketInfo{}
			}
			if err := m.PerpetualMarketInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Funding == nil {
				m.Funding = &PerpetualMarketFunding{}
			}
			if err := m.Funding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventExpiryFuturesMarketUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventExpiryFuturesMarketUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventExpiryFuturesMarketUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryFuturesMarketInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryFuturesMarketInfo == nil {
				m.ExpiryFuturesMarketInfo = &ExpiryFuturesMarketInfo{}
			}
			if err := m.ExpiryFuturesMarketInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPerpetualMarketFundingUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPerpetualMarketFundingUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPerpetualMarketFundingUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Funding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHourlyFunding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHourlyFunding = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.FundingRate = &v
			if err := m.FundingRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MarkPrice = &v
			if err := m.MarkPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSubaccountDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSubaccountDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSubaccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = append(m.SubaccountId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubaccountId == nil {
				m.SubaccountId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSubaccountWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSubaccountWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSubaccountWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = append(m.SubaccountId[:0], dAtA[iNdEx:postIndex]...)
			if m.SubaccountId == nil {
				m.SubaccountId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSubaccountBalanceTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSubaccountBalanceTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSubaccountBalanceTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBatchDepositUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBatchDepositUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBatchDepositUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositUpdates = append(m.DepositUpdates, &DepositUpdate{})
			if err := m.DepositUpdates[len(m.DepositUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeMarketOrderCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarketOrderCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarketOrderCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarketOrder == nil {
				m.MarketOrder = &DerivativeMarketOrder{}
			}
			if err := m.MarketOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CancelQuantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLimitCancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLimitCancel = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LimitOrder == nil {
				m.LimitOrder = &DerivativeLimitOrder{}
			}
			if err := m.LimitOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketOrderCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarketOrderCancel == nil {
				m.MarketOrderCancel = &DerivativeMarketOrderCancel{}
			}
			if err := m.MarketOrderCancel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFeeDiscountSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFeeDiscountSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFeeDiscountSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &FeeDiscountSchedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradingRewardCampaignUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradingRewardCampaignUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradingRewardCampaignUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CampaignInfo == nil {
				m.CampaignInfo = &TradingRewardCampaignInfo{}
			}
			if err := m.CampaignInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignRewardPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignRewardPools = append(m.CampaignRewardPools, &CampaignRewardPool{})
			if err := m.CampaignRewardPools[len(m.CampaignRewardPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradingRewardDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradingRewardDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradingRewardDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountRewards = append(m.AccountRewards, &AccountRewards{})
			if err := m.AccountRewards[len(m.AccountRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNewConditionalDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNewConditionalDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNewConditionalDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &DerivativeOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMarket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMarket = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelConditionalDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelConditionalDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelConditionalDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLimitCancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLimitCancel = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LimitOrder == nil {
				m.LimitOrder = &DerivativeLimitOrder{}
			}
			if err := m.LimitOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarketOrder == nil {
				m.MarketOrder = &DerivativeMarketOrder{}
			}
			if err := m.MarketOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventConditionalDerivativeOrderTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventConditionalDerivativeOrderTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventConditionalDerivativeOrderTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = append(m.MarketId[:0], dAtA[iNdEx:postIndex]...)
			if m.MarketId == nil {
				m.MarketId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLimitTrigger", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLimitTrigger = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredOrderHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggeredOrderHash = append(m.TriggeredOrderHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TriggeredOrderHash == nil {
				m.TriggeredOrderHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacedOrderHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlacedOrderHash = append(m.PlacedOrderHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PlacedOrderHash == nil {
				m.PlacedOrderHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderFail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderFail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderFail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = append(m.Account[:0], dAtA[iNdEx:postIndex]...)
			if m.Account == nil {
				m.Account = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hashes = append(m.Hashes, make([]byte, postIndex-iNdEx))
			copy(m.Hashes[len(m.Hashes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Flags = append(m.Flags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Flags) == 0 {
					m.Flags = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Flags = append(m.Flags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAtomicMarketOrderFeeMultipliersUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAtomicMarketOrderFeeMultipliersUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAtomicMarketOrderFeeMultipliersUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketFeeMultipliers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketFeeMultipliers = append(m.MarketFeeMultipliers, &MarketFeeMultiplier{})
			if err := m.MarketFeeMultipliers[len(m.MarketFeeMultipliers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOrderbookUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOrderbookUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOrderbookUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotUpdates = append(m.SpotUpdates, &OrderbookUpdate{})
			if err := m.SpotUpdates[len(m.SpotUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeUpdates = append(m.DerivativeUpdates, &OrderbookUpdate{})
			if err := m.DerivativeUpdates[len(m.DerivativeUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderbookUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderbookUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderbookUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orderbook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Orderbook == nil {
				m.Orderbook = &Orderbook{}
			}
			if err := m.Orderbook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Orderbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Orderbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Orderbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = append(m.MarketId[:0], dAtA[iNdEx:postIndex]...)
			if m.MarketId == nil {
				m.MarketId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyLevels = append(m.BuyLevels, &Level{})
			if err := m.BuyLevels[len(m.BuyLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SellLevels = append(m.SellLevels, &Level{})
			if err := m.SellLevels[len(m.SellLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
