// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/exchange/v1beta1/proposal.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	types "github.com/InjectiveLabs/sdk-go/chain/oracle/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	types1 "github.com/cosmos/cosmos-sdk/x/distribution/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ExchangeType int32

const (
	ExchangeType_EXCHANGE_UNSPECIFIED ExchangeType = 0
	ExchangeType_SPOT                 ExchangeType = 1
	ExchangeType_DERIVATIVES          ExchangeType = 2
)

var ExchangeType_name = map[int32]string{
	0: "EXCHANGE_UNSPECIFIED",
	1: "SPOT",
	2: "DERIVATIVES",
}

var ExchangeType_value = map[string]int32{
	"EXCHANGE_UNSPECIFIED": 0,
	"SPOT":                 1,
	"DERIVATIVES":          2,
}

func (x ExchangeType) String() string {
	return proto.EnumName(ExchangeType_name, int32(x))
}

func (ExchangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{0}
}

type SpotMarketParamUpdateProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId    string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the spot market
	MakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the trade fee rate for takers on the spot market
	TakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the relayer fee share rate for the spot
	// market
	RelayerFeeShareRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"relayer_fee_share_rate,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price and
	// margin
	MinPriceTickSize *cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize *cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size,omitempty"`
	Status              MarketStatus                 `protobuf:"varint,9,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	Ticker              string                       `protobuf:"bytes,10,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional *cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional,omitempty"`
	AdminInfo   *AdminInfo                   `protobuf:"bytes,12,opt,name=admin_info,json=adminInfo,proto3" json:"admin_info,omitempty"`
	// base token decimals
	BaseDecimals uint32 `protobuf:"varint,13,opt,name=base_decimals,json=baseDecimals,proto3" json:"base_decimals,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,14,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
}

func (m *SpotMarketParamUpdateProposal) Reset()         { *m = SpotMarketParamUpdateProposal{} }
func (m *SpotMarketParamUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*SpotMarketParamUpdateProposal) ProtoMessage()    {}
func (*SpotMarketParamUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{0}
}
func (m *SpotMarketParamUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarketParamUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarketParamUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarketParamUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarketParamUpdateProposal.Merge(m, src)
}
func (m *SpotMarketParamUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarketParamUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarketParamUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarketParamUpdateProposal proto.InternalMessageInfo

type ExchangeEnableProposal struct {
	Title        string       `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description  string       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ExchangeType ExchangeType `protobuf:"varint,3,opt,name=exchangeType,proto3,enum=injective.exchange.v1beta1.ExchangeType" json:"exchangeType,omitempty"`
}

func (m *ExchangeEnableProposal) Reset()         { *m = ExchangeEnableProposal{} }
func (m *ExchangeEnableProposal) String() string { return proto.CompactTextString(m) }
func (*ExchangeEnableProposal) ProtoMessage()    {}
func (*ExchangeEnableProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{1}
}
func (m *ExchangeEnableProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeEnableProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeEnableProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeEnableProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeEnableProposal.Merge(m, src)
}
func (m *ExchangeEnableProposal) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeEnableProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeEnableProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeEnableProposal proto.InternalMessageInfo

type BatchExchangeModificationProposal struct {
	Title                                string                                    `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description                          string                                    `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	SpotMarketParamUpdateProposals       []*SpotMarketParamUpdateProposal          `protobuf:"bytes,3,rep,name=spot_market_param_update_proposals,json=spotMarketParamUpdateProposals,proto3" json:"spot_market_param_update_proposals,omitempty"`
	DerivativeMarketParamUpdateProposals []*DerivativeMarketParamUpdateProposal    `protobuf:"bytes,4,rep,name=derivative_market_param_update_proposals,json=derivativeMarketParamUpdateProposals,proto3" json:"derivative_market_param_update_proposals,omitempty"`
	SpotMarketLaunchProposals            []*SpotMarketLaunchProposal               `protobuf:"bytes,5,rep,name=spot_market_launch_proposals,json=spotMarketLaunchProposals,proto3" json:"spot_market_launch_proposals,omitempty"`
	PerpetualMarketLaunchProposals       []*PerpetualMarketLaunchProposal          `protobuf:"bytes,6,rep,name=perpetual_market_launch_proposals,json=perpetualMarketLaunchProposals,proto3" json:"perpetual_market_launch_proposals,omitempty"`
	ExpiryFuturesMarketLaunchProposals   []*ExpiryFuturesMarketLaunchProposal      `protobuf:"bytes,7,rep,name=expiry_futures_market_launch_proposals,json=expiryFuturesMarketLaunchProposals,proto3" json:"expiry_futures_market_launch_proposals,omitempty"`
	TradingRewardCampaignUpdateProposal  *TradingRewardCampaignUpdateProposal      `protobuf:"bytes,8,opt,name=trading_reward_campaign_update_proposal,json=tradingRewardCampaignUpdateProposal,proto3" json:"trading_reward_campaign_update_proposal,omitempty"`
	BinaryOptionsMarketLaunchProposals   []*BinaryOptionsMarketLaunchProposal      `protobuf:"bytes,9,rep,name=binary_options_market_launch_proposals,json=binaryOptionsMarketLaunchProposals,proto3" json:"binary_options_market_launch_proposals,omitempty"`
	BinaryOptionsParamUpdateProposals    []*BinaryOptionsMarketParamUpdateProposal `protobuf:"bytes,10,rep,name=binary_options_param_update_proposals,json=binaryOptionsParamUpdateProposals,proto3" json:"binary_options_param_update_proposals,omitempty"`
	DenomDecimalsUpdateProposal          *UpdateDenomDecimalsProposal              `protobuf:"bytes,11,opt,name=denom_decimals_update_proposal,json=denomDecimalsUpdateProposal,proto3" json:"denom_decimals_update_proposal,omitempty"`
	FeeDiscountProposal                  *FeeDiscountProposal                      `protobuf:"bytes,12,opt,name=fee_discount_proposal,json=feeDiscountProposal,proto3" json:"fee_discount_proposal,omitempty"`
	MarketForcedSettlementProposals      []*MarketForcedSettlementProposal         `protobuf:"bytes,13,rep,name=market_forced_settlement_proposals,json=marketForcedSettlementProposals,proto3" json:"market_forced_settlement_proposals,omitempty"`
	DenomMinNotionalProposal             *DenomMinNotionalProposal                 `protobuf:"bytes,14,opt,name=denom_min_notional_proposal,json=denomMinNotionalProposal,proto3" json:"denom_min_notional_proposal,omitempty"`
}

func (m *BatchExchangeModificationProposal) Reset()         { *m = BatchExchangeModificationProposal{} }
func (m *BatchExchangeModificationProposal) String() string { return proto.CompactTextString(m) }
func (*BatchExchangeModificationProposal) ProtoMessage()    {}
func (*BatchExchangeModificationProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{2}
}
func (m *BatchExchangeModificationProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchExchangeModificationProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchExchangeModificationProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchExchangeModificationProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchExchangeModificationProposal.Merge(m, src)
}
func (m *BatchExchangeModificationProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchExchangeModificationProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchExchangeModificationProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchExchangeModificationProposal proto.InternalMessageInfo

// SpotMarketLaunchProposal defines a SDK message for proposing a new spot
// market through governance
type SpotMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the spot market.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	BaseDenom string `protobuf:"bytes,4,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,5,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// maker_fee_rate defines the fee percentage makers pay when trading
	MakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the fee percentage takers pay when trading
	TakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate,omitempty"`
	// min_notional defines the minimum notional for orders in the market
	MinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
	AdminInfo   *AdminInfo                  `protobuf:"bytes,11,opt,name=admin_info,json=adminInfo,proto3" json:"admin_info,omitempty"`
	// base token decimals
	BaseDecimals uint32 `protobuf:"varint,14,opt,name=base_decimals,json=baseDecimals,proto3" json:"base_decimals,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,15,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
}

func (m *SpotMarketLaunchProposal) Reset()         { *m = SpotMarketLaunchProposal{} }
func (m *SpotMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*SpotMarketLaunchProposal) ProtoMessage()    {}
func (*SpotMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{3}
}
func (m *SpotMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarketLaunchProposal.Merge(m, src)
}
func (m *SpotMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarketLaunchProposal proto.InternalMessageInfo

// PerpetualMarketLaunchProposal defines a SDK message for proposing a new
// perpetual futures market through governance
type PerpetualMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	QuoteDenom string `protobuf:"bytes,4,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,5,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,6,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types.OracleType `protobuf:"varint,8,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// initial_margin_ratio defines the initial margin ratio for the derivative
	// market
	InitialMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the
	// derivative market
	MaintenanceMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maintenance_margin_ratio"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative
	// market
	MakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative
	// market
	TakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate"`
	// min_price_tick_size defines the minimum tick size of the order's price and
	// margin
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,15,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
	AdminInfo   *AdminInfo                  `protobuf:"bytes,16,opt,name=admin_info,json=adminInfo,proto3" json:"admin_info,omitempty"`
}

func (m *PerpetualMarketLaunchProposal) Reset()         { *m = PerpetualMarketLaunchProposal{} }
func (m *PerpetualMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*PerpetualMarketLaunchProposal) ProtoMessage()    {}
func (*PerpetualMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{4}
}
func (m *PerpetualMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerpetualMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerpetualMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerpetualMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerpetualMarketLaunchProposal.Merge(m, src)
}
func (m *PerpetualMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *PerpetualMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_PerpetualMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_PerpetualMarketLaunchProposal proto.InternalMessageInfo

type BinaryOptionsMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle symbol
	OracleSymbol string `protobuf:"bytes,4,opt,name=oracle_symbol,json=oracleSymbol,proto3" json:"oracle_symbol,omitempty"`
	// Oracle Provider
	OracleProvider string `protobuf:"bytes,5,opt,name=oracle_provider,json=oracleProvider,proto3" json:"oracle_provider,omitempty"`
	// Oracle type
	OracleType types.OracleType `protobuf:"varint,6,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,8,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,9,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// admin of the market
	Admin string `protobuf:"bytes,10,opt,name=admin,proto3" json:"admin,omitempty"`
	// Address of the quote currency denomination for the binary options contract
	QuoteDenom string `protobuf:"bytes,11,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// maker_fee_rate defines the maker fee rate of a binary options market
	MakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate"`
	// taker_fee_rate defines the taker fee rate of a derivative market
	TakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate"`
	// min_price_tick_size defines the minimum tick size that the price and margin
	// required for orders in the market
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,15,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional      cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
	AdminPermissions uint32                      `protobuf:"varint,17,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
}

func (m *BinaryOptionsMarketLaunchProposal) Reset()         { *m = BinaryOptionsMarketLaunchProposal{} }
func (m *BinaryOptionsMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*BinaryOptionsMarketLaunchProposal) ProtoMessage()    {}
func (*BinaryOptionsMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{5}
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOptionsMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOptionsMarketLaunchProposal.Merge(m, src)
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOptionsMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOptionsMarketLaunchProposal proto.InternalMessageInfo

// ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new
// expiry futures market through governance
type ExpiryFuturesMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,4,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,5,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,6,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types.OracleType `protobuf:"varint,8,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Expiration time of the market
	Expiry int64 `protobuf:"varint,9,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// initial_margin_ratio defines the initial margin ratio for the derivative
	// market
	InitialMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the
	// derivative market
	MaintenanceMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maintenance_margin_ratio"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative
	// market
	MakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative
	// market
	TakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate"`
	// min_price_tick_size defines the minimum tick size of the order's price and
	// margin
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,15,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
	AdminInfo   *AdminInfo                  `protobuf:"bytes,17,opt,name=admin_info,json=adminInfo,proto3" json:"admin_info,omitempty"`
}

func (m *ExpiryFuturesMarketLaunchProposal) Reset()         { *m = ExpiryFuturesMarketLaunchProposal{} }
func (m *ExpiryFuturesMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*ExpiryFuturesMarketLaunchProposal) ProtoMessage()    {}
func (*ExpiryFuturesMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{6}
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpiryFuturesMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpiryFuturesMarketLaunchProposal.Merge(m, src)
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpiryFuturesMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ExpiryFuturesMarketLaunchProposal proto.InternalMessageInfo

type DerivativeMarketParamUpdateProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId    string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// initial_margin_ratio defines the initial margin ratio for the derivative
	// market
	InitialMarginRatio *cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"initial_margin_ratio,omitempty"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the
	// derivative market
	MaintenanceMarginRatio *cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maintenance_margin_ratio,omitempty"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative
	// market
	MakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative
	// market
	TakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the relayer fee share rate for the
	// derivative market
	RelayerFeeShareRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"relayer_fee_share_rate,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price and
	// margin
	MinPriceTickSize *cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize *cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size,omitempty"`
	// hourly_interest_rate defines the hourly interest rate
	HourlyInterestRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=HourlyInterestRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"HourlyInterestRate,omitempty"`
	// hourly_funding_rate_cap defines the maximum absolute value of the hourly
	// funding rate
	HourlyFundingRateCap *cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=HourlyFundingRateCap,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"HourlyFundingRateCap,omitempty"`
	Status               MarketStatus                 `protobuf:"varint,13,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	OracleParams         *OracleParams                `protobuf:"bytes,14,opt,name=oracle_params,json=oracleParams,proto3" json:"oracle_params,omitempty"`
	Ticker               string                       `protobuf:"bytes,15,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional *cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional,omitempty"`
	AdminInfo   *AdminInfo                   `protobuf:"bytes,17,opt,name=admin_info,json=adminInfo,proto3" json:"admin_info,omitempty"`
}

func (m *DerivativeMarketParamUpdateProposal) Reset()         { *m = DerivativeMarketParamUpdateProposal{} }
func (m *DerivativeMarketParamUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarketParamUpdateProposal) ProtoMessage()    {}
func (*DerivativeMarketParamUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{7}
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarketParamUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarketParamUpdateProposal.Merge(m, src)
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarketParamUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarketParamUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarketParamUpdateProposal proto.InternalMessageInfo

type AdminInfo struct {
	Admin            string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	AdminPermissions uint32 `protobuf:"varint,2,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
}

func (m *AdminInfo) Reset()         { *m = AdminInfo{} }
func (m *AdminInfo) String() string { return proto.CompactTextString(m) }
func (*AdminInfo) ProtoMessage()    {}
func (*AdminInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{8}
}
func (m *AdminInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminInfo.Merge(m, src)
}
func (m *AdminInfo) XXX_Size() int {
	return m.Size()
}
func (m *AdminInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AdminInfo proto.InternalMessageInfo

func (m *AdminInfo) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *AdminInfo) GetAdminPermissions() uint32 {
	if m != nil {
		return m.AdminPermissions
	}
	return 0
}

type MarketForcedSettlementProposal struct {
	Title           string                       `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description     string                       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId        string                       `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SettlementPrice *cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=settlement_price,json=settlementPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"settlement_price,omitempty"`
}

func (m *MarketForcedSettlementProposal) Reset()         { *m = MarketForcedSettlementProposal{} }
func (m *MarketForcedSettlementProposal) String() string { return proto.CompactTextString(m) }
func (*MarketForcedSettlementProposal) ProtoMessage()    {}
func (*MarketForcedSettlementProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{9}
}
func (m *MarketForcedSettlementProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketForcedSettlementProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketForcedSettlementProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketForcedSettlementProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketForcedSettlementProposal.Merge(m, src)
}
func (m *MarketForcedSettlementProposal) XXX_Size() int {
	return m.Size()
}
func (m *MarketForcedSettlementProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketForcedSettlementProposal.DiscardUnknown(m)
}

var xxx_messageInfo_MarketForcedSettlementProposal proto.InternalMessageInfo

type UpdateDenomDecimalsProposal struct {
	Title         string           `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description   string           `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	DenomDecimals []*DenomDecimals `protobuf:"bytes,3,rep,name=denom_decimals,json=denomDecimals,proto3" json:"denom_decimals,omitempty"`
}

func (m *UpdateDenomDecimalsProposal) Reset()         { *m = UpdateDenomDecimalsProposal{} }
func (m *UpdateDenomDecimalsProposal) String() string { return proto.CompactTextString(m) }
func (*UpdateDenomDecimalsProposal) ProtoMessage()    {}
func (*UpdateDenomDecimalsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{10}
}
func (m *UpdateDenomDecimalsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDenomDecimalsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDenomDecimalsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDenomDecimalsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDenomDecimalsProposal.Merge(m, src)
}
func (m *UpdateDenomDecimalsProposal) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDenomDecimalsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDenomDecimalsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDenomDecimalsProposal proto.InternalMessageInfo

type BinaryOptionsMarketParamUpdateProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId    string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative
	// market
	MakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative
	// market
	TakerFeeRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the relayer fee share rate for the
	// derivative market
	RelayerFeeShareRate *cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"relayer_fee_share_rate,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price and
	// margin
	MinPriceTickSize *cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize *cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,9,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,10,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// new price at which market will be settled
	SettlementPrice *cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=settlement_price,json=settlementPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"settlement_price,omitempty"`
	// admin of the market
	Admin        string                `protobuf:"bytes,12,opt,name=admin,proto3" json:"admin,omitempty"`
	Status       MarketStatus          `protobuf:"varint,13,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	OracleParams *ProviderOracleParams `protobuf:"bytes,14,opt,name=oracle_params,json=oracleParams,proto3" json:"oracle_params,omitempty"`
	Ticker       string                `protobuf:"bytes,15,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional *cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional,omitempty"`
}

func (m *BinaryOptionsMarketParamUpdateProposal) Reset() {
	*m = BinaryOptionsMarketParamUpdateProposal{}
}
func (m *BinaryOptionsMarketParamUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*BinaryOptionsMarketParamUpdateProposal) ProtoMessage()    {}
func (*BinaryOptionsMarketParamUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{11}
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal.Merge(m, src)
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal proto.InternalMessageInfo

type ProviderOracleParams struct {
	// Oracle base currency
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Oracle quote currency
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,3,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
}

func (m *ProviderOracleParams) Reset()         { *m = ProviderOracleParams{} }
func (m *ProviderOracleParams) String() string { return proto.CompactTextString(m) }
func (*ProviderOracleParams) ProtoMessage()    {}
func (*ProviderOracleParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{12}
}
func (m *ProviderOracleParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderOracleParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderOracleParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderOracleParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderOracleParams.Merge(m, src)
}
func (m *ProviderOracleParams) XXX_Size() int {
	return m.Size()
}
func (m *ProviderOracleParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderOracleParams.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderOracleParams proto.InternalMessageInfo

func (m *ProviderOracleParams) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *ProviderOracleParams) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ProviderOracleParams) GetOracleScaleFactor() uint32 {
	if m != nil {
		return m.OracleScaleFactor
	}
	return 0
}

func (m *ProviderOracleParams) GetOracleType() types.OracleType {
	if m != nil {
		return m.OracleType
	}
	return types.OracleType_Unspecified
}

type OracleParams struct {
	// Oracle base currency
	OracleBase string `protobuf:"bytes,1,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,2,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,3,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
}

func (m *OracleParams) Reset()         { *m = OracleParams{} }
func (m *OracleParams) String() string { return proto.CompactTextString(m) }
func (*OracleParams) ProtoMessage()    {}
func (*OracleParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{13}
}
func (m *OracleParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleParams.Merge(m, src)
}
func (m *OracleParams) XXX_Size() int {
	return m.Size()
}
func (m *OracleParams) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleParams.DiscardUnknown(m)
}

var xxx_messageInfo_OracleParams proto.InternalMessageInfo

func (m *OracleParams) GetOracleBase() string {
	if m != nil {
		return m.OracleBase
	}
	return ""
}

func (m *OracleParams) GetOracleQuote() string {
	if m != nil {
		return m.OracleQuote
	}
	return ""
}

func (m *OracleParams) GetOracleScaleFactor() uint32 {
	if m != nil {
		return m.OracleScaleFactor
	}
	return 0
}

func (m *OracleParams) GetOracleType() types.OracleType {
	if m != nil {
		return m.OracleType
	}
	return types.OracleType_Unspecified
}

type TradingRewardCampaignLaunchProposal struct {
	Title               string                     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description         string                     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	CampaignInfo        *TradingRewardCampaignInfo `protobuf:"bytes,3,opt,name=campaign_info,json=campaignInfo,proto3" json:"campaign_info,omitempty"`
	CampaignRewardPools []*CampaignRewardPool      `protobuf:"bytes,4,rep,name=campaign_reward_pools,json=campaignRewardPools,proto3" json:"campaign_reward_pools,omitempty"`
}

func (m *TradingRewardCampaignLaunchProposal) Reset()         { *m = TradingRewardCampaignLaunchProposal{} }
func (m *TradingRewardCampaignLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*TradingRewardCampaignLaunchProposal) ProtoMessage()    {}
func (*TradingRewardCampaignLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{14}
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingRewardCampaignLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingRewardCampaignLaunchProposal.Merge(m, src)
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *TradingRewardCampaignLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingRewardCampaignLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TradingRewardCampaignLaunchProposal proto.InternalMessageInfo

type TradingRewardCampaignUpdateProposal struct {
	Title                        string                     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description                  string                     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	CampaignInfo                 *TradingRewardCampaignInfo `protobuf:"bytes,3,opt,name=campaign_info,json=campaignInfo,proto3" json:"campaign_info,omitempty"`
	CampaignRewardPoolsAdditions []*CampaignRewardPool      `protobuf:"bytes,4,rep,name=campaign_reward_pools_additions,json=campaignRewardPoolsAdditions,proto3" json:"campaign_reward_pools_additions,omitempty"`
	CampaignRewardPoolsUpdates   []*CampaignRewardPool      `protobuf:"bytes,5,rep,name=campaign_reward_pools_updates,json=campaignRewardPoolsUpdates,proto3" json:"campaign_reward_pools_updates,omitempty"`
}

func (m *TradingRewardCampaignUpdateProposal) Reset()         { *m = TradingRewardCampaignUpdateProposal{} }
func (m *TradingRewardCampaignUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*TradingRewardCampaignUpdateProposal) ProtoMessage()    {}
func (*TradingRewardCampaignUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{15}
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingRewardCampaignUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingRewardCampaignUpdateProposal.Merge(m, src)
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *TradingRewardCampaignUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingRewardCampaignUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TradingRewardCampaignUpdateProposal proto.InternalMessageInfo

type RewardPointUpdate struct {
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address,omitempty"`
	// new_points overwrites the current trading reward points for the account
	NewPoints cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=new_points,json=newPoints,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_points"`
}

func (m *RewardPointUpdate) Reset()         { *m = RewardPointUpdate{} }
func (m *RewardPointUpdate) String() string { return proto.CompactTextString(m) }
func (*RewardPointUpdate) ProtoMessage()    {}
func (*RewardPointUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{16}
}
func (m *RewardPointUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardPointUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardPointUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardPointUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardPointUpdate.Merge(m, src)
}
func (m *RewardPointUpdate) XXX_Size() int {
	return m.Size()
}
func (m *RewardPointUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardPointUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_RewardPointUpdate proto.InternalMessageInfo

func (m *RewardPointUpdate) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

type TradingRewardPendingPointsUpdateProposal struct {
	Title                string               `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description          string               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	PendingPoolTimestamp int64                `protobuf:"varint,3,opt,name=pending_pool_timestamp,json=pendingPoolTimestamp,proto3" json:"pending_pool_timestamp,omitempty"`
	RewardPointUpdates   []*RewardPointUpdate `protobuf:"bytes,4,rep,name=reward_point_updates,json=rewardPointUpdates,proto3" json:"reward_point_updates,omitempty"`
}

func (m *TradingRewardPendingPointsUpdateProposal) Reset() {
	*m = TradingRewardPendingPointsUpdateProposal{}
}
func (m *TradingRewardPendingPointsUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*TradingRewardPendingPointsUpdateProposal) ProtoMessage()    {}
func (*TradingRewardPendingPointsUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{17}
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingRewardPendingPointsUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingRewardPendingPointsUpdateProposal.Merge(m, src)
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingRewardPendingPointsUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TradingRewardPendingPointsUpdateProposal proto.InternalMessageInfo

type FeeDiscountProposal struct {
	Title       string               `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Schedule    *FeeDiscountSchedule `protobuf:"bytes,3,opt,name=schedule,proto3" json:"schedule,omitempty"`
}

func (m *FeeDiscountProposal) Reset()         { *m = FeeDiscountProposal{} }
func (m *FeeDiscountProposal) String() string { return proto.CompactTextString(m) }
func (*FeeDiscountProposal) ProtoMessage()    {}
func (*FeeDiscountProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{18}
}
func (m *FeeDiscountProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeDiscountProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeDiscountProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeDiscountProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeDiscountProposal.Merge(m, src)
}
func (m *FeeDiscountProposal) XXX_Size() int {
	return m.Size()
}
func (m *FeeDiscountProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeDiscountProposal.DiscardUnknown(m)
}

var xxx_messageInfo_FeeDiscountProposal proto.InternalMessageInfo

type BatchCommunityPoolSpendProposal struct {
	Title       string                               `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string                               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Proposals   []*types1.CommunityPoolSpendProposal `protobuf:"bytes,3,rep,name=proposals,proto3" json:"proposals,omitempty"`
}

func (m *BatchCommunityPoolSpendProposal) Reset()         { *m = BatchCommunityPoolSpendProposal{} }
func (m *BatchCommunityPoolSpendProposal) String() string { return proto.CompactTextString(m) }
func (*BatchCommunityPoolSpendProposal) ProtoMessage()    {}
func (*BatchCommunityPoolSpendProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{19}
}
func (m *BatchCommunityPoolSpendProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchCommunityPoolSpendProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchCommunityPoolSpendProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchCommunityPoolSpendProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCommunityPoolSpendProposal.Merge(m, src)
}
func (m *BatchCommunityPoolSpendProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchCommunityPoolSpendProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCommunityPoolSpendProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCommunityPoolSpendProposal proto.InternalMessageInfo

// AtomicMarketOrderFeeMultiplierScheduleProposal defines a SDK message for
// proposing new atomic take fee multipliers for specified markets
type AtomicMarketOrderFeeMultiplierScheduleProposal struct {
	Title                string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description          string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketFeeMultipliers []*MarketFeeMultiplier `protobuf:"bytes,3,rep,name=market_fee_multipliers,json=marketFeeMultipliers,proto3" json:"market_fee_multipliers,omitempty"`
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Reset() {
	*m = AtomicMarketOrderFeeMultiplierScheduleProposal{}
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) String() string {
	return proto.CompactTextString(m)
}
func (*AtomicMarketOrderFeeMultiplierScheduleProposal) ProtoMessage() {}
func (*AtomicMarketOrderFeeMultiplierScheduleProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{20}
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal.Merge(m, src)
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Size() int {
	return m.Size()
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal proto.InternalMessageInfo

type DenomMinNotionalProposal struct {
	Title             string              `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description       string              `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	DenomMinNotionals []*DenomMinNotional `protobuf:"bytes,3,rep,name=denom_min_notionals,json=denomMinNotionals,proto3" json:"denom_min_notionals,omitempty"`
}

func (m *DenomMinNotionalProposal) Reset()         { *m = DenomMinNotionalProposal{} }
func (m *DenomMinNotionalProposal) String() string { return proto.CompactTextString(m) }
func (*DenomMinNotionalProposal) ProtoMessage()    {}
func (*DenomMinNotionalProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_32e9ec9b6b22477c, []int{21}
}
func (m *DenomMinNotionalProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomMinNotionalProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomMinNotionalProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomMinNotionalProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomMinNotionalProposal.Merge(m, src)
}
func (m *DenomMinNotionalProposal) XXX_Size() int {
	return m.Size()
}
func (m *DenomMinNotionalProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomMinNotionalProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DenomMinNotionalProposal proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("injective.exchange.v1beta1.ExchangeType", ExchangeType_name, ExchangeType_value)
	proto.RegisterType((*SpotMarketParamUpdateProposal)(nil), "injective.exchange.v1beta1.SpotMarketParamUpdateProposal")
	proto.RegisterType((*ExchangeEnableProposal)(nil), "injective.exchange.v1beta1.ExchangeEnableProposal")
	proto.RegisterType((*BatchExchangeModificationProposal)(nil), "injective.exchange.v1beta1.BatchExchangeModificationProposal")
	proto.RegisterType((*SpotMarketLaunchProposal)(nil), "injective.exchange.v1beta1.SpotMarketLaunchProposal")
	proto.RegisterType((*PerpetualMarketLaunchProposal)(nil), "injective.exchange.v1beta1.PerpetualMarketLaunchProposal")
	proto.RegisterType((*BinaryOptionsMarketLaunchProposal)(nil), "injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal")
	proto.RegisterType((*ExpiryFuturesMarketLaunchProposal)(nil), "injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal")
	proto.RegisterType((*DerivativeMarketParamUpdateProposal)(nil), "injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal")
	proto.RegisterType((*AdminInfo)(nil), "injective.exchange.v1beta1.AdminInfo")
	proto.RegisterType((*MarketForcedSettlementProposal)(nil), "injective.exchange.v1beta1.MarketForcedSettlementProposal")
	proto.RegisterType((*UpdateDenomDecimalsProposal)(nil), "injective.exchange.v1beta1.UpdateDenomDecimalsProposal")
	proto.RegisterType((*BinaryOptionsMarketParamUpdateProposal)(nil), "injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal")
	proto.RegisterType((*ProviderOracleParams)(nil), "injective.exchange.v1beta1.ProviderOracleParams")
	proto.RegisterType((*OracleParams)(nil), "injective.exchange.v1beta1.OracleParams")
	proto.RegisterType((*TradingRewardCampaignLaunchProposal)(nil), "injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal")
	proto.RegisterType((*TradingRewardCampaignUpdateProposal)(nil), "injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal")
	proto.RegisterType((*RewardPointUpdate)(nil), "injective.exchange.v1beta1.RewardPointUpdate")
	proto.RegisterType((*TradingRewardPendingPointsUpdateProposal)(nil), "injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal")
	proto.RegisterType((*FeeDiscountProposal)(nil), "injective.exchange.v1beta1.FeeDiscountProposal")
	proto.RegisterType((*BatchCommunityPoolSpendProposal)(nil), "injective.exchange.v1beta1.BatchCommunityPoolSpendProposal")
	proto.RegisterType((*AtomicMarketOrderFeeMultiplierScheduleProposal)(nil), "injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal")
	proto.RegisterType((*DenomMinNotionalProposal)(nil), "injective.exchange.v1beta1.DenomMinNotionalProposal")
}

func init() {
	proto.RegisterFile("injective/exchange/v1beta1/proposal.proto", fileDescriptor_32e9ec9b6b22477c)
}

var fileDescriptor_32e9ec9b6b22477c = []byte{
	// 2551 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x77, 0xdb, 0x8e, 0xed, 0x79, 0x33, 0x1e, 0xdb, 0x6d, 0xaf, 0x99, 0x75, 0x12, 0x7f, 0x8c,
	0x37, 0x89, 0x37, 0x24, 0x33, 0x24, 0x04, 0x45, 0x58, 0x42, 0xe0, 0xcf, 0x5d, 0x8b, 0xd8, 0x99,
	0xf4, 0xd8, 0xbb, 0xab, 0x68, 0x51, 0xab, 0xa6, 0xbb, 0x6c, 0x17, 0x99, 0xfe, 0x48, 0x57, 0x8f,
	0x13, 0xaf, 0x38, 0x70, 0x60, 0x05, 0x0a, 0x17, 0x40, 0x7c, 0x88, 0x43, 0xc4, 0x9e, 0x38, 0x23,
	0xc1, 0x3f, 0x00, 0x07, 0xb4, 0x20, 0x0e, 0x7b, 0x03, 0x71, 0x58, 0xa1, 0x44, 0x08, 0xfe, 0x02,
	0xc4, 0x01, 0x21, 0xd4, 0x55, 0xd5, 0x3d, 0x3d, 0x33, 0x3d, 0x3d, 0x3d, 0xe3, 0xb1, 0xf6, 0x40,
	0x2e, 0xc9, 0xf4, 0xab, 0x57, 0xaf, 0x5e, 0xbd, 0x57, 0xef, 0xd5, 0xaf, 0xaa, 0x9e, 0xe1, 0x4d,
	0x62, 0x7e, 0x13, 0x6b, 0x2e, 0x39, 0xc1, 0x45, 0xfc, 0x54, 0x3b, 0x46, 0xe6, 0x11, 0x2e, 0x9e,
	0xdc, 0xaa, 0x60, 0x17, 0xdd, 0x2a, 0xda, 0x8e, 0x65, 0x5b, 0x14, 0x55, 0x0b, 0xb6, 0x63, 0xb9,
	0x96, 0x3c, 0x17, 0xb0, 0x16, 0x7c, 0xd6, 0x82, 0x60, 0x9d, 0x9b, 0xd7, 0x2c, 0x6a, 0x58, 0xb4,
	0x58, 0x41, 0xb4, 0xde, 0x5f, 0xb3, 0x88, 0xc9, 0xfb, 0xce, 0x15, 0x44, 0xbb, 0x4e, 0xa8, 0xeb,
	0x90, 0x4a, 0xcd, 0x25, 0x96, 0x19, 0xf0, 0x85, 0x89, 0x82, 0xff, 0x73, 0x82, 0xdf, 0xa0, 0x47,
	0xc5, 0x93, 0x5b, 0xde, 0x7f, 0xa2, 0xe1, 0x75, 0xde, 0xa0, 0xb2, 0xaf, 0x22, 0xff, 0x10, 0x4d,
	0x33, 0x47, 0xd6, 0x91, 0xc5, 0xe9, 0xde, 0x2f, 0x41, 0x8d, 0x9b, 0x60, 0x30, 0x0d, 0xce, 0x7a,
	0xa5, 0xce, 0x6a, 0x39, 0x48, 0xab, 0xd6, 0x19, 0xf9, 0xa7, 0x60, 0x9b, 0x42, 0x06, 0x31, 0xad,
	0x22, 0xfb, 0x97, 0x93, 0xf2, 0xbf, 0x18, 0x85, 0xcb, 0x65, 0xdb, 0x72, 0x77, 0x91, 0xf3, 0x08,
	0xbb, 0x25, 0xe4, 0x20, 0xe3, 0xc0, 0xd6, 0x91, 0x8b, 0x4b, 0xc2, 0x84, 0xf2, 0x0c, 0x5c, 0x70,
	0x89, 0x5b, 0xc5, 0x39, 0x69, 0x51, 0x5a, 0x49, 0x29, 0xfc, 0x43, 0x5e, 0x84, 0xb4, 0x8e, 0xa9,
	0xe6, 0x10, 0xdb, 0x9b, 0x7b, 0x6e, 0x90, 0xb5, 0x85, 0x49, 0xf2, 0x45, 0x48, 0x19, 0x4c, 0xa8,
	0x4a, 0xf4, 0xdc, 0x10, 0x6b, 0x1f, 0xe3, 0x84, 0x1d, 0x5d, 0xde, 0x81, 0xac, 0x81, 0x1e, 0x61,
	0x47, 0x3d, 0xc4, 0x58, 0x75, 0x90, 0x8b, 0x73, 0xc3, 0x1e, 0xc7, 0xfa, 0xf2, 0xc7, 0x9f, 0x2e,
	0x48, 0x7f, 0xfd, 0x74, 0xe1, 0x22, 0xb7, 0x0f, 0xd5, 0x1f, 0x15, 0x88, 0x55, 0x34, 0x90, 0x7b,
	0x5c, 0xb8, 0x87, 0x8f, 0x90, 0x76, 0xba, 0x89, 0x35, 0x25, 0xc3, 0xba, 0x6e, 0x63, 0xac, 0x20,
	0x17, 0x7b, 0xa2, 0xdc, 0x46, 0x51, 0x17, 0xba, 0x10, 0xe5, 0x86, 0x45, 0xbd, 0x07, 0xb3, 0x0e,
	0xae, 0xa2, 0x53, 0x21, 0x8c, 0x1e, 0x23, 0x47, 0x88, 0x1c, 0x49, 0x2e, 0x72, 0x5a, 0x88, 0xd8,
	0xc6, 0xb8, 0xec, 0x09, 0x60, 0x92, 0x15, 0x98, 0x36, 0x88, 0xa9, 0xda, 0x0e, 0xd1, 0xb0, 0xea,
	0x12, 0xed, 0x91, 0x4a, 0xc9, 0x07, 0x38, 0x37, 0x9a, 0x5c, 0xec, 0xa4, 0x41, 0xcc, 0x92, 0xd7,
	0x7d, 0x9f, 0x68, 0x8f, 0xca, 0xe4, 0x03, 0xa6, 0xad, 0x27, 0xf3, 0x71, 0x0d, 0x99, 0x2e, 0x71,
	0x4f, 0x43, 0x62, 0xc7, 0xba, 0xd0, 0xd6, 0x20, 0xe6, 0x03, 0x21, 0x21, 0x90, 0xfc, 0x35, 0x18,
	0xa1, 0x2e, 0x72, 0x6b, 0x34, 0x97, 0x5a, 0x94, 0x56, 0xb2, 0xb7, 0x57, 0x0a, 0xed, 0x03, 0xa8,
	0xc0, 0x57, 0x4e, 0x99, 0xf1, 0x2b, 0xa2, 0x9f, 0x7c, 0x09, 0x46, 0x3c, 0x75, 0xb0, 0x93, 0x03,
	0xa6, 0xcb, 0xb0, 0xa7, 0x8b, 0x22, 0x68, 0xf2, 0x36, 0x64, 0x3c, 0xcd, 0x4d, 0xcb, 0x5b, 0x28,
	0xa8, 0x9a, 0x4b, 0x27, 0xd7, 0x37, 0x6d, 0x10, 0x73, 0x4f, 0xf4, 0x93, 0x37, 0x01, 0x90, 0xee,
	0x49, 0x22, 0xe6, 0xa1, 0x95, 0xcb, 0x2c, 0x4a, 0x2b, 0xe9, 0xdb, 0x57, 0xe2, 0x74, 0x5d, 0xf3,
	0xb8, 0x77, 0xcc, 0x43, 0x4b, 0x49, 0x21, 0xff, 0xa7, 0xbc, 0x0c, 0xe3, 0x5e, 0xf0, 0xab, 0x3a,
	0xd6, 0x88, 0x81, 0xaa, 0x34, 0x37, 0xbe, 0x28, 0xad, 0x8c, 0x2b, 0x19, 0x8f, 0xb8, 0x29, 0x68,
	0xf2, 0x15, 0xc8, 0x3e, 0xae, 0x59, 0x6e, 0x88, 0x2b, 0xcb, 0xb8, 0xc6, 0x19, 0xd5, 0x67, 0x5b,
	0x7d, 0xf0, 0xbd, 0x8f, 0x16, 0x06, 0xfe, 0xf9, 0xd1, 0xc2, 0xc0, 0x1f, 0x7f, 0x73, 0x73, 0x4e,
	0xc4, 0xf8, 0x91, 0x75, 0x12, 0x28, 0xb0, 0x61, 0x99, 0x2e, 0x36, 0xdd, 0x67, 0xff, 0xf8, 0xd5,
	0xf5, 0xab, 0x41, 0x50, 0xc7, 0xc6, 0x5f, 0xfe, 0x4f, 0x12, 0xcc, 0x6e, 0x09, 0xd6, 0x2d, 0x13,
	0x55, 0xaa, 0x67, 0x0f, 0xcd, 0x7b, 0x90, 0xf1, 0x07, 0xdf, 0x3f, 0xb5, 0x31, 0x8b, 0xce, 0x0e,
	0x5e, 0xde, 0x0a, 0xf1, 0x2b, 0x0d, 0xbd, 0x57, 0x6f, 0xf8, 0x73, 0xf6, 0x66, 0xb5, 0x10, 0xcc,
	0x2a, 0x5a, 0xe7, 0xfc, 0xf7, 0xb3, 0xb0, 0xb4, 0x8e, 0x5c, 0xed, 0xd8, 0x6f, 0xdf, 0xb5, 0x74,
	0x72, 0x48, 0x34, 0xe4, 0x69, 0x76, 0xe6, 0x99, 0x7d, 0x28, 0x41, 0x9e, 0xda, 0x96, 0xab, 0x8a,
	0xd4, 0x63, 0x7b, 0x06, 0x55, 0x6b, 0xcc, 0xa2, 0xaa, 0xbf, 0x2b, 0xd0, 0xdc, 0xd0, 0xe2, 0xd0,
	0x4a, 0xfa, 0xf6, 0x97, 0xe3, 0x26, 0x1c, 0xeb, 0x14, 0x65, 0x9e, 0xc6, 0x35, 0x53, 0xf9, 0x67,
	0x12, 0xac, 0xe8, 0xd8, 0x21, 0x27, 0xc8, 0x93, 0xde, 0x41, 0x9b, 0x61, 0xa6, 0xcd, 0x57, 0xe3,
	0xb4, 0xd9, 0x0c, 0x64, 0xb5, 0xd7, 0xe9, 0x0d, 0xbd, 0x33, 0x13, 0x95, 0x6b, 0x70, 0x29, 0x6c,
	0xa0, 0x2a, 0xaa, 0x99, 0xda, 0x71, 0x48, 0x99, 0x0b, 0x4c, 0x99, 0x3b, 0xc9, 0x4c, 0x73, 0x8f,
	0xf5, 0x0e, 0x34, 0x78, 0x9d, 0xb6, 0x69, 0xa1, 0xf2, 0x77, 0x24, 0x58, 0xb2, 0xb1, 0x63, 0x63,
	0xb7, 0x86, 0xaa, 0x6d, 0x07, 0x1f, 0xe9, 0xec, 0x97, 0x92, 0x2f, 0x24, 0x52, 0x83, 0x79, 0x3b,
	0xae, 0x99, 0xca, 0x3f, 0x94, 0xe0, 0x2a, 0x7e, 0x6a, 0x13, 0xe7, 0x54, 0x3d, 0xac, 0xb9, 0x35,
	0x07, 0xd3, 0xb6, 0xba, 0x8c, 0x32, 0x5d, 0xbe, 0x12, 0x1f, 0x14, 0x9e, 0xa4, 0x6d, 0x2e, 0x28,
	0x52, 0x9f, 0x3c, 0xee, 0xc4, 0x42, 0xe5, 0x9f, 0x48, 0x70, 0xcd, 0x75, 0x90, 0x4e, 0xcc, 0x23,
	0xd5, 0xc1, 0x4f, 0x90, 0xa3, 0xab, 0x1a, 0x32, 0x6c, 0x44, 0x8e, 0xcc, 0xe6, 0xb5, 0xc2, 0x32,
	0x7b, 0x87, 0xa5, 0xb2, 0xcf, 0x45, 0x29, 0x4c, 0xd2, 0x86, 0x10, 0xd4, 0xb4, 0x54, 0x96, 0xdd,
	0xce, 0x4c, 0xcc, 0x56, 0x15, 0x62, 0x22, 0xe7, 0x54, 0xb5, 0x58, 0x74, 0xb5, 0xb7, 0x55, 0xaa,
	0xb3, 0xad, 0xd6, 0x99, 0xa4, 0xfb, 0x5c, 0x50, 0xb4, 0xad, 0x2a, 0x9d, 0x58, 0xa8, 0xfc, 0x63,
	0x09, 0xae, 0x34, 0xe9, 0xd4, 0x26, 0xa8, 0x80, 0xa9, 0xb4, 0xde, 0xa5, 0x4a, 0x51, 0x71, 0xb5,
	0xd4, 0xa0, 0x57, 0x64, 0x50, 0x7d, 0x0b, 0xe6, 0x75, 0x6c, 0x5a, 0x46, 0xb0, 0x3b, 0xb4, 0x38,
	0x2e, 0xcd, 0x1c, 0x77, 0x37, 0x4e, 0x1d, 0x2e, 0x74, 0xd3, 0x93, 0xe3, 0xef, 0x27, 0x81, 0x0e,
	0x17, 0xf5, 0x30, 0xb9, 0xc9, 0x51, 0x1a, 0xbc, 0xe6, 0xc1, 0x15, 0x9d, 0x50, 0xcd, 0xaa, 0x99,
	0x6e, 0x7d, 0x50, 0xbe, 0x23, 0x16, 0xe3, 0x06, 0xdd, 0xc6, 0x78, 0x53, 0xf4, 0x0b, 0x06, 0x9b,
	0x3e, 0x6c, 0x25, 0xca, 0xdf, 0x95, 0x20, 0x2f, 0xdc, 0x7f, 0x68, 0x39, 0x1a, 0xd6, 0x55, 0x8a,
	0x5d, 0xb7, 0x8a, 0x0d, 0x1c, 0x1a, 0xd1, 0xdb, 0x3b, 0x3d, 0xb3, 0xaf, 0x76, 0x06, 0x0c, 0xdb,
	0x4c, 0x48, 0x39, 0x90, 0x11, 0x8c, 0xbe, 0x60, 0xc4, 0xb6, 0x53, 0x99, 0x02, 0xb7, 0x86, 0x1a,
	0xc6, 0x10, 0xf5, 0x49, 0x67, 0xd9, 0xa4, 0xef, 0xc4, 0x67, 0x53, 0xd3, 0x32, 0x76, 0xeb, 0x40,
	0x22, 0x18, 0x3b, 0xa7, 0xb7, 0x69, 0x59, 0x3d, 0x48, 0xbe, 0xb1, 0x5f, 0x0f, 0xb6, 0xc0, 0x8e,
	0xfb, 0x5c, 0xfe, 0xa7, 0x23, 0x90, 0x6b, 0x97, 0x4e, 0x7b, 0xde, 0x04, 0x67, 0x03, 0xf0, 0xc5,
	0x61, 0xb7, 0x0f, 0xbb, 0x2e, 0x03, 0x08, 0xa0, 0x63, 0x5a, 0x06, 0x07, 0xdc, 0x4a, 0x8a, 0xa3,
	0x1c, 0xd3, 0x32, 0xe4, 0x05, 0x48, 0xfb, 0x10, 0xc7, 0x6b, 0x67, 0x28, 0x5a, 0x01, 0x81, 0x6f,
	0x3c, 0x86, 0x36, 0x20, 0xb6, 0x8e, 0x8d, 0x07, 0xfa, 0x09, 0x62, 0x47, 0x93, 0x8b, 0x8d, 0x04,
	0xb1, 0xad, 0x47, 0x8c, 0xb1, 0xfe, 0x1d, 0x31, 0x52, 0xbd, 0x1e, 0x31, 0x9a, 0xa1, 0x2f, 0x24,
	0x9f, 0x65, 0x0c, 0xf4, 0x4d, 0xf7, 0x0b, 0xfa, 0x66, 0x13, 0x41, 0xdf, 0x89, 0x28, 0xe8, 0x7b,
	0x2f, 0x79, 0x84, 0x2c, 0x45, 0x40, 0xdf, 0xc6, 0xb5, 0x9f, 0xff, 0xe5, 0x18, 0x5c, 0x8e, 0xdd,
	0xea, 0xfb, 0x1e, 0x1d, 0x4d, 0xcb, 0x7f, 0xb8, 0x65, 0xf9, 0x2f, 0x40, 0x9a, 0x9f, 0xa6, 0x55,
	0xcf, 0x3c, 0x7e, 0x7c, 0x70, 0xd2, 0x3a, 0xa2, 0x58, 0x5e, 0x82, 0x8c, 0x60, 0x60, 0xbd, 0x78,
	0x60, 0x28, 0xa2, 0xd3, 0x03, 0x8f, 0x24, 0x17, 0x60, 0x5a, 0xb0, 0x50, 0x0d, 0x55, 0xb1, 0x7a,
	0x88, 0x34, 0xd7, 0x72, 0xd8, 0x5a, 0x1f, 0x57, 0xa6, 0x78, 0x53, 0xd9, 0x6b, 0xd9, 0x66, 0x0d,
	0xf2, 0x56, 0x30, 0xa6, 0xeb, 0x01, 0xf5, 0x31, 0x06, 0xd4, 0xdf, 0x08, 0xf9, 0x59, 0x9c, 0xef,
	0x7d, 0x23, 0xdf, 0x67, 0x9f, 0x0c, 0xa4, 0x0b, 0xcd, 0xbc, 0xdf, 0xf2, 0x01, 0xcc, 0x10, 0x93,
	0xb8, 0x84, 0x43, 0xaf, 0x23, 0x62, 0x7a, 0xab, 0x98, 0x58, 0xa1, 0x65, 0xdc, 0x71, 0xf5, 0xc9,
	0x42, 0xc0, 0x2e, 0xeb, 0xaf, 0x78, 0xdd, 0xe5, 0x6f, 0x40, 0xce, 0x40, 0xc4, 0x73, 0x2b, 0x32,
	0x35, 0xdc, 0x28, 0xba, 0x8b, 0x85, 0x3d, 0x1b, 0x12, 0x12, 0x16, 0xdf, 0x1a, 0xc1, 0xe9, 0xe4,
	0x42, 0x3b, 0x45, 0x70, 0xa6, 0x0b, 0x51, 0x0d, 0x11, 0xdc, 0x26, 0x0b, 0x8e, 0x9f, 0x4f, 0x16,
	0xcc, 0x9e, 0x31, 0x0b, 0x36, 0xe7, 0x9b, 0x89, 0xbe, 0xe4, 0x9b, 0xc9, 0xde, 0xf2, 0x4d, 0x6f,
	0xc7, 0xe3, 0xd8, 0x34, 0x90, 0xff, 0xfb, 0x28, 0x2c, 0x75, 0xc4, 0x96, 0x7d, 0x4f, 0x16, 0xcb,
	0x30, 0xee, 0xc7, 0xf1, 0xa9, 0x51, 0xb1, 0xaa, 0x22, 0x5d, 0x88, 0xf8, 0x2f, 0x33, 0x9a, 0x7c,
	0x0d, 0x26, 0x04, 0x93, 0xed, 0x58, 0x27, 0x44, 0xc7, 0x8e, 0x48, 0x1a, 0x59, 0x4e, 0x2e, 0x09,
	0x6a, 0x73, 0x94, 0x8f, 0xf4, 0x18, 0xe5, 0xdd, 0x26, 0x97, 0x5b, 0x30, 0xc3, 0x8e, 0x27, 0x0c,
	0x92, 0xa8, 0x2e, 0x31, 0x30, 0x75, 0x91, 0x61, 0xb3, 0x2c, 0x33, 0xa4, 0x4c, 0xd7, 0xdb, 0xf6,
	0xfd, 0x26, 0xaf, 0x4b, 0x08, 0xf6, 0xd5, 0xbb, 0xa4, 0x78, 0x97, 0x7a, 0x5b, 0xbd, 0xcb, 0x0c,
	0x5c, 0x60, 0x0b, 0x80, 0x67, 0x04, 0x85, 0x7f, 0x34, 0x67, 0xdb, 0x74, 0x4b, 0xb6, 0x6d, 0x0d,
	0xfe, 0x4c, 0xff, 0x82, 0x7f, 0xbc, 0xcf, 0xc1, 0x9f, 0x3d, 0x9f, 0xe0, 0x9f, 0xe8, 0x73, 0xf0,
	0x4f, 0xf6, 0x18, 0xfc, 0x9f, 0x87, 0x29, 0x1e, 0xfc, 0x36, 0x76, 0x0c, 0x42, 0xa9, 0x17, 0x66,
	0xb9, 0x29, 0xb6, 0xac, 0x26, 0x59, 0x43, 0xa9, 0x4e, 0xef, 0x11, 0x29, 0x77, 0x8a, 0xe0, 0xfc,
	0xef, 0xc7, 0x60, 0xa9, 0xe3, 0x79, 0xfb, 0x15, 0x28, 0xe8, 0x22, 0x5d, 0xcc, 0xc2, 0x08, 0xbf,
	0x9d, 0x10, 0xd1, 0x2b, 0xbe, 0xda, 0x82, 0x05, 0x38, 0x3f, 0xb0, 0x90, 0x3e, 0x0f, 0xb0, 0xf0,
	0x2a, 0x5f, 0x7c, 0x56, 0xf9, 0xa2, 0x11, 0x2c, 0x4c, 0xf5, 0x08, 0x16, 0x7a, 0x4a, 0x24, 0x1d,
	0x53, 0x44, 0xfe, 0x47, 0x00, 0xcb, 0x09, 0xae, 0x53, 0xcf, 0xe7, 0xdd, 0xab, 0x5d, 0x6c, 0x75,
	0xf1, 0xfa, 0xd5, 0x6d, 0x6c, 0x75, 0xf1, 0x1a, 0x96, 0x3c, 0xb6, 0x46, 0xfa, 0x77, 0x94, 0x1e,
	0xed, 0xff, 0x6b, 0xdd, 0xd8, 0xf9, 0xbc, 0xd6, 0xa5, 0xce, 0xe7, 0xb5, 0x0e, 0xce, 0xf8, 0x5a,
	0x57, 0x06, 0xf9, 0x6d, 0xab, 0xe6, 0x54, 0x4f, 0x77, 0x4c, 0x17, 0x3b, 0x98, 0xba, 0x4a, 0xe3,
	0x51, 0xa9, 0xf3, 0x8a, 0x6a, 0xed, 0x2e, 0xbf, 0x0b, 0x33, 0x9c, 0xba, 0x5d, 0x33, 0xd9, 0x4d,
	0x31, 0x72, 0xf1, 0x06, 0xb2, 0x43, 0x49, 0xb5, 0xa3, 0xd8, 0x48, 0x01, 0xa1, 0xb7, 0xc5, 0xf1,
	0x1e, 0xdf, 0x16, 0x77, 0x03, 0xec, 0xcd, 0xae, 0x7e, 0xa9, 0xb8, 0xf1, 0x8b, 0x15, 0xc4, 0xb7,
	0x40, 0x16, 0xe6, 0xd4, 0x47, 0xe9, 0xfc, 0x2b, 0xf4, 0x54, 0x39, 0x91, 0xe0, 0xa9, 0x72, 0xb2,
	0x2f, 0x4f, 0x95, 0xbd, 0xa6, 0xc4, 0x77, 0x93, 0xa7, 0xc4, 0x1b, 0x41, 0x4a, 0x4c, 0x90, 0xec,
	0xf2, 0x7b, 0x90, 0x0a, 0x06, 0xac, 0x23, 0x76, 0x29, 0x8c, 0xd8, 0x23, 0x41, 0xe0, 0x60, 0x34,
	0x08, 0xcc, 0xff, 0x7c, 0x10, 0xe6, 0xe3, 0xef, 0x79, 0xcf, 0x27, 0xbf, 0xee, 0xc1, 0x64, 0xc3,
	0xb5, 0x34, 0xd1, 0xba, 0xaa, 0x2c, 0x98, 0xa0, 0x21, 0x3d, 0x89, 0x86, 0x57, 0x95, 0xe4, 0x06,
	0xbf, 0x16, 0x18, 0x3c, 0x7e, 0xe2, 0xf9, 0x7f, 0x4b, 0x70, 0x31, 0xe6, 0xae, 0xbf, 0x67, 0xc3,
	0x94, 0x20, 0xdb, 0xf8, 0x08, 0x21, 0x9e, 0x39, 0xdf, 0xec, 0x78, 0x15, 0xee, 0xab, 0xa0, 0x8c,
	0x37, 0x3c, 0x33, 0xac, 0xde, 0x4f, 0x3e, 0xfb, 0x37, 0x82, 0xd9, 0xc7, 0x4c, 0x2d, 0xff, 0xbb,
	0x31, 0xb8, 0x9a, 0xec, 0xd5, 0xe5, 0x55, 0xd9, 0xc9, 0xff, 0x5f, 0xd9, 0x49, 0xbb, 0xfb, 0x88,
	0x54, 0xf7, 0xf7, 0x11, 0xd0, 0xfe, 0x3e, 0x22, 0x2a, 0x45, 0xa4, 0x7b, 0x4f, 0x11, 0xf5, 0x6c,
	0x99, 0x09, 0x67, 0xcb, 0xb3, 0x6f, 0x73, 0x07, 0xd1, 0xdb, 0xdc, 0x17, 0x62, 0x1f, 0xc7, 0xc5,
	0x8d, 0xd2, 0x67, 0xbd, 0xdd, 0xad, 0x3e, 0x4c, 0x9e, 0x39, 0x8a, 0x71, 0x97, 0x00, 0x51, 0x7b,
	0xd5, 0x6f, 0x25, 0x98, 0x89, 0x9a, 0xa8, 0x77, 0xa0, 0x15, 0xb7, 0x71, 0x3c, 0x67, 0x88, 0x2f,
	0x79, 0x0e, 0xc6, 0x82, 0x0b, 0x38, 0x9e, 0x31, 0x82, 0xef, 0x76, 0x67, 0xef, 0xa1, 0x84, 0x67,
	0xef, 0xe1, 0xde, 0xce, 0xde, 0xf9, 0x3f, 0x48, 0x90, 0x69, 0xd0, 0xbd, 0xe9, 0x1e, 0x41, 0xea,
	0x78, 0x8f, 0x30, 0x98, 0xf8, 0x1e, 0xe1, 0xbc, 0xe7, 0xf2, 0xaf, 0x41, 0x58, 0x8e, 0x2c, 0x3a,
	0xe8, 0xd3, 0xdd, 0xcc, 0x43, 0x18, 0x0f, 0xea, 0x21, 0x18, 0x7a, 0x1a, 0x62, 0x81, 0xf0, 0xa5,
	0xae, 0x8b, 0x20, 0x18, 0x9a, 0xca, 0x68, 0xa1, 0x2f, 0xb9, 0x02, 0xaf, 0x05, 0xb2, 0x45, 0xed,
	0x85, 0x6d, 0x59, 0x41, 0x4d, 0x4e, 0x21, 0x6e, 0x0c, 0x5f, 0x2c, 0x1f, 0xa4, 0x64, 0x59, 0x55,
	0x65, 0x5a, 0x6b, 0xa1, 0xd1, 0xde, 0x40, 0x5b, 0x02, 0x83, 0xe6, 0xff, 0x33, 0xd4, 0xc6, 0xf0,
	0x7d, 0xda, 0x4a, 0xcf, 0xd3, 0xf0, 0x35, 0x58, 0x88, 0x34, 0xbc, 0x8a, 0x74, 0x9d, 0xb0, 0x04,
	0xd0, 0xa3, 0x0b, 0x2e, 0x45, 0xb8, 0x60, 0xcd, 0x97, 0x29, 0x3f, 0x86, 0xcb, 0xd1, 0xc3, 0xf2,
	0x7a, 0x0d, 0xbf, 0xfc, 0xa9, 0xdb, 0x41, 0xe7, 0x22, 0x06, 0xe5, 0x4e, 0xe8, 0xa7, 0xfb, 0x9b,
	0xf2, 0xe0, 0xb7, 0x25, 0x98, 0xf2, 0xc7, 0x23, 0xa6, 0xcb, 0x5b, 0xe5, 0x6b, 0x30, 0x81, 0x34,
	0x5e, 0x07, 0x82, 0x74, 0xdd, 0xc1, 0x94, 0x0a, 0xb7, 0x67, 0x05, 0x79, 0x8d, 0x53, 0xe5, 0x75,
	0x00, 0x13, 0x3f, 0x51, 0x6d, 0xaf, 0x2f, 0xed, 0xe6, 0xb2, 0x2c, 0x65, 0xe2, 0x27, 0x6c, 0x44,
	0x9a, 0xff, 0xf3, 0x20, 0xac, 0x34, 0xa8, 0x5a, 0xc2, 0xec, 0xb0, 0xc7, 0x9b, 0xfb, 0xb4, 0x0c,
	0xef, 0xc0, 0xac, 0xcd, 0xc5, 0x32, 0x5f, 0x85, 0x76, 0xf9, 0x21, 0xb6, 0xcb, 0xcf, 0xd8, 0xfe,
	0xa0, 0x56, 0xb5, 0xbe, 0xcd, 0xab, 0x30, 0x13, 0x38, 0x98, 0x98, 0x6e, 0xe0, 0x60, 0xbe, 0xaa,
	0x6e, 0xc6, 0x39, 0xb8, 0xc5, 0xa8, 0x8a, 0xec, 0x34, 0x93, 0xe8, 0xea, 0xfb, 0xc9, 0xfd, 0x7a,
	0x2b, 0xda, 0xaf, 0x31, 0xc6, 0xca, 0xbf, 0x94, 0x60, 0x3a, 0xa2, 0x36, 0xa7, 0x67, 0x23, 0x7e,
	0x1d, 0xc6, 0xa8, 0x76, 0x8c, 0xf5, 0x5a, 0x15, 0x8b, 0x30, 0x4e, 0x5a, 0x16, 0x54, 0x16, 0xdd,
	0x94, 0x40, 0xc0, 0xea, 0x5b, 0xc9, 0xa7, 0x7e, 0x29, 0x98, 0x7a, 0xc4, 0x6c, 0xf2, 0x1f, 0x0e,
	0xc2, 0x02, 0x2b, 0x92, 0xd9, 0xb0, 0x0c, 0xa3, 0x66, 0x12, 0xf7, 0xd4, 0x73, 0x62, 0xd9, 0x73,
	0xe8, 0x99, 0x67, 0x7c, 0x00, 0xa9, 0xe6, 0x82, 0xcf, 0xbb, 0xa2, 0x98, 0xbf, 0xd0, 0x50, 0xb7,
	0x5f, 0xd7, 0xba, 0x9d, 0x0e, 0x4a, 0x5d, 0xd2, 0x6a, 0x39, 0xf9, 0xdc, 0x57, 0x1a, 0x0b, 0x81,
	0xda, 0xcb, 0xcf, 0xff, 0x7a, 0x10, 0x0a, 0x6b, 0xae, 0x65, 0x10, 0x8d, 0xc3, 0x9e, 0xfb, 0x8e,
	0xce, 0x90, 0xfc, 0x6e, 0xad, 0xea, 0x12, 0xbb, 0x4a, 0xb0, 0xe3, 0x7b, 0xe1, 0xcc, 0x66, 0xc1,
	0x30, 0xeb, 0x97, 0x71, 0x61, 0xac, 0x1a, 0xc1, 0x00, 0xbe, 0x8d, 0x8a, 0x09, 0x4a, 0xb7, 0xc2,
	0x8a, 0x29, 0x33, 0x46, 0x2b, 0x91, 0xae, 0x56, 0x92, 0x9b, 0xe9, 0x6e, 0x60, 0xa6, 0xee, 0x4c,
	0x90, 0xff, 0xaf, 0x04, 0xb9, 0x76, 0xa5, 0x5c, 0x3d, 0xdb, 0xe7, 0x7d, 0x98, 0x6e, 0xad, 0x2e,
	0xf3, 0x8d, 0x73, 0xa3, 0x9b, 0xaa, 0x32, 0x65, 0xaa, 0xb9, 0x9a, 0xac, 0xc7, 0x22, 0x99, 0x76,
	0x73, 0xbc, 0xfe, 0x14, 0x32, 0xe1, 0xba, 0x6c, 0xf9, 0x36, 0xcc, 0x6c, 0xbd, 0xb7, 0xf1, 0xf6,
	0xda, 0xde, 0x5b, 0x5b, 0xea, 0xc1, 0x5e, 0xb9, 0xb4, 0xb5, 0xb1, 0xb3, 0xbd, 0xb3, 0xb5, 0x39,
	0x39, 0x30, 0x97, 0x7b, 0xf6, 0x7c, 0x31, 0xb2, 0x4d, 0x96, 0x61, 0xb8, 0x5c, 0xba, 0xbf, 0x3f,
	0x29, 0xcd, 0x8d, 0x3d, 0x7b, 0xbe, 0xc8, 0x7e, 0x7b, 0x56, 0xda, 0xdc, 0x52, 0x76, 0xde, 0x59,
	0xdb, 0xdf, 0x79, 0x67, 0xab, 0x3c, 0x39, 0x38, 0x37, 0xf1, 0xec, 0xf9, 0x62, 0x98, 0xb4, 0x7e,
	0xfc, 0xf1, 0x8b, 0x79, 0xe9, 0x93, 0x17, 0xf3, 0xd2, 0xdf, 0x5e, 0xcc, 0x4b, 0x3f, 0x78, 0x39,
	0x3f, 0xf0, 0xc9, 0xcb, 0xf9, 0x81, 0xbf, 0xbc, 0x9c, 0x1f, 0x78, 0xb8, 0x77, 0x44, 0xdc, 0xe3,
	0x5a, 0xa5, 0xa0, 0x59, 0x46, 0x71, 0xc7, 0x37, 0xd6, 0x3d, 0x54, 0xa1, 0xc5, 0xc0, 0x74, 0x37,
	0x35, 0xcb, 0xc1, 0xe1, 0xcf, 0x63, 0x44, 0xcc, 0xa2, 0x61, 0x79, 0xce, 0xa5, 0xf5, 0xe3, 0x80,
	0x07, 0x4a, 0x69, 0x65, 0x84, 0xfd, 0x9d, 0xca, 0x17, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xb0,
	0xf8, 0x37, 0x4a, 0xef, 0x33, 0x00, 0x00,
}

func (m *SpotMarketParamUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarketParamUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarketParamUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QuoteDecimals != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.QuoteDecimals))
		i--
		dAtA[i] = 0x70
	}
	if m.BaseDecimals != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.BaseDecimals))
		i--
		dAtA[i] = 0x68
	}
	if m.AdminInfo != nil {
		{
			size, err := m.AdminInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MinNotional != nil {
		{
			size := m.MinNotional.Size()
			i -= size
			if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x52
	}
	if m.Status != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.MinQuantityTickSize != nil {
		{
			size := m.MinQuantityTickSize.Size()
			i -= size
			if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.MinPriceTickSize != nil {
		{
			size := m.MinPriceTickSize.Size()
			i -= size
			if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RelayerFeeShareRate != nil {
		{
			size := m.RelayerFeeShareRate.Size()
			i -= size
			if _, err := m.RelayerFeeShareRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeEnableProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeEnableProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeEnableProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExchangeType != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.ExchangeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchExchangeModificationProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchExchangeModificationProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchExchangeModificationProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DenomMinNotionalProposal != nil {
		{
			size, err := m.DenomMinNotionalProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.MarketForcedSettlementProposals) > 0 {
		for iNdEx := len(m.MarketForcedSettlementProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MarketForcedSettlementProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.FeeDiscountProposal != nil {
		{
			size, err := m.FeeDiscountProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DenomDecimalsUpdateProposal != nil {
		{
			size, err := m.DenomDecimalsUpdateProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.BinaryOptionsParamUpdateProposals) > 0 {
		for iNdEx := len(m.BinaryOptionsParamUpdateProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsParamUpdateProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BinaryOptionsMarketLaunchProposals) > 0 {
		for iNdEx := len(m.BinaryOptionsMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.TradingRewardCampaignUpdateProposal != nil {
		{
			size, err := m.TradingRewardCampaignUpdateProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExpiryFuturesMarketLaunchProposals) > 0 {
		for iNdEx := len(m.ExpiryFuturesMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExpiryFuturesMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PerpetualMarketLaunchProposals) > 0 {
		for iNdEx := len(m.PerpetualMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PerpetualMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SpotMarketLaunchProposals) > 0 {
		for iNdEx := len(m.SpotMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DerivativeMarketParamUpdateProposals) > 0 {
		for iNdEx := len(m.DerivativeMarketParamUpdateProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeMarketParamUpdateProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SpotMarketParamUpdateProposals) > 0 {
		for iNdEx := len(m.SpotMarketParamUpdateProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotMarketParamUpdateProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QuoteDecimals != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.QuoteDecimals))
		i--
		dAtA[i] = 0x78
	}
	if m.BaseDecimals != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.BaseDecimals))
		i--
		dAtA[i] = 0x70
	}
	if m.AdminInfo != nil {
		{
			size, err := m.AdminInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PerpetualMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerpetualMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerpetualMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminInfo != nil {
		{
			size, err := m.AdminInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.OracleType != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOptionsMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOptionsMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOptionsMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminPermissions != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.AdminPermissions))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x52
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x48
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if m.OracleType != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OracleProvider) > 0 {
		i -= len(m.OracleProvider)
		copy(dAtA[i:], m.OracleProvider)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleProvider)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleSymbol) > 0 {
		i -= len(m.OracleSymbol)
		copy(dAtA[i:], m.OracleSymbol)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleSymbol)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExpiryFuturesMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpiryFuturesMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExpiryFuturesMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminInfo != nil {
		{
			size, err := m.AdminInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Expiry != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x48
	}
	if m.OracleType != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeMarketParamUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarketParamUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarketParamUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminInfo != nil {
		{
			size, err := m.AdminInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.MinNotional != nil {
		{
			size := m.MinNotional.Size()
			i -= size
			if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x7a
	}
	if m.OracleParams != nil {
		{
			size, err := m.OracleParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Status != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x68
	}
	if m.HourlyFundingRateCap != nil {
		{
			size := m.HourlyFundingRateCap.Size()
			i -= size
			if _, err := m.HourlyFundingRateCap.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.HourlyInterestRate != nil {
		{
			size := m.HourlyInterestRate.Size()
			i -= size
			if _, err := m.HourlyInterestRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MinQuantityTickSize != nil {
		{
			size := m.MinQuantityTickSize.Size()
			i -= size
			if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.MinPriceTickSize != nil {
		{
			size := m.MinPriceTickSize.Size()
			i -= size
			if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.RelayerFeeShareRate != nil {
		{
			size := m.RelayerFeeShareRate.Size()
			i -= size
			if _, err := m.RelayerFeeShareRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MaintenanceMarginRatio != nil {
		{
			size := m.MaintenanceMarginRatio.Size()
			i -= size
			if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.InitialMarginRatio != nil {
		{
			size := m.InitialMarginRatio.Size()
			i -= size
			if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdminInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminPermissions != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.AdminPermissions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketForcedSettlementProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketForcedSettlementProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketForcedSettlementProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SettlementPrice != nil {
		{
			size := m.SettlementPrice.Size()
			i -= size
			if _, err := m.SettlementPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDenomDecimalsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDenomDecimalsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDenomDecimalsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DenomDecimals) > 0 {
		for iNdEx := len(m.DenomDecimals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomDecimals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOptionsMarketParamUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOptionsMarketParamUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOptionsMarketParamUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinNotional != nil {
		{
			size := m.MinNotional.Size()
			i -= size
			if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x7a
	}
	if m.OracleParams != nil {
		{
			size, err := m.OracleParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Status != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x62
	}
	if m.SettlementPrice != nil {
		{
			size := m.SettlementPrice.Size()
			i -= size
			if _, err := m.SettlementPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x50
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x48
	}
	if m.MinQuantityTickSize != nil {
		{
			size := m.MinQuantityTickSize.Size()
			i -= size
			if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.MinPriceTickSize != nil {
		{
			size := m.MinPriceTickSize.Size()
			i -= size
			if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RelayerFeeShareRate != nil {
		{
			size := m.RelayerFeeShareRate.Size()
			i -= size
			if _, err := m.RelayerFeeShareRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderOracleParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderOracleParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderOracleParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OracleType != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x20
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OracleType != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x20
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingRewardCampaignLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingRewardCampaignLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingRewardCampaignLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CampaignRewardPools) > 0 {
		for iNdEx := len(m.CampaignRewardPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CampaignRewardPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CampaignInfo != nil {
		{
			size, err := m.CampaignInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingRewardCampaignUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingRewardCampaignUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingRewardCampaignUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CampaignRewardPoolsUpdates) > 0 {
		for iNdEx := len(m.CampaignRewardPoolsUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CampaignRewardPoolsUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CampaignRewardPoolsAdditions) > 0 {
		for iNdEx := len(m.CampaignRewardPoolsAdditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CampaignRewardPoolsAdditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CampaignInfo != nil {
		{
			size, err := m.CampaignInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardPointUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardPointUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardPointUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewPoints.Size()
		i -= size
		if _, err := m.NewPoints.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposal(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingRewardPendingPointsUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingRewardPendingPointsUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingRewardPendingPointsUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardPointUpdates) > 0 {
		for iNdEx := len(m.RewardPointUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardPointUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PendingPoolTimestamp != 0 {
		i = encodeVarintProposal(dAtA, i, uint64(m.PendingPoolTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeeDiscountProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeDiscountProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeDiscountProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchCommunityPoolSpendProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCommunityPoolSpendProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchCommunityPoolSpendProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proposals) > 0 {
		for iNdEx := len(m.Proposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Proposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketFeeMultipliers) > 0 {
		for iNdEx := len(m.MarketFeeMultipliers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MarketFeeMultipliers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomMinNotionalProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomMinNotionalProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomMinNotionalProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DenomMinNotionals) > 0 {
		for iNdEx := len(m.DenomMinNotionals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomMinNotionals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintProposal(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintProposal(dAtA []byte, offset int, v uint64) int {
	offset -= sovProposal(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpotMarketParamUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.RelayerFeeShareRate != nil {
		l = m.RelayerFeeShareRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinPriceTickSize != nil {
		l = m.MinPriceTickSize.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinQuantityTickSize != nil {
		l = m.MinQuantityTickSize.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovProposal(uint64(m.Status))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinNotional != nil {
		l = m.MinNotional.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.AdminInfo != nil {
		l = m.AdminInfo.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.BaseDecimals != 0 {
		n += 1 + sovProposal(uint64(m.BaseDecimals))
	}
	if m.QuoteDecimals != 0 {
		n += 1 + sovProposal(uint64(m.QuoteDecimals))
	}
	return n
}

func (m *ExchangeEnableProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.ExchangeType != 0 {
		n += 1 + sovProposal(uint64(m.ExchangeType))
	}
	return n
}

func (m *BatchExchangeModificationProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.SpotMarketParamUpdateProposals) > 0 {
		for _, e := range m.SpotMarketParamUpdateProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if len(m.DerivativeMarketParamUpdateProposals) > 0 {
		for _, e := range m.DerivativeMarketParamUpdateProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if len(m.SpotMarketLaunchProposals) > 0 {
		for _, e := range m.SpotMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if len(m.PerpetualMarketLaunchProposals) > 0 {
		for _, e := range m.PerpetualMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if len(m.ExpiryFuturesMarketLaunchProposals) > 0 {
		for _, e := range m.ExpiryFuturesMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if m.TradingRewardCampaignUpdateProposal != nil {
		l = m.TradingRewardCampaignUpdateProposal.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.BinaryOptionsMarketLaunchProposals) > 0 {
		for _, e := range m.BinaryOptionsMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if len(m.BinaryOptionsParamUpdateProposals) > 0 {
		for _, e := range m.BinaryOptionsParamUpdateProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if m.DenomDecimalsUpdateProposal != nil {
		l = m.DenomDecimalsUpdateProposal.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.FeeDiscountProposal != nil {
		l = m.FeeDiscountProposal.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.MarketForcedSettlementProposals) > 0 {
		for _, e := range m.MarketForcedSettlementProposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if m.DenomMinNotionalProposal != nil {
		l = m.DenomMinNotionalProposal.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	return n
}

func (m *SpotMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	l = m.MinNotional.Size()
	n += 1 + l + sovProposal(uint64(l))
	if m.AdminInfo != nil {
		l = m.AdminInfo.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.BaseDecimals != 0 {
		n += 1 + sovProposal(uint64(m.BaseDecimals))
	}
	if m.QuoteDecimals != 0 {
		n += 1 + sovProposal(uint64(m.QuoteDecimals))
	}
	return n
}

func (m *PerpetualMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovProposal(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovProposal(uint64(m.OracleType))
	}
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinNotional.Size()
	n += 1 + l + sovProposal(uint64(l))
	if m.AdminInfo != nil {
		l = m.AdminInfo.Size()
		n += 2 + l + sovProposal(uint64(l))
	}
	return n
}

func (m *BinaryOptionsMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.OracleSymbol)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.OracleProvider)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.OracleType != 0 {
		n += 1 + sovProposal(uint64(m.OracleType))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovProposal(uint64(m.OracleScaleFactor))
	}
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovProposal(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovProposal(uint64(m.SettlementTimestamp))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinNotional.Size()
	n += 2 + l + sovProposal(uint64(l))
	if m.AdminPermissions != 0 {
		n += 2 + sovProposal(uint64(m.AdminPermissions))
	}
	return n
}

func (m *ExpiryFuturesMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovProposal(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovProposal(uint64(m.OracleType))
	}
	if m.Expiry != 0 {
		n += 1 + sovProposal(uint64(m.Expiry))
	}
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovProposal(uint64(l))
	l = m.MinNotional.Size()
	n += 2 + l + sovProposal(uint64(l))
	if m.AdminInfo != nil {
		l = m.AdminInfo.Size()
		n += 2 + l + sovProposal(uint64(l))
	}
	return n
}

func (m *DerivativeMarketParamUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.InitialMarginRatio != nil {
		l = m.InitialMarginRatio.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MaintenanceMarginRatio != nil {
		l = m.MaintenanceMarginRatio.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.RelayerFeeShareRate != nil {
		l = m.RelayerFeeShareRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinPriceTickSize != nil {
		l = m.MinPriceTickSize.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinQuantityTickSize != nil {
		l = m.MinQuantityTickSize.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.HourlyInterestRate != nil {
		l = m.HourlyInterestRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.HourlyFundingRateCap != nil {
		l = m.HourlyFundingRateCap.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovProposal(uint64(m.Status))
	}
	if m.OracleParams != nil {
		l = m.OracleParams.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinNotional != nil {
		l = m.MinNotional.Size()
		n += 2 + l + sovProposal(uint64(l))
	}
	if m.AdminInfo != nil {
		l = m.AdminInfo.Size()
		n += 2 + l + sovProposal(uint64(l))
	}
	return n
}

func (m *AdminInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.AdminPermissions != 0 {
		n += 1 + sovProposal(uint64(m.AdminPermissions))
	}
	return n
}

func (m *MarketForcedSettlementProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.SettlementPrice != nil {
		l = m.SettlementPrice.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	return n
}

func (m *UpdateDenomDecimalsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.DenomDecimals) > 0 {
		for _, e := range m.DenomDecimals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	return n
}

func (m *BinaryOptionsMarketParamUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.RelayerFeeShareRate != nil {
		l = m.RelayerFeeShareRate.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinPriceTickSize != nil {
		l = m.MinPriceTickSize.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinQuantityTickSize != nil {
		l = m.MinQuantityTickSize.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovProposal(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovProposal(uint64(m.SettlementTimestamp))
	}
	if m.SettlementPrice != nil {
		l = m.SettlementPrice.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovProposal(uint64(m.Status))
	}
	if m.OracleParams != nil {
		l = m.OracleParams.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.MinNotional != nil {
		l = m.MinNotional.Size()
		n += 2 + l + sovProposal(uint64(l))
	}
	return n
}

func (m *ProviderOracleParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovProposal(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovProposal(uint64(m.OracleType))
	}
	return n
}

func (m *OracleParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovProposal(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovProposal(uint64(m.OracleType))
	}
	return n
}

func (m *TradingRewardCampaignLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.CampaignInfo != nil {
		l = m.CampaignInfo.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.CampaignRewardPools) > 0 {
		for _, e := range m.CampaignRewardPools {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	return n
}

func (m *TradingRewardCampaignUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.CampaignInfo != nil {
		l = m.CampaignInfo.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.CampaignRewardPoolsAdditions) > 0 {
		for _, e := range m.CampaignRewardPoolsAdditions {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	if len(m.CampaignRewardPoolsUpdates) > 0 {
		for _, e := range m.CampaignRewardPoolsUpdates {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	return n
}

func (m *RewardPointUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = m.NewPoints.Size()
	n += 1 + l + sovProposal(uint64(l))
	return n
}

func (m *TradingRewardPendingPointsUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.PendingPoolTimestamp != 0 {
		n += 1 + sovProposal(uint64(m.PendingPoolTimestamp))
	}
	if len(m.RewardPointUpdates) > 0 {
		for _, e := range m.RewardPointUpdates {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	return n
}

func (m *FeeDiscountProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovProposal(uint64(l))
	}
	return n
}

func (m *BatchCommunityPoolSpendProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.Proposals) > 0 {
		for _, e := range m.Proposals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	return n
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.MarketFeeMultipliers) > 0 {
		for _, e := range m.MarketFeeMultipliers {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	return n
}

func (m *DenomMinNotionalProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovProposal(uint64(l))
	}
	if len(m.DenomMinNotionals) > 0 {
		for _, e := range m.DenomMinNotionals {
			l = e.Size()
			n += 1 + l + sovProposal(uint64(l))
		}
	}
	return n
}

func sovProposal(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProposal(x uint64) (n int) {
	return sovProposal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpotMarketParamUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarketParamUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarketParamUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerFeeShareRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.RelayerFeeShareRate = &v
			if err := m.RelayerFeeShareRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinPriceTickSize = &v
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinQuantityTickSize = &v
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinNotional = &v
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminInfo == nil {
				m.AdminInfo = &AdminInfo{}
			}
			if err := m.AdminInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDecimals", wireType)
			}
			m.BaseDecimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseDecimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDecimals", wireType)
			}
			m.QuoteDecimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuoteDecimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeEnableProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeEnableProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeEnableProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeType", wireType)
			}
			m.ExchangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExchangeType |= ExchangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchExchangeModificationProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchExchangeModificationProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchExchangeModificationProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotMarketParamUpdateProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotMarketParamUpdateProposals = append(m.SpotMarketParamUpdateProposals, &SpotMarketParamUpdateProposal{})
			if err := m.SpotMarketParamUpdateProposals[len(m.SpotMarketParamUpdateProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeMarketParamUpdateProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeMarketParamUpdateProposals = append(m.DerivativeMarketParamUpdateProposals, &DerivativeMarketParamUpdateProposal{})
			if err := m.DerivativeMarketParamUpdateProposals[len(m.DerivativeMarketParamUpdateProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotMarketLaunchProposals = append(m.SpotMarketLaunchProposals, &SpotMarketLaunchProposal{})
			if err := m.SpotMarketLaunchProposals[len(m.SpotMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerpetualMarketLaunchProposals = append(m.PerpetualMarketLaunchProposals, &PerpetualMarketLaunchProposal{})
			if err := m.PerpetualMarketLaunchProposals[len(m.PerpetualMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryFuturesMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpiryFuturesMarketLaunchProposals = append(m.ExpiryFuturesMarketLaunchProposals, &ExpiryFuturesMarketLaunchProposal{})
			if err := m.ExpiryFuturesMarketLaunchProposals[len(m.ExpiryFuturesMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingRewardCampaignUpdateProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingRewardCampaignUpdateProposal == nil {
				m.TradingRewardCampaignUpdateProposal = &TradingRewardCampaignUpdateProposal{}
			}
			if err := m.TradingRewardCampaignUpdateProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsMarketLaunchProposals = append(m.BinaryOptionsMarketLaunchProposals, &BinaryOptionsMarketLaunchProposal{})
			if err := m.BinaryOptionsMarketLaunchProposals[len(m.BinaryOptionsMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsParamUpdateProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsParamUpdateProposals = append(m.BinaryOptionsParamUpdateProposals, &BinaryOptionsMarketParamUpdateProposal{})
			if err := m.BinaryOptionsParamUpdateProposals[len(m.BinaryOptionsParamUpdateProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomDecimalsUpdateProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomDecimalsUpdateProposal == nil {
				m.DenomDecimalsUpdateProposal = &UpdateDenomDecimalsProposal{}
			}
			if err := m.DenomDecimalsUpdateProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeDiscountProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeDiscountProposal == nil {
				m.FeeDiscountProposal = &FeeDiscountProposal{}
			}
			if err := m.FeeDiscountProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketForcedSettlementProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketForcedSettlementProposals = append(m.MarketForcedSettlementProposals, &MarketForcedSettlementProposal{})
			if err := m.MarketForcedSettlementProposals[len(m.MarketForcedSettlementProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomMinNotionalProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomMinNotionalProposal == nil {
				m.DenomMinNotionalProposal = &DenomMinNotionalProposal{}
			}
			if err := m.DenomMinNotionalProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminInfo == nil {
				m.AdminInfo = &AdminInfo{}
			}
			if err := m.AdminInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDecimals", wireType)
			}
			m.BaseDecimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseDecimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDecimals", wireType)
			}
			m.QuoteDecimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuoteDecimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerpetualMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerpetualMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerpetualMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminInfo == nil {
				m.AdminInfo = &AdminInfo{}
			}
			if err := m.AdminInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOptionsMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOptionsMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOptionsMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPermissions", wireType)
			}
			m.AdminPermissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminPermissions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpiryFuturesMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpiryFuturesMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpiryFuturesMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminInfo == nil {
				m.AdminInfo = &AdminInfo{}
			}
			if err := m.AdminInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeMarketParamUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarketParamUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarketParamUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.InitialMarginRatio = &v
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MaintenanceMarginRatio = &v
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerFeeShareRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.RelayerFeeShareRate = &v
			if err := m.RelayerFeeShareRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinPriceTickSize = &v
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinQuantityTickSize = &v
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyInterestRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.HourlyInterestRate = &v
			if err := m.HourlyInterestRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyFundingRateCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.HourlyFundingRateCap = &v
			if err := m.HourlyFundingRateCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleParams == nil {
				m.OracleParams = &OracleParams{}
			}
			if err := m.OracleParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinNotional = &v
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminInfo == nil {
				m.AdminInfo = &AdminInfo{}
			}
			if err := m.AdminInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPermissions", wireType)
			}
			m.AdminPermissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminPermissions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketForcedSettlementProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketForcedSettlementProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketForcedSettlementProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.SettlementPrice = &v
			if err := m.SettlementPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDenomDecimalsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDenomDecimalsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDenomDecimalsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomDecimals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomDecimals = append(m.DenomDecimals, &DenomDecimals{})
			if err := m.DenomDecimals[len(m.DenomDecimals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOptionsMarketParamUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOptionsMarketParamUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOptionsMarketParamUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerFeeShareRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.RelayerFeeShareRate = &v
			if err := m.RelayerFeeShareRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinPriceTickSize = &v
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinQuantityTickSize = &v
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.SettlementPrice = &v
			if err := m.SettlementPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleParams == nil {
				m.OracleParams = &ProviderOracleParams{}
			}
			if err := m.OracleParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.MinNotional = &v
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderOracleParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderOracleParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderOracleParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingRewardCampaignLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingRewardCampaignLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingRewardCampaignLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CampaignInfo == nil {
				m.CampaignInfo = &TradingRewardCampaignInfo{}
			}
			if err := m.CampaignInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignRewardPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignRewardPools = append(m.CampaignRewardPools, &CampaignRewardPool{})
			if err := m.CampaignRewardPools[len(m.CampaignRewardPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingRewardCampaignUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingRewardCampaignUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingRewardCampaignUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CampaignInfo == nil {
				m.CampaignInfo = &TradingRewardCampaignInfo{}
			}
			if err := m.CampaignInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignRewardPoolsAdditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignRewardPoolsAdditions = append(m.CampaignRewardPoolsAdditions, &CampaignRewardPool{})
			if err := m.CampaignRewardPoolsAdditions[len(m.CampaignRewardPoolsAdditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignRewardPoolsUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignRewardPoolsUpdates = append(m.CampaignRewardPoolsUpdates, &CampaignRewardPool{})
			if err := m.CampaignRewardPoolsUpdates[len(m.CampaignRewardPoolsUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardPointUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardPointUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardPointUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewPoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingRewardPendingPointsUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingRewardPendingPointsUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingRewardPendingPointsUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPoolTimestamp", wireType)
			}
			m.PendingPoolTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingPoolTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPointUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardPointUpdates = append(m.RewardPointUpdates, &RewardPointUpdate{})
			if err := m.RewardPointUpdates[len(m.RewardPointUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeDiscountProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeDiscountProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeDiscountProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &FeeDiscountSchedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCommunityPoolSpendProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCommunityPoolSpendProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCommunityPoolSpendProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposals = append(m.Proposals, &types1.CommunityPoolSpendProposal{})
			if err := m.Proposals[len(m.Proposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicMarketOrderFeeMultiplierScheduleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicMarketOrderFeeMultiplierScheduleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketFeeMultipliers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketFeeMultipliers = append(m.MarketFeeMultipliers, &MarketFeeMultiplier{})
			if err := m.MarketFeeMultipliers[len(m.MarketFeeMultipliers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomMinNotionalProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomMinNotionalProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomMinNotionalProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomMinNotionals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomMinNotionals = append(m.DenomMinNotionals, &DenomMinNotional{})
			if err := m.DenomMinNotionals[len(m.DenomMinNotionals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProposal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProposal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProposal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProposal
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProposal
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProposal
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProposal        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProposal          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProposal = fmt.Errorf("proto: unexpected end of group")
)
