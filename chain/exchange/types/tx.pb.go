// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/exchange/v1beta1/tx.proto

package types

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	types1 "github.com/InjectiveLabs/sdk-go/chain/oracle/types"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/cosmos-sdk/x/distribution/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgUpdateSpotMarket struct {
	// current admin address of the associated market
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// id of the market to be updated
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// (optional) updated ticker value
	NewTicker string `protobuf:"bytes,3,opt,name=new_ticker,json=newTicker,proto3" json:"new_ticker,omitempty"`
	// (optional) updated min price tick size value
	NewMinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=new_min_price_tick_size,json=newMinPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_min_price_tick_size"`
	// (optional) updated min quantity tick size value
	NewMinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=new_min_quantity_tick_size,json=newMinQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_min_quantity_tick_size"`
	// (optional) updated min notional
	NewMinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=new_min_notional,json=newMinNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_min_notional"`
}

func (m *MsgUpdateSpotMarket) Reset()         { *m = MsgUpdateSpotMarket{} }
func (m *MsgUpdateSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSpotMarket) ProtoMessage()    {}
func (*MsgUpdateSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{0}
}
func (m *MsgUpdateSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSpotMarket.Merge(m, src)
}
func (m *MsgUpdateSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSpotMarket proto.InternalMessageInfo

type MsgUpdateSpotMarketResponse struct {
}

func (m *MsgUpdateSpotMarketResponse) Reset()         { *m = MsgUpdateSpotMarketResponse{} }
func (m *MsgUpdateSpotMarketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSpotMarketResponse) ProtoMessage()    {}
func (*MsgUpdateSpotMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{1}
}
func (m *MsgUpdateSpotMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSpotMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSpotMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSpotMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSpotMarketResponse.Merge(m, src)
}
func (m *MsgUpdateSpotMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSpotMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSpotMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSpotMarketResponse proto.InternalMessageInfo

type MsgUpdateDerivativeMarket struct {
	// current admin address of the associated market
	Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`
	// id of the market to be updated
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// (optional) updated value for ticker
	NewTicker string `protobuf:"bytes,3,opt,name=new_ticker,json=newTicker,proto3" json:"new_ticker,omitempty"`
	// (optional) updated value for min_price_tick_size
	NewMinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=new_min_price_tick_size,json=newMinPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_min_price_tick_size"`
	// (optional) updated value min_quantity_tick_size
	NewMinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=new_min_quantity_tick_size,json=newMinQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_min_quantity_tick_size"`
	// (optional) updated min notional
	NewMinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=new_min_notional,json=newMinNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_min_notional"`
	// (optional) updated value for initial_margin_ratio
	NewInitialMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=new_initial_margin_ratio,json=newInitialMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_initial_margin_ratio"`
	// (optional) updated value for maintenance_margin_ratio
	NewMaintenanceMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=new_maintenance_margin_ratio,json=newMaintenanceMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_maintenance_margin_ratio"`
}

func (m *MsgUpdateDerivativeMarket) Reset()         { *m = MsgUpdateDerivativeMarket{} }
func (m *MsgUpdateDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDerivativeMarket) ProtoMessage()    {}
func (*MsgUpdateDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{2}
}
func (m *MsgUpdateDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDerivativeMarket.Merge(m, src)
}
func (m *MsgUpdateDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDerivativeMarket proto.InternalMessageInfo

type MsgUpdateDerivativeMarketResponse struct {
}

func (m *MsgUpdateDerivativeMarketResponse) Reset()         { *m = MsgUpdateDerivativeMarketResponse{} }
func (m *MsgUpdateDerivativeMarketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDerivativeMarketResponse) ProtoMessage()    {}
func (*MsgUpdateDerivativeMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{3}
}
func (m *MsgUpdateDerivativeMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDerivativeMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDerivativeMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDerivativeMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDerivativeMarketResponse.Merge(m, src)
}
func (m *MsgUpdateDerivativeMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDerivativeMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDerivativeMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDerivativeMarketResponse proto.InternalMessageInfo

type MsgUpdateParams struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the exchange parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{4}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{5}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgDeposit defines a SDK message for transferring coins from the sender's
// bank balance into the subaccount's exchange deposits
type MsgDeposit struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin
	// will be deposited to the sender's default subaccount address.
	SubaccountId string     `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Amount       types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgDeposit) Reset()         { *m = MsgDeposit{} }
func (m *MsgDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgDeposit) ProtoMessage()    {}
func (*MsgDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{6}
}
func (m *MsgDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeposit.Merge(m, src)
}
func (m *MsgDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeposit proto.InternalMessageInfo

// MsgDepositResponse defines the Msg/Deposit response type.
type MsgDepositResponse struct {
}

func (m *MsgDepositResponse) Reset()         { *m = MsgDepositResponse{} }
func (m *MsgDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositResponse) ProtoMessage()    {}
func (*MsgDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{7}
}
func (m *MsgDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositResponse.Merge(m, src)
}
func (m *MsgDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositResponse proto.InternalMessageInfo

// MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's
// deposits to the user's bank balance
type MsgWithdraw struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// bytes32 subaccount ID to withdraw funds from
	SubaccountId string     `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Amount       types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgWithdraw) Reset()         { *m = MsgWithdraw{} }
func (m *MsgWithdraw) String() string { return proto.CompactTextString(m) }
func (*MsgWithdraw) ProtoMessage()    {}
func (*MsgWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{8}
}
func (m *MsgWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdraw.Merge(m, src)
}
func (m *MsgWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdraw proto.InternalMessageInfo

// MsgWithdraw defines the Msg/Withdraw response type.
type MsgWithdrawResponse struct {
}

func (m *MsgWithdrawResponse) Reset()         { *m = MsgWithdrawResponse{} }
func (m *MsgWithdrawResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawResponse) ProtoMessage()    {}
func (*MsgWithdrawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{9}
}
func (m *MsgWithdrawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawResponse.Merge(m, src)
}
func (m *MsgWithdrawResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawResponse proto.InternalMessageInfo

// MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit
// order.
type MsgCreateSpotLimitOrder struct {
	Sender string    `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  SpotOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateSpotLimitOrder) Reset()         { *m = MsgCreateSpotLimitOrder{} }
func (m *MsgCreateSpotLimitOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotLimitOrder) ProtoMessage()    {}
func (*MsgCreateSpotLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{10}
}
func (m *MsgCreateSpotLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotLimitOrder.Merge(m, src)
}
func (m *MsgCreateSpotLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotLimitOrder proto.InternalMessageInfo

// MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response
// type.
type MsgCreateSpotLimitOrderResponse struct {
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Cid       string `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCreateSpotLimitOrderResponse) Reset()         { *m = MsgCreateSpotLimitOrderResponse{} }
func (m *MsgCreateSpotLimitOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotLimitOrderResponse) ProtoMessage()    {}
func (*MsgCreateSpotLimitOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{11}
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotLimitOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotLimitOrderResponse.Merge(m, src)
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotLimitOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotLimitOrderResponse proto.InternalMessageInfo

// MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new batch
// of spot limit orders.
type MsgBatchCreateSpotLimitOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Orders []SpotOrder `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders"`
}

func (m *MsgBatchCreateSpotLimitOrders) Reset()         { *m = MsgBatchCreateSpotLimitOrders{} }
func (m *MsgBatchCreateSpotLimitOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCreateSpotLimitOrders) ProtoMessage()    {}
func (*MsgBatchCreateSpotLimitOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{12}
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateSpotLimitOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrders.Merge(m, src)
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateSpotLimitOrders proto.InternalMessageInfo

// MsgBatchCreateSpotLimitOrdersResponse defines the
// Msg/BatchCreateSpotLimitOrders response type.
type MsgBatchCreateSpotLimitOrdersResponse struct {
	OrderHashes       []string `protobuf:"bytes,1,rep,name=order_hashes,json=orderHashes,proto3" json:"order_hashes,omitempty"`
	CreatedOrdersCids []string `protobuf:"bytes,2,rep,name=created_orders_cids,json=createdOrdersCids,proto3" json:"created_orders_cids,omitempty"`
	FailedOrdersCids  []string `protobuf:"bytes,3,rep,name=failed_orders_cids,json=failedOrdersCids,proto3" json:"failed_orders_cids,omitempty"`
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) Reset()         { *m = MsgBatchCreateSpotLimitOrdersResponse{} }
func (m *MsgBatchCreateSpotLimitOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCreateSpotLimitOrdersResponse) ProtoMessage()    {}
func (*MsgBatchCreateSpotLimitOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{13}
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse proto.InternalMessageInfo

// MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot
// market by paying listing fee without governance
type MsgInstantSpotMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the spot market.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	BaseDenom string `protobuf:"bytes,3,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,4,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
}

func (m *MsgInstantSpotMarketLaunch) Reset()         { *m = MsgInstantSpotMarketLaunch{} }
func (m *MsgInstantSpotMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantSpotMarketLaunch) ProtoMessage()    {}
func (*MsgInstantSpotMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{14}
}
func (m *MsgInstantSpotMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantSpotMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantSpotMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantSpotMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantSpotMarketLaunch.Merge(m, src)
}
func (m *MsgInstantSpotMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantSpotMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantSpotMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantSpotMarketLaunch proto.InternalMessageInfo

// MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch
// response type.
type MsgInstantSpotMarketLaunchResponse struct {
}

func (m *MsgInstantSpotMarketLaunchResponse) Reset()         { *m = MsgInstantSpotMarketLaunchResponse{} }
func (m *MsgInstantSpotMarketLaunchResponse) String() string { return proto.CompactTextString(m) }
func (*MsgInstantSpotMarketLaunchResponse) ProtoMessage()    {}
func (*MsgInstantSpotMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{15}
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantSpotMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantSpotMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantSpotMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantSpotMarketLaunchResponse proto.InternalMessageInfo

// MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new
// perpetual futures market by paying listing fee without governance
type MsgInstantPerpetualMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,4,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,5,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,6,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,7,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the perpetual
	// market
	MakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate"`
	// taker_fee_rate defines the trade fee rate for takers on the perpetual
	// market
	TakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate"`
	// initial_margin_ratio defines the initial margin ratio for the perpetual
	// market
	InitialMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the
	// perpetual market
	MaintenanceMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maintenance_margin_ratio"`
	// min_price_tick_size defines the minimum tick size of the order's price and
	// margin
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
}

func (m *MsgInstantPerpetualMarketLaunch) Reset()         { *m = MsgInstantPerpetualMarketLaunch{} }
func (m *MsgInstantPerpetualMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantPerpetualMarketLaunch) ProtoMessage()    {}
func (*MsgInstantPerpetualMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{16}
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantPerpetualMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunch.Merge(m, src)
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantPerpetualMarketLaunch proto.InternalMessageInfo

// MsgInstantPerpetualMarketLaunchResponse defines the
// Msg/InstantPerpetualMarketLaunchResponse response type.
type MsgInstantPerpetualMarketLaunchResponse struct {
}

func (m *MsgInstantPerpetualMarketLaunchResponse) Reset() {
	*m = MsgInstantPerpetualMarketLaunchResponse{}
}
func (m *MsgInstantPerpetualMarketLaunchResponse) String() string { return proto.CompactTextString(m) }
func (*MsgInstantPerpetualMarketLaunchResponse) ProtoMessage()    {}
func (*MsgInstantPerpetualMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{17}
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse proto.InternalMessageInfo

// MsgInstantBinaryOptionsMarketLaunch defines a SDK message for creating a new
// perpetual futures market by paying listing fee without governance
type MsgInstantBinaryOptionsMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle symbol
	OracleSymbol string `protobuf:"bytes,3,opt,name=oracle_symbol,json=oracleSymbol,proto3" json:"oracle_symbol,omitempty"`
	// Oracle Provider
	OracleProvider string `protobuf:"bytes,4,opt,name=oracle_provider,json=oracleProvider,proto3" json:"oracle_provider,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,5,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,6,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the perpetual
	// market
	MakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate"`
	// taker_fee_rate defines the trade fee rate for takers on the perpetual
	// market
	TakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,9,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,10,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// admin of the market
	Admin string `protobuf:"bytes,11,opt,name=admin,proto3" json:"admin,omitempty"`
	// Address of the quote currency denomination for the binary options contract
	QuoteDenom string `protobuf:"bytes,12,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price and margin
	// required for orders in the market
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,15,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
}

func (m *MsgInstantBinaryOptionsMarketLaunch) Reset()         { *m = MsgInstantBinaryOptionsMarketLaunch{} }
func (m *MsgInstantBinaryOptionsMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantBinaryOptionsMarketLaunch) ProtoMessage()    {}
func (*MsgInstantBinaryOptionsMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{18}
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch.Merge(m, src)
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch proto.InternalMessageInfo

// MsgInstantBinaryOptionsMarketLaunchResponse defines the
// Msg/InstantBinaryOptionsMarketLaunchResponse response type.
type MsgInstantBinaryOptionsMarketLaunchResponse struct {
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Reset() {
	*m = MsgInstantBinaryOptionsMarketLaunchResponse{}
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgInstantBinaryOptionsMarketLaunchResponse) ProtoMessage() {}
func (*MsgInstantBinaryOptionsMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{19}
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse proto.InternalMessageInfo

// MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a new
// expiry futures market by paying listing fee without governance
type MsgInstantExpiryFuturesMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,4,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,5,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,6,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Expiration time of the market
	Expiry int64 `protobuf:"varint,8,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the expiry futures
	// market
	MakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maker_fee_rate"`
	// taker_fee_rate defines the trade fee rate for takers on the expiry futures
	// market
	TakerFeeRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"taker_fee_rate"`
	// initial_margin_ratio defines the initial margin ratio for the derivative
	// market
	InitialMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,11,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the
	// derivative market
	MaintenanceMarginRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,12,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"maintenance_margin_ratio"`
	// min_price_tick_size defines the minimum tick size of the order's price and
	// margin
	MinPriceTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,13,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's
	// quantity
	MinQuantityTickSize cosmossdk_io_math.LegacyDec `protobuf:"bytes,14,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_quantity_tick_size"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional cosmossdk_io_math.LegacyDec `protobuf:"bytes,15,opt,name=min_notional,json=minNotional,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_notional"`
}

func (m *MsgInstantExpiryFuturesMarketLaunch) Reset()         { *m = MsgInstantExpiryFuturesMarketLaunch{} }
func (m *MsgInstantExpiryFuturesMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantExpiryFuturesMarketLaunch) ProtoMessage()    {}
func (*MsgInstantExpiryFuturesMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{20}
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch.Merge(m, src)
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch proto.InternalMessageInfo

// MsgInstantExpiryFuturesMarketLaunchResponse defines the
// Msg/InstantExpiryFuturesMarketLaunch response type.
type MsgInstantExpiryFuturesMarketLaunchResponse struct {
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Reset() {
	*m = MsgInstantExpiryFuturesMarketLaunchResponse{}
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgInstantExpiryFuturesMarketLaunchResponse) ProtoMessage() {}
func (*MsgInstantExpiryFuturesMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{21}
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse proto.InternalMessageInfo

// MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market
// order.
type MsgCreateSpotMarketOrder struct {
	Sender string    `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  SpotOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateSpotMarketOrder) Reset()         { *m = MsgCreateSpotMarketOrder{} }
func (m *MsgCreateSpotMarketOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotMarketOrder) ProtoMessage()    {}
func (*MsgCreateSpotMarketOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{22}
}
func (m *MsgCreateSpotMarketOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotMarketOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotMarketOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotMarketOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotMarketOrder.Merge(m, src)
}
func (m *MsgCreateSpotMarketOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotMarketOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotMarketOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotMarketOrder proto.InternalMessageInfo

// MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder
// response type.
type MsgCreateSpotMarketOrderResponse struct {
	OrderHash string                  `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Results   *SpotMarketOrderResults `protobuf:"bytes,2,opt,name=results,proto3" json:"results,omitempty"`
	Cid       string                  `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCreateSpotMarketOrderResponse) Reset()         { *m = MsgCreateSpotMarketOrderResponse{} }
func (m *MsgCreateSpotMarketOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotMarketOrderResponse) ProtoMessage()    {}
func (*MsgCreateSpotMarketOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{23}
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotMarketOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotMarketOrderResponse.Merge(m, src)
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotMarketOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotMarketOrderResponse proto.InternalMessageInfo

type SpotMarketOrderResults struct {
	Quantity cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=quantity,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"quantity"`
	Price    cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	Fee      cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=fee,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"fee"`
}

func (m *SpotMarketOrderResults) Reset()         { *m = SpotMarketOrderResults{} }
func (m *SpotMarketOrderResults) String() string { return proto.CompactTextString(m) }
func (*SpotMarketOrderResults) ProtoMessage()    {}
func (*SpotMarketOrderResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{24}
}
func (m *SpotMarketOrderResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarketOrderResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarketOrderResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarketOrderResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarketOrderResults.Merge(m, src)
}
func (m *SpotMarketOrderResults) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarketOrderResults) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarketOrderResults.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarketOrderResults proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateDerivativeLimitOrder
type MsgCreateDerivativeLimitOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateDerivativeLimitOrder) Reset()         { *m = MsgCreateDerivativeLimitOrder{} }
func (m *MsgCreateDerivativeLimitOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeLimitOrder) ProtoMessage()    {}
func (*MsgCreateDerivativeLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{25}
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeLimitOrder.Merge(m, src)
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeLimitOrder proto.InternalMessageInfo

// MsgCreateDerivativeLimitOrderResponse defines the
// Msg/CreateDerivativeMarketOrder response type.
type MsgCreateDerivativeLimitOrderResponse struct {
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Cid       string `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCreateDerivativeLimitOrderResponse) Reset()         { *m = MsgCreateDerivativeLimitOrderResponse{} }
func (m *MsgCreateDerivativeLimitOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeLimitOrderResponse) ProtoMessage()    {}
func (*MsgCreateDerivativeLimitOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{26}
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse.Merge(m, src)
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateBinaryOptionsLimitOrder
type MsgCreateBinaryOptionsLimitOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateBinaryOptionsLimitOrder) Reset()         { *m = MsgCreateBinaryOptionsLimitOrder{} }
func (m *MsgCreateBinaryOptionsLimitOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBinaryOptionsLimitOrder) ProtoMessage()    {}
func (*MsgCreateBinaryOptionsLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{27}
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder proto.InternalMessageInfo

// MsgCreateBinaryOptionsLimitOrderResponse defines the
// Msg/CreateBinaryOptionsLimitOrder response type.
type MsgCreateBinaryOptionsLimitOrderResponse struct {
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Cid       string `protobuf:"bytes,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) Reset() {
	*m = MsgCreateBinaryOptionsLimitOrderResponse{}
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBinaryOptionsLimitOrderResponse) ProtoMessage()    {}
func (*MsgCreateBinaryOptionsLimitOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{28}
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders
type MsgBatchCreateDerivativeLimitOrders struct {
	Sender string            `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Orders []DerivativeOrder `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders"`
}

func (m *MsgBatchCreateDerivativeLimitOrders) Reset()         { *m = MsgBatchCreateDerivativeLimitOrders{} }
func (m *MsgBatchCreateDerivativeLimitOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCreateDerivativeLimitOrders) ProtoMessage()    {}
func (*MsgBatchCreateDerivativeLimitOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{29}
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders.Merge(m, src)
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders proto.InternalMessageInfo

// MsgBatchCreateDerivativeLimitOrdersResponse defines the
// Msg/BatchCreateDerivativeLimitOrders response type.
type MsgBatchCreateDerivativeLimitOrdersResponse struct {
	OrderHashes       []string `protobuf:"bytes,1,rep,name=order_hashes,json=orderHashes,proto3" json:"order_hashes,omitempty"`
	CreatedOrdersCids []string `protobuf:"bytes,2,rep,name=created_orders_cids,json=createdOrdersCids,proto3" json:"created_orders_cids,omitempty"`
	FailedOrdersCids  []string `protobuf:"bytes,3,rep,name=failed_orders_cids,json=failedOrdersCids,proto3" json:"failed_orders_cids,omitempty"`
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Reset() {
	*m = MsgBatchCreateDerivativeLimitOrdersResponse{}
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgBatchCreateDerivativeLimitOrdersResponse) ProtoMessage() {}
func (*MsgBatchCreateDerivativeLimitOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{30}
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse proto.InternalMessageInfo

// MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type.
type MsgCancelSpotOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId     string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Cid          string `protobuf:"bytes,5,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCancelSpotOrder) Reset()         { *m = MsgCancelSpotOrder{} }
func (m *MsgCancelSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelSpotOrder) ProtoMessage()    {}
func (*MsgCancelSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{31}
}
func (m *MsgCancelSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelSpotOrder.Merge(m, src)
}
func (m *MsgCancelSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelSpotOrder proto.InternalMessageInfo

// MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type.
type MsgCancelSpotOrderResponse struct {
}

func (m *MsgCancelSpotOrderResponse) Reset()         { *m = MsgCancelSpotOrderResponse{} }
func (m *MsgCancelSpotOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelSpotOrderResponse) ProtoMessage()    {}
func (*MsgCancelSpotOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{32}
}
func (m *MsgCancelSpotOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelSpotOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelSpotOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelSpotOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelSpotOrderResponse.Merge(m, src)
}
func (m *MsgCancelSpotOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelSpotOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelSpotOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelSpotOrderResponse proto.InternalMessageInfo

// MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type.
type MsgBatchCancelSpotOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Data   []OrderData `protobuf:"bytes,2,rep,name=data,proto3" json:"data"`
}

func (m *MsgBatchCancelSpotOrders) Reset()         { *m = MsgBatchCancelSpotOrders{} }
func (m *MsgBatchCancelSpotOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelSpotOrders) ProtoMessage()    {}
func (*MsgBatchCancelSpotOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{33}
}
func (m *MsgBatchCancelSpotOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelSpotOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelSpotOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelSpotOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelSpotOrders.Merge(m, src)
}
func (m *MsgBatchCancelSpotOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelSpotOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelSpotOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelSpotOrders proto.InternalMessageInfo

// MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders
// response type.
type MsgBatchCancelSpotOrdersResponse struct {
	Success []bool `protobuf:"varint,1,rep,packed,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgBatchCancelSpotOrdersResponse) Reset()         { *m = MsgBatchCancelSpotOrdersResponse{} }
func (m *MsgBatchCancelSpotOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelSpotOrdersResponse) ProtoMessage()    {}
func (*MsgBatchCancelSpotOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{34}
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelSpotOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelSpotOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelSpotOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelSpotOrdersResponse proto.InternalMessageInfo

// MsgBatchCancelBinaryOptionsOrders defines the
// Msg/BatchCancelBinaryOptionsOrders response type.
type MsgBatchCancelBinaryOptionsOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Data   []OrderData `protobuf:"bytes,2,rep,name=data,proto3" json:"data"`
}

func (m *MsgBatchCancelBinaryOptionsOrders) Reset()         { *m = MsgBatchCancelBinaryOptionsOrders{} }
func (m *MsgBatchCancelBinaryOptionsOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelBinaryOptionsOrders) ProtoMessage()    {}
func (*MsgBatchCancelBinaryOptionsOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{35}
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders.Merge(m, src)
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders proto.InternalMessageInfo

// BatchCancelBinaryOptionsOrdersResponse defines the
// Msg/BatchCancelBinaryOptionsOrders response type.
type MsgBatchCancelBinaryOptionsOrdersResponse struct {
	Success []bool `protobuf:"varint,1,rep,packed,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Reset() {
	*m = MsgBatchCancelBinaryOptionsOrdersResponse{}
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgBatchCancelBinaryOptionsOrdersResponse) ProtoMessage() {}
func (*MsgBatchCancelBinaryOptionsOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{36}
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse proto.InternalMessageInfo

// MsgBatchUpdateOrders defines the Msg/BatchUpdateOrders response type.
type MsgBatchUpdateOrders struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// subaccount_id only used for the spot_market_ids_to_cancel_all and
	// derivative_market_ids_to_cancel_all.
	SubaccountId                      string             `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	SpotMarketIdsToCancelAll          []string           `protobuf:"bytes,3,rep,name=spot_market_ids_to_cancel_all,json=spotMarketIdsToCancelAll,proto3" json:"spot_market_ids_to_cancel_all,omitempty"`
	DerivativeMarketIdsToCancelAll    []string           `protobuf:"bytes,4,rep,name=derivative_market_ids_to_cancel_all,json=derivativeMarketIdsToCancelAll,proto3" json:"derivative_market_ids_to_cancel_all,omitempty"`
	SpotOrdersToCancel                []*OrderData       `protobuf:"bytes,5,rep,name=spot_orders_to_cancel,json=spotOrdersToCancel,proto3" json:"spot_orders_to_cancel,omitempty"`
	DerivativeOrdersToCancel          []*OrderData       `protobuf:"bytes,6,rep,name=derivative_orders_to_cancel,json=derivativeOrdersToCancel,proto3" json:"derivative_orders_to_cancel,omitempty"`
	SpotOrdersToCreate                []*SpotOrder       `protobuf:"bytes,7,rep,name=spot_orders_to_create,json=spotOrdersToCreate,proto3" json:"spot_orders_to_create,omitempty"`
	DerivativeOrdersToCreate          []*DerivativeOrder `protobuf:"bytes,8,rep,name=derivative_orders_to_create,json=derivativeOrdersToCreate,proto3" json:"derivative_orders_to_create,omitempty"`
	BinaryOptionsOrdersToCancel       []*OrderData       `protobuf:"bytes,9,rep,name=binary_options_orders_to_cancel,json=binaryOptionsOrdersToCancel,proto3" json:"binary_options_orders_to_cancel,omitempty"`
	BinaryOptionsMarketIdsToCancelAll []string           `protobuf:"bytes,10,rep,name=binary_options_market_ids_to_cancel_all,json=binaryOptionsMarketIdsToCancelAll,proto3" json:"binary_options_market_ids_to_cancel_all,omitempty"`
	BinaryOptionsOrdersToCreate       []*DerivativeOrder `protobuf:"bytes,11,rep,name=binary_options_orders_to_create,json=binaryOptionsOrdersToCreate,proto3" json:"binary_options_orders_to_create,omitempty"`
}

func (m *MsgBatchUpdateOrders) Reset()         { *m = MsgBatchUpdateOrders{} }
func (m *MsgBatchUpdateOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchUpdateOrders) ProtoMessage()    {}
func (*MsgBatchUpdateOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{37}
}
func (m *MsgBatchUpdateOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchUpdateOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchUpdateOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchUpdateOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchUpdateOrders.Merge(m, src)
}
func (m *MsgBatchUpdateOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchUpdateOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchUpdateOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchUpdateOrders proto.InternalMessageInfo

// MsgBatchUpdateOrdersResponse defines the Msg/BatchUpdateOrders response type.
type MsgBatchUpdateOrdersResponse struct {
	SpotCancelSuccess              []bool   `protobuf:"varint,1,rep,packed,name=spot_cancel_success,json=spotCancelSuccess,proto3" json:"spot_cancel_success,omitempty"`
	DerivativeCancelSuccess        []bool   `protobuf:"varint,2,rep,packed,name=derivative_cancel_success,json=derivativeCancelSuccess,proto3" json:"derivative_cancel_success,omitempty"`
	SpotOrderHashes                []string `protobuf:"bytes,3,rep,name=spot_order_hashes,json=spotOrderHashes,proto3" json:"spot_order_hashes,omitempty"`
	DerivativeOrderHashes          []string `protobuf:"bytes,4,rep,name=derivative_order_hashes,json=derivativeOrderHashes,proto3" json:"derivative_order_hashes,omitempty"`
	BinaryOptionsCancelSuccess     []bool   `protobuf:"varint,5,rep,packed,name=binary_options_cancel_success,json=binaryOptionsCancelSuccess,proto3" json:"binary_options_cancel_success,omitempty"`
	BinaryOptionsOrderHashes       []string `protobuf:"bytes,6,rep,name=binary_options_order_hashes,json=binaryOptionsOrderHashes,proto3" json:"binary_options_order_hashes,omitempty"`
	CreatedSpotOrdersCids          []string `protobuf:"bytes,7,rep,name=created_spot_orders_cids,json=createdSpotOrdersCids,proto3" json:"created_spot_orders_cids,omitempty"`
	FailedSpotOrdersCids           []string `protobuf:"bytes,8,rep,name=failed_spot_orders_cids,json=failedSpotOrdersCids,proto3" json:"failed_spot_orders_cids,omitempty"`
	CreatedDerivativeOrdersCids    []string `protobuf:"bytes,9,rep,name=created_derivative_orders_cids,json=createdDerivativeOrdersCids,proto3" json:"created_derivative_orders_cids,omitempty"`
	FailedDerivativeOrdersCids     []string `protobuf:"bytes,10,rep,name=failed_derivative_orders_cids,json=failedDerivativeOrdersCids,proto3" json:"failed_derivative_orders_cids,omitempty"`
	CreatedBinaryOptionsOrdersCids []string `protobuf:"bytes,11,rep,name=created_binary_options_orders_cids,json=createdBinaryOptionsOrdersCids,proto3" json:"created_binary_options_orders_cids,omitempty"`
	FailedBinaryOptionsOrdersCids  []string `protobuf:"bytes,12,rep,name=failed_binary_options_orders_cids,json=failedBinaryOptionsOrdersCids,proto3" json:"failed_binary_options_orders_cids,omitempty"`
}

func (m *MsgBatchUpdateOrdersResponse) Reset()         { *m = MsgBatchUpdateOrdersResponse{} }
func (m *MsgBatchUpdateOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchUpdateOrdersResponse) ProtoMessage()    {}
func (*MsgBatchUpdateOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{38}
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchUpdateOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchUpdateOrdersResponse.Merge(m, src)
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchUpdateOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchUpdateOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchUpdateOrdersResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateDerivativeMarketOrder
type MsgCreateDerivativeMarketOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateDerivativeMarketOrder) Reset()         { *m = MsgCreateDerivativeMarketOrder{} }
func (m *MsgCreateDerivativeMarketOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeMarketOrder) ProtoMessage()    {}
func (*MsgCreateDerivativeMarketOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{39}
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeMarketOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeMarketOrder.Merge(m, src)
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeMarketOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeMarketOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeMarketOrder proto.InternalMessageInfo

// MsgCreateDerivativeMarketOrderResponse defines the
// Msg/CreateDerivativeMarketOrder response type.
type MsgCreateDerivativeMarketOrderResponse struct {
	OrderHash string                        `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Results   *DerivativeMarketOrderResults `protobuf:"bytes,2,opt,name=results,proto3" json:"results,omitempty"`
	Cid       string                        `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCreateDerivativeMarketOrderResponse) Reset() {
	*m = MsgCreateDerivativeMarketOrderResponse{}
}
func (m *MsgCreateDerivativeMarketOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeMarketOrderResponse) ProtoMessage()    {}
func (*MsgCreateDerivativeMarketOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{40}
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse.Merge(m, src)
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse proto.InternalMessageInfo

type DerivativeMarketOrderResults struct {
	Quantity      cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=quantity,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"quantity"`
	Price         cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	Fee           cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=fee,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"fee"`
	PositionDelta PositionDelta               `protobuf:"bytes,4,opt,name=position_delta,json=positionDelta,proto3" json:"position_delta"`
	Payout        cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=payout,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"payout"`
}

func (m *DerivativeMarketOrderResults) Reset()         { *m = DerivativeMarketOrderResults{} }
func (m *DerivativeMarketOrderResults) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarketOrderResults) ProtoMessage()    {}
func (*DerivativeMarketOrderResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{41}
}
func (m *DerivativeMarketOrderResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarketOrderResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarketOrderResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarketOrderResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarketOrderResults.Merge(m, src)
}
func (m *DerivativeMarketOrderResults) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarketOrderResults) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarketOrderResults.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarketOrderResults proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateBinaryOptionsMarketOrder
type MsgCreateBinaryOptionsMarketOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateBinaryOptionsMarketOrder) Reset()         { *m = MsgCreateBinaryOptionsMarketOrder{} }
func (m *MsgCreateBinaryOptionsMarketOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBinaryOptionsMarketOrder) ProtoMessage()    {}
func (*MsgCreateBinaryOptionsMarketOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{42}
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder proto.InternalMessageInfo

// MsgCreateBinaryOptionsMarketOrderResponse defines the
// Msg/CreateBinaryOptionsMarketOrder response type.
type MsgCreateBinaryOptionsMarketOrderResponse struct {
	OrderHash string                        `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Results   *DerivativeMarketOrderResults `protobuf:"bytes,2,opt,name=results,proto3" json:"results,omitempty"`
	Cid       string                        `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) Reset() {
	*m = MsgCreateBinaryOptionsMarketOrderResponse{}
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgCreateBinaryOptionsMarketOrderResponse) ProtoMessage() {}
func (*MsgCreateBinaryOptionsMarketOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{43}
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse proto.InternalMessageInfo

// MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type.
type MsgCancelDerivativeOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId     string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	OrderMask    int32  `protobuf:"varint,5,opt,name=order_mask,json=orderMask,proto3" json:"order_mask,omitempty"`
	Cid          string `protobuf:"bytes,6,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCancelDerivativeOrder) Reset()         { *m = MsgCancelDerivativeOrder{} }
func (m *MsgCancelDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelDerivativeOrder) ProtoMessage()    {}
func (*MsgCancelDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{44}
}
func (m *MsgCancelDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelDerivativeOrder.Merge(m, src)
}
func (m *MsgCancelDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelDerivativeOrder proto.InternalMessageInfo

// MsgCancelDerivativeOrderResponse defines the
// Msg/CancelDerivativeOrderResponse response type.
type MsgCancelDerivativeOrderResponse struct {
}

func (m *MsgCancelDerivativeOrderResponse) Reset()         { *m = MsgCancelDerivativeOrderResponse{} }
func (m *MsgCancelDerivativeOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelDerivativeOrderResponse) ProtoMessage()    {}
func (*MsgCancelDerivativeOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{45}
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelDerivativeOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelDerivativeOrderResponse.Merge(m, src)
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelDerivativeOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelDerivativeOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelDerivativeOrderResponse proto.InternalMessageInfo

// MsgCancelBinaryOptionsOrder defines the Msg/CancelBinaryOptionsOrder response
// type.
type MsgCancelBinaryOptionsOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId     string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	OrderMask    int32  `protobuf:"varint,5,opt,name=order_mask,json=orderMask,proto3" json:"order_mask,omitempty"`
	Cid          string `protobuf:"bytes,6,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *MsgCancelBinaryOptionsOrder) Reset()         { *m = MsgCancelBinaryOptionsOrder{} }
func (m *MsgCancelBinaryOptionsOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelBinaryOptionsOrder) ProtoMessage()    {}
func (*MsgCancelBinaryOptionsOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{46}
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelBinaryOptionsOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelBinaryOptionsOrder.Merge(m, src)
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelBinaryOptionsOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelBinaryOptionsOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelBinaryOptionsOrder proto.InternalMessageInfo

// MsgCancelBinaryOptionsOrderResponse defines the
// Msg/CancelBinaryOptionsOrderResponse response type.
type MsgCancelBinaryOptionsOrderResponse struct {
}

func (m *MsgCancelBinaryOptionsOrderResponse) Reset()         { *m = MsgCancelBinaryOptionsOrderResponse{} }
func (m *MsgCancelBinaryOptionsOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelBinaryOptionsOrderResponse) ProtoMessage()    {}
func (*MsgCancelBinaryOptionsOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{47}
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse.Merge(m, src)
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse proto.InternalMessageInfo

type OrderData struct {
	MarketId     string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,3,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	OrderMask    int32  `protobuf:"varint,4,opt,name=order_mask,json=orderMask,proto3" json:"order_mask,omitempty"`
	Cid          string `protobuf:"bytes,5,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *OrderData) Reset()         { *m = OrderData{} }
func (m *OrderData) String() string { return proto.CompactTextString(m) }
func (*OrderData) ProtoMessage()    {}
func (*OrderData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{48}
}
func (m *OrderData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderData.Merge(m, src)
}
func (m *OrderData) XXX_Size() int {
	return m.Size()
}
func (m *OrderData) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderData.DiscardUnknown(m)
}

var xxx_messageInfo_OrderData proto.InternalMessageInfo

func (m *OrderData) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *OrderData) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *OrderData) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *OrderData) GetOrderMask() int32 {
	if m != nil {
		return m.OrderMask
	}
	return 0
}

func (m *OrderData) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

// MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders
// response type.
type MsgBatchCancelDerivativeOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Data   []OrderData `protobuf:"bytes,2,rep,name=data,proto3" json:"data"`
}

func (m *MsgBatchCancelDerivativeOrders) Reset()         { *m = MsgBatchCancelDerivativeOrders{} }
func (m *MsgBatchCancelDerivativeOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelDerivativeOrders) ProtoMessage()    {}
func (*MsgBatchCancelDerivativeOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{49}
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelDerivativeOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelDerivativeOrders.Merge(m, src)
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelDerivativeOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelDerivativeOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelDerivativeOrders proto.InternalMessageInfo

// MsgBatchCancelDerivativeOrdersResponse defines the
// Msg/CancelDerivativeOrderResponse response type.
type MsgBatchCancelDerivativeOrdersResponse struct {
	Success []bool `protobuf:"varint,1,rep,packed,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgBatchCancelDerivativeOrdersResponse) Reset() {
	*m = MsgBatchCancelDerivativeOrdersResponse{}
}
func (m *MsgBatchCancelDerivativeOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelDerivativeOrdersResponse) ProtoMessage()    {}
func (*MsgBatchCancelDerivativeOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{50}
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgSubaccountTransfer
type MsgSubaccountTransfer struct {
	Sender                  string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SourceSubaccountId      string     `protobuf:"bytes,2,opt,name=source_subaccount_id,json=sourceSubaccountId,proto3" json:"source_subaccount_id,omitempty"`
	DestinationSubaccountId string     `protobuf:"bytes,3,opt,name=destination_subaccount_id,json=destinationSubaccountId,proto3" json:"destination_subaccount_id,omitempty"`
	Amount                  types.Coin `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgSubaccountTransfer) Reset()         { *m = MsgSubaccountTransfer{} }
func (m *MsgSubaccountTransfer) String() string { return proto.CompactTextString(m) }
func (*MsgSubaccountTransfer) ProtoMessage()    {}
func (*MsgSubaccountTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{51}
}
func (m *MsgSubaccountTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubaccountTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubaccountTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubaccountTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubaccountTransfer.Merge(m, src)
}
func (m *MsgSubaccountTransfer) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubaccountTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubaccountTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubaccountTransfer proto.InternalMessageInfo

func (m *MsgSubaccountTransfer) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSubaccountTransfer) GetSourceSubaccountId() string {
	if m != nil {
		return m.SourceSubaccountId
	}
	return ""
}

func (m *MsgSubaccountTransfer) GetDestinationSubaccountId() string {
	if m != nil {
		return m.DestinationSubaccountId
	}
	return ""
}

func (m *MsgSubaccountTransfer) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response
// type.
type MsgSubaccountTransferResponse struct {
}

func (m *MsgSubaccountTransferResponse) Reset()         { *m = MsgSubaccountTransferResponse{} }
func (m *MsgSubaccountTransferResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubaccountTransferResponse) ProtoMessage()    {}
func (*MsgSubaccountTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{52}
}
func (m *MsgSubaccountTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubaccountTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubaccountTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubaccountTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubaccountTransferResponse.Merge(m, src)
}
func (m *MsgSubaccountTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubaccountTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubaccountTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubaccountTransferResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgExternalTransfer
type MsgExternalTransfer struct {
	Sender                  string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SourceSubaccountId      string     `protobuf:"bytes,2,opt,name=source_subaccount_id,json=sourceSubaccountId,proto3" json:"source_subaccount_id,omitempty"`
	DestinationSubaccountId string     `protobuf:"bytes,3,opt,name=destination_subaccount_id,json=destinationSubaccountId,proto3" json:"destination_subaccount_id,omitempty"`
	Amount                  types.Coin `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgExternalTransfer) Reset()         { *m = MsgExternalTransfer{} }
func (m *MsgExternalTransfer) String() string { return proto.CompactTextString(m) }
func (*MsgExternalTransfer) ProtoMessage()    {}
func (*MsgExternalTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{53}
}
func (m *MsgExternalTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExternalTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExternalTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExternalTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExternalTransfer.Merge(m, src)
}
func (m *MsgExternalTransfer) XXX_Size() int {
	return m.Size()
}
func (m *MsgExternalTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExternalTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExternalTransfer proto.InternalMessageInfo

func (m *MsgExternalTransfer) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgExternalTransfer) GetSourceSubaccountId() string {
	if m != nil {
		return m.SourceSubaccountId
	}
	return ""
}

func (m *MsgExternalTransfer) GetDestinationSubaccountId() string {
	if m != nil {
		return m.DestinationSubaccountId
	}
	return ""
}

func (m *MsgExternalTransfer) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgExternalTransferResponse defines the Msg/ExternalTransfer response type.
type MsgExternalTransferResponse struct {
}

func (m *MsgExternalTransferResponse) Reset()         { *m = MsgExternalTransferResponse{} }
func (m *MsgExternalTransferResponse) String() string { return proto.CompactTextString(m) }
func (*MsgExternalTransferResponse) ProtoMessage()    {}
func (*MsgExternalTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{54}
}
func (m *MsgExternalTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExternalTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExternalTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExternalTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExternalTransferResponse.Merge(m, src)
}
func (m *MsgExternalTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgExternalTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExternalTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExternalTransferResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgLiquidatePosition
type MsgLiquidatePosition struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SubaccountId string `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	MarketId     string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// optional order to provide for liquidation
	Order *DerivativeOrder `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *MsgLiquidatePosition) Reset()         { *m = MsgLiquidatePosition{} }
func (m *MsgLiquidatePosition) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidatePosition) ProtoMessage()    {}
func (*MsgLiquidatePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{55}
}
func (m *MsgLiquidatePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidatePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidatePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidatePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidatePosition.Merge(m, src)
}
func (m *MsgLiquidatePosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidatePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidatePosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidatePosition proto.InternalMessageInfo

func (m *MsgLiquidatePosition) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgLiquidatePosition) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *MsgLiquidatePosition) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgLiquidatePosition) GetOrder() *DerivativeOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response type.
type MsgLiquidatePositionResponse struct {
}

func (m *MsgLiquidatePositionResponse) Reset()         { *m = MsgLiquidatePositionResponse{} }
func (m *MsgLiquidatePositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidatePositionResponse) ProtoMessage()    {}
func (*MsgLiquidatePositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{56}
}
func (m *MsgLiquidatePositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidatePositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidatePositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidatePositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidatePositionResponse.Merge(m, src)
}
func (m *MsgLiquidatePositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidatePositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidatePositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidatePositionResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgEmergencySettleMarket
type MsgEmergencySettleMarket struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SubaccountId string `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	MarketId     string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *MsgEmergencySettleMarket) Reset()         { *m = MsgEmergencySettleMarket{} }
func (m *MsgEmergencySettleMarket) String() string { return proto.CompactTextString(m) }
func (*MsgEmergencySettleMarket) ProtoMessage()    {}
func (*MsgEmergencySettleMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{57}
}
func (m *MsgEmergencySettleMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmergencySettleMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmergencySettleMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmergencySettleMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmergencySettleMarket.Merge(m, src)
}
func (m *MsgEmergencySettleMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmergencySettleMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmergencySettleMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmergencySettleMarket proto.InternalMessageInfo

func (m *MsgEmergencySettleMarket) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgEmergencySettleMarket) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *MsgEmergencySettleMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

// MsgEmergencySettleMarketResponse defines the Msg/EmergencySettleMarket
// response type.
type MsgEmergencySettleMarketResponse struct {
}

func (m *MsgEmergencySettleMarketResponse) Reset()         { *m = MsgEmergencySettleMarketResponse{} }
func (m *MsgEmergencySettleMarketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEmergencySettleMarketResponse) ProtoMessage()    {}
func (*MsgEmergencySettleMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{58}
}
func (m *MsgEmergencySettleMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmergencySettleMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmergencySettleMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmergencySettleMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmergencySettleMarketResponse.Merge(m, src)
}
func (m *MsgEmergencySettleMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmergencySettleMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmergencySettleMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmergencySettleMarketResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgIncreasePositionMargin
type MsgIncreasePositionMargin struct {
	Sender                  string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SourceSubaccountId      string `protobuf:"bytes,2,opt,name=source_subaccount_id,json=sourceSubaccountId,proto3" json:"source_subaccount_id,omitempty"`
	DestinationSubaccountId string `protobuf:"bytes,3,opt,name=destination_subaccount_id,json=destinationSubaccountId,proto3" json:"destination_subaccount_id,omitempty"`
	MarketId                string `protobuf:"bytes,4,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount defines the amount of margin to add to the position
	Amount cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=amount,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"amount"`
}

func (m *MsgIncreasePositionMargin) Reset()         { *m = MsgIncreasePositionMargin{} }
func (m *MsgIncreasePositionMargin) String() string { return proto.CompactTextString(m) }
func (*MsgIncreasePositionMargin) ProtoMessage()    {}
func (*MsgIncreasePositionMargin) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{59}
}
func (m *MsgIncreasePositionMargin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIncreasePositionMargin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIncreasePositionMargin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIncreasePositionMargin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIncreasePositionMargin.Merge(m, src)
}
func (m *MsgIncreasePositionMargin) XXX_Size() int {
	return m.Size()
}
func (m *MsgIncreasePositionMargin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIncreasePositionMargin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIncreasePositionMargin proto.InternalMessageInfo

func (m *MsgIncreasePositionMargin) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgIncreasePositionMargin) GetSourceSubaccountId() string {
	if m != nil {
		return m.SourceSubaccountId
	}
	return ""
}

func (m *MsgIncreasePositionMargin) GetDestinationSubaccountId() string {
	if m != nil {
		return m.DestinationSubaccountId
	}
	return ""
}

func (m *MsgIncreasePositionMargin) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

// MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin
// response type.
type MsgIncreasePositionMarginResponse struct {
}

func (m *MsgIncreasePositionMarginResponse) Reset()         { *m = MsgIncreasePositionMarginResponse{} }
func (m *MsgIncreasePositionMarginResponse) String() string { return proto.CompactTextString(m) }
func (*MsgIncreasePositionMarginResponse) ProtoMessage()    {}
func (*MsgIncreasePositionMarginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{60}
}
func (m *MsgIncreasePositionMarginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIncreasePositionMarginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIncreasePositionMarginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIncreasePositionMarginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIncreasePositionMarginResponse.Merge(m, src)
}
func (m *MsgIncreasePositionMarginResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgIncreasePositionMarginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIncreasePositionMarginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIncreasePositionMarginResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgDecreasePositionMargin
type MsgDecreasePositionMargin struct {
	Sender                  string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SourceSubaccountId      string `protobuf:"bytes,2,opt,name=source_subaccount_id,json=sourceSubaccountId,proto3" json:"source_subaccount_id,omitempty"`
	DestinationSubaccountId string `protobuf:"bytes,3,opt,name=destination_subaccount_id,json=destinationSubaccountId,proto3" json:"destination_subaccount_id,omitempty"`
	MarketId                string `protobuf:"bytes,4,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount defines the amount of margin to withdraw from the position
	Amount cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=amount,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"amount"`
}

func (m *MsgDecreasePositionMargin) Reset()         { *m = MsgDecreasePositionMargin{} }
func (m *MsgDecreasePositionMargin) String() string { return proto.CompactTextString(m) }
func (*MsgDecreasePositionMargin) ProtoMessage()    {}
func (*MsgDecreasePositionMargin) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{61}
}
func (m *MsgDecreasePositionMargin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDecreasePositionMargin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDecreasePositionMargin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDecreasePositionMargin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDecreasePositionMargin.Merge(m, src)
}
func (m *MsgDecreasePositionMargin) XXX_Size() int {
	return m.Size()
}
func (m *MsgDecreasePositionMargin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDecreasePositionMargin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDecreasePositionMargin proto.InternalMessageInfo

func (m *MsgDecreasePositionMargin) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgDecreasePositionMargin) GetSourceSubaccountId() string {
	if m != nil {
		return m.SourceSubaccountId
	}
	return ""
}

func (m *MsgDecreasePositionMargin) GetDestinationSubaccountId() string {
	if m != nil {
		return m.DestinationSubaccountId
	}
	return ""
}

func (m *MsgDecreasePositionMargin) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

// MsgDecreasePositionMarginResponse defines the Msg/MsgDecreasePositionMargin
// response type.
type MsgDecreasePositionMarginResponse struct {
}

func (m *MsgDecreasePositionMarginResponse) Reset()         { *m = MsgDecreasePositionMarginResponse{} }
func (m *MsgDecreasePositionMarginResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDecreasePositionMarginResponse) ProtoMessage()    {}
func (*MsgDecreasePositionMarginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{62}
}
func (m *MsgDecreasePositionMarginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDecreasePositionMarginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDecreasePositionMarginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDecreasePositionMarginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDecreasePositionMarginResponse.Merge(m, src)
}
func (m *MsgDecreasePositionMarginResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDecreasePositionMarginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDecreasePositionMarginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDecreasePositionMarginResponse proto.InternalMessageInfo

// MsgPrivilegedExecuteContract defines the Msg/Exec message type
type MsgPrivilegedExecuteContract struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// funds defines the user's bank coins used to fund the execution (e.g.
	// 100inj).
	Funds string `protobuf:"bytes,2,opt,name=funds,proto3" json:"funds,omitempty"`
	// contract_address defines the contract address to execute
	ContractAddress string `protobuf:"bytes,3,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	// data defines the call data used when executing the contract
	Data string `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgPrivilegedExecuteContract) Reset()         { *m = MsgPrivilegedExecuteContract{} }
func (m *MsgPrivilegedExecuteContract) String() string { return proto.CompactTextString(m) }
func (*MsgPrivilegedExecuteContract) ProtoMessage()    {}
func (*MsgPrivilegedExecuteContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{63}
}
func (m *MsgPrivilegedExecuteContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPrivilegedExecuteContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPrivilegedExecuteContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPrivilegedExecuteContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPrivilegedExecuteContract.Merge(m, src)
}
func (m *MsgPrivilegedExecuteContract) XXX_Size() int {
	return m.Size()
}
func (m *MsgPrivilegedExecuteContract) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPrivilegedExecuteContract.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPrivilegedExecuteContract proto.InternalMessageInfo

// MsgPrivilegedExecuteContractResponse defines the Msg/Exec response type.
type MsgPrivilegedExecuteContractResponse struct {
	FundsDiff github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=funds_diff,json=fundsDiff,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"funds_diff"`
}

func (m *MsgPrivilegedExecuteContractResponse) Reset()         { *m = MsgPrivilegedExecuteContractResponse{} }
func (m *MsgPrivilegedExecuteContractResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPrivilegedExecuteContractResponse) ProtoMessage()    {}
func (*MsgPrivilegedExecuteContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{64}
}
func (m *MsgPrivilegedExecuteContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPrivilegedExecuteContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPrivilegedExecuteContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPrivilegedExecuteContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPrivilegedExecuteContractResponse.Merge(m, src)
}
func (m *MsgPrivilegedExecuteContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPrivilegedExecuteContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPrivilegedExecuteContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPrivilegedExecuteContractResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgRewardsOptOut
type MsgRewardsOptOut struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *MsgRewardsOptOut) Reset()         { *m = MsgRewardsOptOut{} }
func (m *MsgRewardsOptOut) String() string { return proto.CompactTextString(m) }
func (*MsgRewardsOptOut) ProtoMessage()    {}
func (*MsgRewardsOptOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{65}
}
func (m *MsgRewardsOptOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRewardsOptOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRewardsOptOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRewardsOptOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRewardsOptOut.Merge(m, src)
}
func (m *MsgRewardsOptOut) XXX_Size() int {
	return m.Size()
}
func (m *MsgRewardsOptOut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRewardsOptOut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRewardsOptOut proto.InternalMessageInfo

// MsgRewardsOptOutResponse defines the Msg/RewardsOptOut response type.
type MsgRewardsOptOutResponse struct {
}

func (m *MsgRewardsOptOutResponse) Reset()         { *m = MsgRewardsOptOutResponse{} }
func (m *MsgRewardsOptOutResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRewardsOptOutResponse) ProtoMessage()    {}
func (*MsgRewardsOptOutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{66}
}
func (m *MsgRewardsOptOutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRewardsOptOutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRewardsOptOutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRewardsOptOutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRewardsOptOutResponse.Merge(m, src)
}
func (m *MsgRewardsOptOutResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRewardsOptOutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRewardsOptOutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRewardsOptOutResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgReclaimLockedFunds
type MsgReclaimLockedFunds struct {
	Sender              string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	LockedAccountPubKey []byte `protobuf:"bytes,2,opt,name=lockedAccountPubKey,proto3" json:"lockedAccountPubKey,omitempty"`
	Signature           []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgReclaimLockedFunds) Reset()         { *m = MsgReclaimLockedFunds{} }
func (m *MsgReclaimLockedFunds) String() string { return proto.CompactTextString(m) }
func (*MsgReclaimLockedFunds) ProtoMessage()    {}
func (*MsgReclaimLockedFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{67}
}
func (m *MsgReclaimLockedFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReclaimLockedFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReclaimLockedFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReclaimLockedFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReclaimLockedFunds.Merge(m, src)
}
func (m *MsgReclaimLockedFunds) XXX_Size() int {
	return m.Size()
}
func (m *MsgReclaimLockedFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReclaimLockedFunds.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReclaimLockedFunds proto.InternalMessageInfo

func (m *MsgReclaimLockedFunds) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgReclaimLockedFunds) GetLockedAccountPubKey() []byte {
	if m != nil {
		return m.LockedAccountPubKey
	}
	return nil
}

func (m *MsgReclaimLockedFunds) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MsgReclaimLockedFundsResponse defines the Msg/ReclaimLockedFunds response
// type.
type MsgReclaimLockedFundsResponse struct {
}

func (m *MsgReclaimLockedFundsResponse) Reset()         { *m = MsgReclaimLockedFundsResponse{} }
func (m *MsgReclaimLockedFundsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReclaimLockedFundsResponse) ProtoMessage()    {}
func (*MsgReclaimLockedFundsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{68}
}
func (m *MsgReclaimLockedFundsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReclaimLockedFundsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReclaimLockedFundsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReclaimLockedFundsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReclaimLockedFundsResponse.Merge(m, src)
}
func (m *MsgReclaimLockedFundsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReclaimLockedFundsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReclaimLockedFundsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReclaimLockedFundsResponse proto.InternalMessageInfo

// MsgSignData defines an arbitrary, general-purpose, off-chain message
type MsgSignData struct {
	// Signer is the sdk.AccAddress of the message signer
	Signer github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=Signer,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"signer"`
	// Data represents the raw bytes of the content that is signed (text, json,
	// etc)
	Data []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"data"`
}

func (m *MsgSignData) Reset()         { *m = MsgSignData{} }
func (m *MsgSignData) String() string { return proto.CompactTextString(m) }
func (*MsgSignData) ProtoMessage()    {}
func (*MsgSignData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{69}
}
func (m *MsgSignData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSignData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSignData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSignData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSignData.Merge(m, src)
}
func (m *MsgSignData) XXX_Size() int {
	return m.Size()
}
func (m *MsgSignData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSignData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSignData proto.InternalMessageInfo

func (m *MsgSignData) GetSigner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *MsgSignData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// MsgSignDoc defines an arbitrary, general-purpose, off-chain message
type MsgSignDoc struct {
	SignType string      `protobuf:"bytes,1,opt,name=sign_type,json=signType,proto3" json:"type"`
	Value    MsgSignData `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
}

func (m *MsgSignDoc) Reset()         { *m = MsgSignDoc{} }
func (m *MsgSignDoc) String() string { return proto.CompactTextString(m) }
func (*MsgSignDoc) ProtoMessage()    {}
func (*MsgSignDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{70}
}
func (m *MsgSignDoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSignDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSignDoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSignDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSignDoc.Merge(m, src)
}
func (m *MsgSignDoc) XXX_Size() int {
	return m.Size()
}
func (m *MsgSignDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSignDoc.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSignDoc proto.InternalMessageInfo

func (m *MsgSignDoc) GetSignType() string {
	if m != nil {
		return m.SignType
	}
	return ""
}

func (m *MsgSignDoc) GetValue() MsgSignData {
	if m != nil {
		return m.Value
	}
	return MsgSignData{}
}

// MsgAdminUpdateBinaryOptionsMarket is used by the market Admin to operate the
// market
type MsgAdminUpdateBinaryOptionsMarket struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// new price at which market will be settled
	SettlementPrice *cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=settlement_price,json=settlementPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"settlement_price,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,4,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,5,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,6,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
}

func (m *MsgAdminUpdateBinaryOptionsMarket) Reset()         { *m = MsgAdminUpdateBinaryOptionsMarket{} }
func (m *MsgAdminUpdateBinaryOptionsMarket) String() string { return proto.CompactTextString(m) }
func (*MsgAdminUpdateBinaryOptionsMarket) ProtoMessage()    {}
func (*MsgAdminUpdateBinaryOptionsMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{71}
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket.Merge(m, src)
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket proto.InternalMessageInfo

func (m *MsgAdminUpdateBinaryOptionsMarket) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetExpirationTimestamp() int64 {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return 0
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetSettlementTimestamp() int64 {
	if m != nil {
		return m.SettlementTimestamp
	}
	return 0
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetStatus() MarketStatus {
	if m != nil {
		return m.Status
	}
	return MarketStatus_Unspecified
}

// MsgAdminUpdateBinaryOptionsMarketResponse is the response for
// AdminUpdateBinaryOptionsMarket rpc method
type MsgAdminUpdateBinaryOptionsMarketResponse struct {
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Reset() {
	*m = MsgAdminUpdateBinaryOptionsMarketResponse{}
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgAdminUpdateBinaryOptionsMarketResponse) ProtoMessage() {}
func (*MsgAdminUpdateBinaryOptionsMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{72}
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse.Merge(m, src)
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse proto.InternalMessageInfo

// MsgAuthorizeStakeGrants grants stakes to grantees.
type MsgAuthorizeStakeGrants struct {
	Sender string                `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Grants []*GrantAuthorization `protobuf:"bytes,2,rep,name=grants,proto3" json:"grants,omitempty"`
}

func (m *MsgAuthorizeStakeGrants) Reset()         { *m = MsgAuthorizeStakeGrants{} }
func (m *MsgAuthorizeStakeGrants) String() string { return proto.CompactTextString(m) }
func (*MsgAuthorizeStakeGrants) ProtoMessage()    {}
func (*MsgAuthorizeStakeGrants) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{73}
}
func (m *MsgAuthorizeStakeGrants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAuthorizeStakeGrants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAuthorizeStakeGrants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAuthorizeStakeGrants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAuthorizeStakeGrants.Merge(m, src)
}
func (m *MsgAuthorizeStakeGrants) XXX_Size() int {
	return m.Size()
}
func (m *MsgAuthorizeStakeGrants) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAuthorizeStakeGrants.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAuthorizeStakeGrants proto.InternalMessageInfo

func (m *MsgAuthorizeStakeGrants) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgAuthorizeStakeGrants) GetGrants() []*GrantAuthorization {
	if m != nil {
		return m.Grants
	}
	return nil
}

type MsgAuthorizeStakeGrantsResponse struct {
}

func (m *MsgAuthorizeStakeGrantsResponse) Reset()         { *m = MsgAuthorizeStakeGrantsResponse{} }
func (m *MsgAuthorizeStakeGrantsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAuthorizeStakeGrantsResponse) ProtoMessage()    {}
func (*MsgAuthorizeStakeGrantsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{74}
}
func (m *MsgAuthorizeStakeGrantsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAuthorizeStakeGrantsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAuthorizeStakeGrantsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAuthorizeStakeGrantsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAuthorizeStakeGrantsResponse.Merge(m, src)
}
func (m *MsgAuthorizeStakeGrantsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAuthorizeStakeGrantsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAuthorizeStakeGrantsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAuthorizeStakeGrantsResponse proto.InternalMessageInfo

// MsgActivateStakeGrant allows a grantee to activate a stake grant.
type MsgActivateStakeGrant struct {
	Sender  string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Granter string `protobuf:"bytes,2,opt,name=granter,proto3" json:"granter,omitempty"`
}

func (m *MsgActivateStakeGrant) Reset()         { *m = MsgActivateStakeGrant{} }
func (m *MsgActivateStakeGrant) String() string { return proto.CompactTextString(m) }
func (*MsgActivateStakeGrant) ProtoMessage()    {}
func (*MsgActivateStakeGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{75}
}
func (m *MsgActivateStakeGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateStakeGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateStakeGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateStakeGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateStakeGrant.Merge(m, src)
}
func (m *MsgActivateStakeGrant) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateStakeGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateStakeGrant.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateStakeGrant proto.InternalMessageInfo

func (m *MsgActivateStakeGrant) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgActivateStakeGrant) GetGranter() string {
	if m != nil {
		return m.Granter
	}
	return ""
}

type MsgActivateStakeGrantResponse struct {
}

func (m *MsgActivateStakeGrantResponse) Reset()         { *m = MsgActivateStakeGrantResponse{} }
func (m *MsgActivateStakeGrantResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateStakeGrantResponse) ProtoMessage()    {}
func (*MsgActivateStakeGrantResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{76}
}
func (m *MsgActivateStakeGrantResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateStakeGrantResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateStakeGrantResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateStakeGrantResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateStakeGrantResponse.Merge(m, src)
}
func (m *MsgActivateStakeGrantResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateStakeGrantResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateStakeGrantResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateStakeGrantResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgUpdateSpotMarket)(nil), "injective.exchange.v1beta1.MsgUpdateSpotMarket")
	proto.RegisterType((*MsgUpdateSpotMarketResponse)(nil), "injective.exchange.v1beta1.MsgUpdateSpotMarketResponse")
	proto.RegisterType((*MsgUpdateDerivativeMarket)(nil), "injective.exchange.v1beta1.MsgUpdateDerivativeMarket")
	proto.RegisterType((*MsgUpdateDerivativeMarketResponse)(nil), "injective.exchange.v1beta1.MsgUpdateDerivativeMarketResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "injective.exchange.v1beta1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "injective.exchange.v1beta1.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgDeposit)(nil), "injective.exchange.v1beta1.MsgDeposit")
	proto.RegisterType((*MsgDepositResponse)(nil), "injective.exchange.v1beta1.MsgDepositResponse")
	proto.RegisterType((*MsgWithdraw)(nil), "injective.exchange.v1beta1.MsgWithdraw")
	proto.RegisterType((*MsgWithdrawResponse)(nil), "injective.exchange.v1beta1.MsgWithdrawResponse")
	proto.RegisterType((*MsgCreateSpotLimitOrder)(nil), "injective.exchange.v1beta1.MsgCreateSpotLimitOrder")
	proto.RegisterType((*MsgCreateSpotLimitOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse")
	proto.RegisterType((*MsgBatchCreateSpotLimitOrders)(nil), "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders")
	proto.RegisterType((*MsgBatchCreateSpotLimitOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse")
	proto.RegisterType((*MsgInstantSpotMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantSpotMarketLaunch")
	proto.RegisterType((*MsgInstantSpotMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse")
	proto.RegisterType((*MsgInstantPerpetualMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch")
	proto.RegisterType((*MsgInstantPerpetualMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse")
	proto.RegisterType((*MsgInstantBinaryOptionsMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch")
	proto.RegisterType((*MsgInstantBinaryOptionsMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse")
	proto.RegisterType((*MsgInstantExpiryFuturesMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch")
	proto.RegisterType((*MsgInstantExpiryFuturesMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse")
	proto.RegisterType((*MsgCreateSpotMarketOrder)(nil), "injective.exchange.v1beta1.MsgCreateSpotMarketOrder")
	proto.RegisterType((*MsgCreateSpotMarketOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse")
	proto.RegisterType((*SpotMarketOrderResults)(nil), "injective.exchange.v1beta1.SpotMarketOrderResults")
	proto.RegisterType((*MsgCreateDerivativeLimitOrder)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder")
	proto.RegisterType((*MsgCreateDerivativeLimitOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse")
	proto.RegisterType((*MsgCreateBinaryOptionsLimitOrder)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder")
	proto.RegisterType((*MsgCreateBinaryOptionsLimitOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse")
	proto.RegisterType((*MsgBatchCreateDerivativeLimitOrders)(nil), "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders")
	proto.RegisterType((*MsgBatchCreateDerivativeLimitOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse")
	proto.RegisterType((*MsgCancelSpotOrder)(nil), "injective.exchange.v1beta1.MsgCancelSpotOrder")
	proto.RegisterType((*MsgCancelSpotOrderResponse)(nil), "injective.exchange.v1beta1.MsgCancelSpotOrderResponse")
	proto.RegisterType((*MsgBatchCancelSpotOrders)(nil), "injective.exchange.v1beta1.MsgBatchCancelSpotOrders")
	proto.RegisterType((*MsgBatchCancelSpotOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse")
	proto.RegisterType((*MsgBatchCancelBinaryOptionsOrders)(nil), "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders")
	proto.RegisterType((*MsgBatchCancelBinaryOptionsOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse")
	proto.RegisterType((*MsgBatchUpdateOrders)(nil), "injective.exchange.v1beta1.MsgBatchUpdateOrders")
	proto.RegisterType((*MsgBatchUpdateOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse")
	proto.RegisterType((*MsgCreateDerivativeMarketOrder)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder")
	proto.RegisterType((*MsgCreateDerivativeMarketOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse")
	proto.RegisterType((*DerivativeMarketOrderResults)(nil), "injective.exchange.v1beta1.DerivativeMarketOrderResults")
	proto.RegisterType((*MsgCreateBinaryOptionsMarketOrder)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder")
	proto.RegisterType((*MsgCreateBinaryOptionsMarketOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse")
	proto.RegisterType((*MsgCancelDerivativeOrder)(nil), "injective.exchange.v1beta1.MsgCancelDerivativeOrder")
	proto.RegisterType((*MsgCancelDerivativeOrderResponse)(nil), "injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse")
	proto.RegisterType((*MsgCancelBinaryOptionsOrder)(nil), "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder")
	proto.RegisterType((*MsgCancelBinaryOptionsOrderResponse)(nil), "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse")
	proto.RegisterType((*OrderData)(nil), "injective.exchange.v1beta1.OrderData")
	proto.RegisterType((*MsgBatchCancelDerivativeOrders)(nil), "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders")
	proto.RegisterType((*MsgBatchCancelDerivativeOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse")
	proto.RegisterType((*MsgSubaccountTransfer)(nil), "injective.exchange.v1beta1.MsgSubaccountTransfer")
	proto.RegisterType((*MsgSubaccountTransferResponse)(nil), "injective.exchange.v1beta1.MsgSubaccountTransferResponse")
	proto.RegisterType((*MsgExternalTransfer)(nil), "injective.exchange.v1beta1.MsgExternalTransfer")
	proto.RegisterType((*MsgExternalTransferResponse)(nil), "injective.exchange.v1beta1.MsgExternalTransferResponse")
	proto.RegisterType((*MsgLiquidatePosition)(nil), "injective.exchange.v1beta1.MsgLiquidatePosition")
	proto.RegisterType((*MsgLiquidatePositionResponse)(nil), "injective.exchange.v1beta1.MsgLiquidatePositionResponse")
	proto.RegisterType((*MsgEmergencySettleMarket)(nil), "injective.exchange.v1beta1.MsgEmergencySettleMarket")
	proto.RegisterType((*MsgEmergencySettleMarketResponse)(nil), "injective.exchange.v1beta1.MsgEmergencySettleMarketResponse")
	proto.RegisterType((*MsgIncreasePositionMargin)(nil), "injective.exchange.v1beta1.MsgIncreasePositionMargin")
	proto.RegisterType((*MsgIncreasePositionMarginResponse)(nil), "injective.exchange.v1beta1.MsgIncreasePositionMarginResponse")
	proto.RegisterType((*MsgDecreasePositionMargin)(nil), "injective.exchange.v1beta1.MsgDecreasePositionMargin")
	proto.RegisterType((*MsgDecreasePositionMarginResponse)(nil), "injective.exchange.v1beta1.MsgDecreasePositionMarginResponse")
	proto.RegisterType((*MsgPrivilegedExecuteContract)(nil), "injective.exchange.v1beta1.MsgPrivilegedExecuteContract")
	proto.RegisterType((*MsgPrivilegedExecuteContractResponse)(nil), "injective.exchange.v1beta1.MsgPrivilegedExecuteContractResponse")
	proto.RegisterType((*MsgRewardsOptOut)(nil), "injective.exchange.v1beta1.MsgRewardsOptOut")
	proto.RegisterType((*MsgRewardsOptOutResponse)(nil), "injective.exchange.v1beta1.MsgRewardsOptOutResponse")
	proto.RegisterType((*MsgReclaimLockedFunds)(nil), "injective.exchange.v1beta1.MsgReclaimLockedFunds")
	proto.RegisterType((*MsgReclaimLockedFundsResponse)(nil), "injective.exchange.v1beta1.MsgReclaimLockedFundsResponse")
	proto.RegisterType((*MsgSignData)(nil), "injective.exchange.v1beta1.MsgSignData")
	proto.RegisterType((*MsgSignDoc)(nil), "injective.exchange.v1beta1.MsgSignDoc")
	proto.RegisterType((*MsgAdminUpdateBinaryOptionsMarket)(nil), "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket")
	proto.RegisterType((*MsgAdminUpdateBinaryOptionsMarketResponse)(nil), "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse")
	proto.RegisterType((*MsgAuthorizeStakeGrants)(nil), "injective.exchange.v1beta1.MsgAuthorizeStakeGrants")
	proto.RegisterType((*MsgAuthorizeStakeGrantsResponse)(nil), "injective.exchange.v1beta1.MsgAuthorizeStakeGrantsResponse")
	proto.RegisterType((*MsgActivateStakeGrant)(nil), "injective.exchange.v1beta1.MsgActivateStakeGrant")
	proto.RegisterType((*MsgActivateStakeGrantResponse)(nil), "injective.exchange.v1beta1.MsgActivateStakeGrantResponse")
}

func init() {
	proto.RegisterFile("injective/exchange/v1beta1/tx.proto", fileDescriptor_bd45b74cb6d81462)
}

var fileDescriptor_bd45b74cb6d81462 = []byte{
	// 3934 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3c, 0x4b, 0x6c, 0x1c, 0xc7,
	0x95, 0x6a, 0x0e, 0x39, 0x24, 0x1f, 0x29, 0x89, 0x6a, 0x52, 0xe2, 0x70, 0xf8, 0x93, 0x9a, 0x92,
	0xf5, 0x27, 0xf5, 0xff, 0x8c, 0x56, 0x96, 0xf8, 0x91, 0x6c, 0xae, 0x45, 0x4b, 0x1e, 0xca, 0xbb,
	0xde, 0x85, 0xbd, 0x83, 0x66, 0x4f, 0x71, 0xd8, 0xe6, 0x4c, 0xf7, 0xa8, 0xbb, 0x47, 0x12, 0x8d,
	0x05, 0x76, 0xd7, 0x87, 0x85, 0x76, 0x13, 0x04, 0x09, 0x10, 0x20, 0x40, 0x00, 0x03, 0x06, 0x02,
	0xc4, 0x80, 0x13, 0x24, 0x76, 0x10, 0x04, 0x3e, 0xe4, 0x87, 0x20, 0x07, 0xc7, 0x27, 0x27, 0x40,
	0x80, 0x20, 0x07, 0x25, 0xb0, 0x0f, 0x36, 0x7c, 0x0a, 0x72, 0x09, 0x90, 0x5c, 0x82, 0xae, 0xaa,
	0xae, 0xe9, 0x4f, 0x55, 0x77, 0xcf, 0x88, 0xb4, 0xe5, 0xc0, 0x17, 0x89, 0x5d, 0xf5, 0xde, 0xab,
	0xf7, 0x5e, 0xbd, 0x4f, 0xd5, 0xab, 0xaa, 0x81, 0x29, 0xdd, 0x78, 0x19, 0x69, 0x8e, 0x7e, 0x17,
	0xcd, 0xa0, 0xfb, 0xda, 0x9a, 0x6a, 0x54, 0xd0, 0xcc, 0xdd, 0x93, 0x2b, 0xc8, 0x51, 0x4f, 0xce,
	0x38, 0xf7, 0xa7, 0xeb, 0x96, 0xe9, 0x98, 0x72, 0x9e, 0x01, 0x4d, 0x7b, 0x40, 0xd3, 0x14, 0x28,
	0x3f, 0xa1, 0x99, 0x76, 0xcd, 0xb4, 0x67, 0x56, 0x54, 0xbb, 0x89, 0xa9, 0x99, 0xba, 0x41, 0x70,
	0xf3, 0xd3, 0xb4, 0xbf, 0xac, 0xdb, 0x8e, 0xa5, 0xaf, 0x34, 0x1c, 0xdd, 0x34, 0x18, 0x9c, 0xbf,
	0x91, 0xc2, 0x0f, 0x53, 0xf8, 0x9a, 0x5d, 0x99, 0xb9, 0x7b, 0xd2, 0xfd, 0x8f, 0x76, 0x8c, 0x90,
	0x8e, 0x12, 0xfe, 0x9a, 0x21, 0x1f, 0xb4, 0x6b, 0xa8, 0x62, 0x56, 0x4c, 0xd2, 0xee, 0xfe, 0x45,
	0x5b, 0x0f, 0xc7, 0x88, 0xc6, 0xc4, 0x20, 0xa0, 0x07, 0x9a, 0xa0, 0xa6, 0xa5, 0x6a, 0xd5, 0x26,
	0x20, 0xf9, 0xa4, 0x60, 0xbb, 0xd4, 0x9a, 0x6e, 0x98, 0x33, 0xf8, 0x5f, 0xd2, 0xa4, 0xbc, 0x91,
	0x81, 0xc1, 0x25, 0xbb, 0xf2, 0x7c, 0xbd, 0xac, 0x3a, 0x68, 0xb9, 0x6e, 0x3a, 0x4b, 0xaa, 0xb5,
	0x8e, 0x1c, 0x79, 0x08, 0xba, 0xd4, 0x72, 0x4d, 0x37, 0x72, 0xd2, 0x5e, 0xe9, 0x50, 0x6f, 0x91,
	0x7c, 0xc8, 0xa3, 0xd0, 0x5b, 0xc3, 0xfd, 0x25, 0xbd, 0x9c, 0xeb, 0xc0, 0x3d, 0x3d, 0xa4, 0x61,
	0xb1, 0x2c, 0x8f, 0x03, 0x18, 0xe8, 0x5e, 0xc9, 0xd1, 0xb5, 0x75, 0x64, 0xe5, 0x32, 0xb8, 0xb7,
	0xd7, 0x40, 0xf7, 0x6e, 0xe3, 0x06, 0xf9, 0xdf, 0x60, 0xd8, 0xed, 0xae, 0xe9, 0x46, 0xa9, 0x6e,
	0xe9, 0x1a, 0xc2, 0x80, 0x25, 0x5b, 0x7f, 0x05, 0xe5, 0x3a, 0x5d, 0xd8, 0xb9, 0xa9, 0x77, 0x1f,
	0x4e, 0x6e, 0xfb, 0xfd, 0xc3, 0xc9, 0x51, 0xa2, 0x1b, 0xbb, 0xbc, 0x3e, 0xad, 0x9b, 0x33, 0x35,
	0xd5, 0x59, 0x9b, 0xbe, 0x81, 0x2a, 0xaa, 0xb6, 0xb1, 0x80, 0xb4, 0xe2, 0xa0, 0x81, 0xee, 0x2d,
	0xe9, 0xc6, 0x2d, 0x97, 0x82, 0x4b, 0x78, 0x59, 0x7f, 0x05, 0xc9, 0x25, 0xc8, 0x7b, 0xa4, 0xef,
	0x34, 0x54, 0xc3, 0xd1, 0x9d, 0x0d, 0x1f, 0xf5, 0xae, 0xf4, 0xd4, 0xf7, 0x10, 0xea, 0xcf, 0x51,
	0x22, 0x6c, 0x80, 0x25, 0x18, 0xf0, 0x06, 0x30, 0x4c, 0x77, 0xb2, 0xd5, 0x6a, 0x2e, 0x9b, 0x9e,
	0xec, 0x0e, 0x42, 0xf6, 0x59, 0x8a, 0x5a, 0x38, 0xfd, 0xe0, 0xf5, 0xc9, 0x6d, 0x1f, 0xbf, 0x3e,
	0xb9, 0xed, 0xd5, 0x8f, 0xde, 0x3a, 0x42, 0x54, 0xfb, 0xff, 0x1f, 0xbd, 0x75, 0x64, 0x8c, 0x4d,
	0x33, 0x67, 0x46, 0x94, 0x71, 0x18, 0xe5, 0x34, 0x17, 0x91, 0x5d, 0x37, 0x0d, 0x1b, 0x29, 0x7f,
	0xe9, 0x84, 0x11, 0xd6, 0xbf, 0x80, 0x2c, 0xfd, 0xae, 0xea, 0xda, 0xc3, 0x17, 0xd3, 0xb9, 0xe5,
	0xd3, 0x29, 0xbf, 0x08, 0x39, 0x97, 0x9c, 0x6e, 0xe8, 0x8e, 0xae, 0x56, 0x4b, 0x35, 0xd5, 0xaa,
	0xe8, 0x46, 0xc9, 0x52, 0x1d, 0xdd, 0xcc, 0x75, 0xa7, 0x27, 0xbb, 0xdb, 0x40, 0xf7, 0x16, 0x09,
	0x8d, 0x25, 0x4c, 0xa2, 0xe8, 0x52, 0x90, 0xcb, 0x30, 0x86, 0x99, 0x55, 0x75, 0xc3, 0x41, 0x86,
	0x6a, 0x68, 0x28, 0x38, 0x42, 0x4f, 0xfa, 0x11, 0x46, 0x5c, 0xc6, 0x9b, 0x74, 0x7c, 0xa3, 0x14,
	0x2e, 0xf2, 0x4d, 0x52, 0x89, 0x9a, 0x64, 0xd8, 0xb6, 0x94, 0x29, 0xd8, 0x27, 0xec, 0x64, 0xe6,
	0xf9, 0x8e, 0x04, 0x3b, 0x19, 0xd4, 0x2d, 0xd5, 0x52, 0x6b, 0xb6, 0x7c, 0x0e, 0x7a, 0xd5, 0x86,
	0xb3, 0x66, 0x5a, 0xba, 0xb3, 0x41, 0x0c, 0x73, 0x2e, 0xf7, 0x9b, 0x1f, 0x1e, 0x1f, 0xa2, 0xb1,
	0x71, 0xb6, 0x5c, 0xb6, 0x90, 0x6d, 0x2f, 0x3b, 0x96, 0x6e, 0x54, 0x8a, 0x4d, 0x50, 0xf9, 0x2a,
	0x64, 0xeb, 0x98, 0x02, 0xb6, 0xd9, 0xbe, 0x53, 0xca, 0xb4, 0x38, 0xbe, 0x4f, 0x93, 0xb1, 0xe6,
	0x3a, 0x5d, 0xfd, 0x14, 0x29, 0x5e, 0xe1, 0xa8, 0x2b, 0x65, 0x93, 0xa2, 0x2b, 0x69, 0x2e, 0x2a,
	0x29, 0x41, 0x55, 0x46, 0x60, 0x38, 0xd4, 0xc4, 0xa4, 0xfa, 0xbe, 0x04, 0xb0, 0x64, 0x57, 0x16,
	0x50, 0xdd, 0xb4, 0x75, 0x47, 0xde, 0x03, 0x59, 0x1b, 0x19, 0x65, 0x64, 0x51, 0x37, 0xa3, 0x5f,
	0xf2, 0x14, 0x6c, 0xb7, 0x1b, 0x2b, 0xaa, 0xa6, 0x99, 0x0d, 0xc3, 0xe7, 0x6b, 0xfd, 0xcd, 0xc6,
	0xc5, 0xb2, 0x7c, 0x1e, 0xb2, 0x6a, 0xcd, 0xfd, 0x1b, 0xfb, 0x5a, 0xdf, 0xa9, 0x11, 0x9a, 0x79,
	0xa6, 0xdd, 0xcc, 0xc4, 0xc4, 0x99, 0x37, 0x75, 0xc3, 0x13, 0x86, 0x80, 0x17, 0x8e, 0xfa, 0xa7,
	0x8e, 0x0e, 0xe9, 0x4a, 0x34, 0xe8, 0x97, 0x88, 0xb2, 0xa8, 0x0c, 0x81, 0xdc, 0xfc, 0x62, 0x72,
	0xbc, 0x2d, 0x41, 0xdf, 0x92, 0x5d, 0xf9, 0x57, 0xdd, 0x59, 0x2b, 0x5b, 0xea, 0xbd, 0xcf, 0x48,
	0x90, 0x63, 0x02, 0x41, 0x86, 0xfc, 0x82, 0x78, 0x3c, 0x2a, 0xbb, 0x71, 0xe2, 0xf2, 0x3e, 0x99,
	0x28, 0xdf, 0x93, 0xf0, 0x74, 0xcd, 0x5b, 0x88, 0xc6, 0xc9, 0x1b, 0x7a, 0x4d, 0x77, 0x6e, 0x5a,
	0x2e, 0xfb, 0x22, 0xb1, 0x66, 0xa1, 0xcb, 0x74, 0x01, 0xa8, 0x3d, 0x1d, 0x88, 0xb3, 0x27, 0x97,
	0x24, 0xa6, 0x46, 0x99, 0x27, 0x98, 0x85, 0x0b, 0x02, 0xde, 0xf7, 0xfa, 0x79, 0xe7, 0x31, 0xa5,
	0xbc, 0x08, 0x93, 0x82, 0x2e, 0x4f, 0x26, 0x37, 0x14, 0xe3, 0x51, 0x4a, 0x6b, 0xaa, 0xbd, 0x46,
	0x79, 0xef, 0xc5, 0x2d, 0x4f, 0xab, 0xf6, 0x9a, 0x3c, 0x00, 0x19, 0x8d, 0xcd, 0x85, 0xfb, 0x67,
	0xa1, 0xc7, 0xe3, 0x46, 0xf9, 0xb1, 0x04, 0xe3, 0x4b, 0x76, 0x65, 0x4e, 0x75, 0xb4, 0x35, 0xde,
	0x18, 0xb6, 0x50, 0x29, 0xf3, 0x90, 0xc5, 0x43, 0xb8, 0x5e, 0x96, 0x69, 0x55, 0x2b, 0x14, 0xb5,
	0xf0, 0xa4, 0x40, 0x2d, 0x4f, 0xf8, 0xd5, 0x22, 0x66, 0x4e, 0xf9, 0x81, 0x04, 0x07, 0x62, 0x21,
	0x98, 0x8e, 0xf6, 0x41, 0x7f, 0x53, 0x47, 0xc8, 0xce, 0x49, 0x7b, 0x33, 0x87, 0x7a, 0x8b, 0x7d,
	0x4c, 0x4b, 0xc8, 0x96, 0xa7, 0x61, 0x50, 0xc3, 0x34, 0xca, 0x25, 0xc2, 0x5e, 0x49, 0xd3, 0xcb,
	0x44, 0xbc, 0xde, 0xe2, 0x2e, 0xda, 0x45, 0xc8, 0xce, 0xeb, 0x65, 0x5b, 0x3e, 0x06, 0xf2, 0xaa,
	0xaa, 0x57, 0x43, 0xe0, 0x19, 0x0c, 0x3e, 0x40, 0x7a, 0x9a, 0xd0, 0x3e, 0x9d, 0xff, 0x2c, 0x03,
	0xf9, 0x25, 0xbb, 0xb2, 0x68, 0xd8, 0x8e, 0x6a, 0x38, 0xcd, 0x5c, 0x7d, 0x43, 0x6d, 0x18, 0xda,
	0x9a, 0x50, 0xe1, 0x7b, 0x20, 0x4b, 0x93, 0x2d, 0x99, 0x49, 0xfa, 0xe5, 0xce, 0xbe, 0xeb, 0x39,
	0xa5, 0x32, 0x32, 0xcc, 0x9a, 0x97, 0x88, 0xdd, 0x96, 0x05, 0xb7, 0x41, 0x9e, 0x84, 0xbe, 0x3b,
	0x0d, 0xd3, 0xf1, 0xfa, 0x71, 0xf2, 0x2d, 0x02, 0x6e, 0x22, 0x00, 0x45, 0x18, 0xe4, 0x65, 0xe9,
	0x16, 0xf2, 0xe8, 0x40, 0x2d, 0x9c, 0xa2, 0x5f, 0x80, 0x3d, 0x82, 0xf4, 0xdc, 0x42, 0x1e, 0x75,
	0xd9, 0x8a, 0xe4, 0xe6, 0xeb, 0xd0, 0x1f, 0xc8, 0xcb, 0x2d, 0x24, 0xd0, 0xbe, 0x9a, 0x6f, 0x8d,
	0x75, 0x49, 0x60, 0x79, 0x53, 0x7e, 0xcb, 0x13, 0x4c, 0x91, 0xb2, 0x1f, 0x14, 0x71, 0x6f, 0x33,
	0x6a, 0x76, 0x63, 0xd7, 0xa5, 0x60, 0xb7, 0x90, 0x55, 0x47, 0x4e, 0x03, 0x27, 0xef, 0xf6, 0x27,
	0x3b, 0x34, 0x9b, 0x99, 0xc8, 0x6c, 0x4e, 0x42, 0x1f, 0x59, 0xd3, 0x97, 0x5c, 0x13, 0xf0, 0xa6,
	0x9b, 0x34, 0xcd, 0xa9, 0x9e, 0x23, 0x60, 0x00, 0x8c, 0x45, 0xe6, 0xb9, 0x48, 0x91, 0x9e, 0x73,
	0x9b, 0x5c, 0x47, 0xa0, 0x20, 0xb6, 0xa6, 0x56, 0x51, 0x69, 0x55, 0xd5, 0x1c, 0xd3, 0xc2, 0x53,
	0xb7, 0xbd, 0xb8, 0x8b, 0x74, 0x2d, 0xbb, 0x3d, 0xd7, 0x71, 0x87, 0x7c, 0x8d, 0x8d, 0xe9, 0x6c,
	0xd4, 0x11, 0x9e, 0x92, 0x1d, 0xa7, 0xf6, 0xfb, 0xe2, 0x01, 0xdd, 0x65, 0x78, 0xd1, 0xe0, 0x26,
	0xfe, 0xbc, 0xbd, 0x51, 0x47, 0x1e, 0x67, 0xee, 0xdf, 0xf2, 0x22, 0xec, 0xa8, 0xa9, 0xeb, 0xc8,
	0x2a, 0xad, 0x22, 0xe4, 0x2e, 0x5e, 0x50, 0x2b, 0x6b, 0x97, 0x7e, 0x8c, 0x7a, 0x1d, 0xa1, 0xa2,
	0xea, 0x60, 0x52, 0x4e, 0x90, 0x54, 0x6f, 0x0b, 0xa4, 0x1c, 0x3f, 0xa9, 0xe7, 0x61, 0x88, 0xbb,
	0x72, 0x83, 0xf4, 0x04, 0x65, 0x3d, 0xba, 0x6c, 0x7b, 0x09, 0x72, 0xc2, 0x25, 0x5b, 0x5f, 0x0b,
	0x4b, 0xd8, 0x1a, 0x77, 0xbd, 0x26, 0x72, 0xea, 0xfe, 0xad, 0x71, 0xea, 0xed, 0x9b, 0xec, 0xd4,
	0x3b, 0xda, 0x74, 0xea, 0xab, 0x02, 0xa7, 0x3e, 0xc4, 0x71, 0x6a, 0xae, 0x3f, 0x2a, 0x87, 0xe1,
	0x60, 0x02, 0x08, 0x73, 0xef, 0xff, 0xeb, 0x86, 0xa9, 0x26, 0xec, 0x9c, 0x6e, 0xa8, 0xd6, 0xc6,
	0xcd, 0xba, 0xcb, 0x89, 0xfd, 0x48, 0x2e, 0x3e, 0x05, 0xdb, 0x3d, 0xef, 0xdb, 0xa8, 0xad, 0x98,
	0x55, 0xea, 0xe4, 0xd4, 0x6b, 0x97, 0x71, 0x9b, 0x7c, 0x10, 0x76, 0x52, 0xa0, 0xba, 0x65, 0xde,
	0xd5, 0x5d, 0xea, 0xc4, 0xd5, 0x77, 0x90, 0xe6, 0x5b, 0xb4, 0x35, 0xec, 0x9b, 0x5d, 0x6d, 0xfa,
	0x66, 0xab, 0x21, 0x21, 0xea, 0xcb, 0xdd, 0x9b, 0xe7, 0xcb, 0x3d, 0xed, 0xfa, 0xf2, 0x49, 0x18,
	0x42, 0xf7, 0xeb, 0x3a, 0xf6, 0x32, 0xa3, 0xe4, 0xe8, 0x35, 0x64, 0x3b, 0x6a, 0xad, 0x8e, 0x83,
	0x43, 0xa6, 0x38, 0xd8, 0xec, 0xbb, 0xed, 0x75, 0xb9, 0x28, 0x36, 0x72, 0x9c, 0x2a, 0xaa, 0x21,
	0xc3, 0xf1, 0xa1, 0x00, 0x41, 0x69, 0xf6, 0x35, 0x51, 0xd8, 0x66, 0xba, 0xcf, 0xbf, 0x99, 0x0e,
	0x45, 0xee, 0xfe, 0xb4, 0x79, 0x78, 0xfb, 0xd6, 0xb8, 0xec, 0x8e, 0x4d, 0x76, 0xd9, 0x9d, 0x6d,
	0xba, 0xec, 0x82, 0xc0, 0x65, 0x8f, 0x71, 0x5c, 0x56, 0xe8, 0x63, 0xca, 0x71, 0x38, 0x9a, 0x02,
	0x8c, 0xb9, 0xee, 0xaf, 0x03, 0xae, 0x7b, 0xcd, 0x9d, 0xf6, 0x8d, 0xeb, 0x0d, 0xa7, 0x61, 0x21,
	0xfb, 0xf1, 0xcf, 0xce, 0x21, 0x8f, 0xce, 0x6e, 0xae, 0x47, 0x77, 0x8b, 0x3c, 0x7a, 0x0f, 0x64,
	0xb1, 0x7f, 0x6c, 0x60, 0xf7, 0xcb, 0x14, 0xe9, 0x17, 0xc7, 0xd3, 0x7b, 0x37, 0xcf, 0xd3, 0x61,
	0xb3, 0xb3, 0x76, 0xdf, 0xd6, 0x65, 0xed, 0xfe, 0x2d, 0xcb, 0xda, 0x5f, 0x84, 0x80, 0x64, 0x5f,
	0x0d, 0x86, 0x00, 0x21, 0x18, 0x0b, 0x01, 0x6f, 0x49, 0x90, 0x0b, 0xec, 0xab, 0x09, 0xd4, 0x96,
	0x17, 0x02, 0x2e, 0x0a, 0x84, 0xdd, 0xc7, 0x2f, 0x04, 0xf8, 0xb8, 0x52, 0xde, 0x96, 0x60, 0xaf,
	0xa8, 0x33, 0x6d, 0x2d, 0xa0, 0x08, 0xdd, 0x16, 0xb2, 0x1b, 0x55, 0xc7, 0x2b, 0x8e, 0x9d, 0x4a,
	0x92, 0x21, 0x38, 0x88, 0x8b, 0x89, 0x05, 0x92, 0x8a, 0x1e, 0x21, 0xaf, 0xbe, 0x90, 0xe1, 0xd5,
	0x17, 0x7e, 0x2b, 0xc1, 0x1e, 0x3e, 0x15, 0xf9, 0x0a, 0xf4, 0x78, 0x46, 0x49, 0xab, 0x7b, 0xa9,
	0x4c, 0x87, 0x21, 0xc9, 0x17, 0xa1, 0x0b, 0x7b, 0x0a, 0x09, 0xc2, 0xe9, 0xb0, 0x09, 0x86, 0x7c,
	0x16, 0x32, 0xab, 0x08, 0x11, 0x96, 0xd3, 0x21, 0xba, 0xf0, 0xd1, 0xba, 0x09, 0x99, 0x8b, 0x66,
	0x55, 0x33, 0x45, 0x31, 0xe9, 0xa9, 0xa0, 0x0d, 0x1d, 0x8d, 0xd3, 0x7f, 0x93, 0x30, 0xc7, 0x92,
	0x0a, 0x0f, 0x12, 0xea, 0x26, 0x62, 0xe6, 0x94, 0x15, 0x5c, 0x36, 0x11, 0x03, 0x6c, 0x46, 0x69,
	0xe9, 0x17, 0x7e, 0x73, 0x0d, 0xe4, 0xe4, 0x4f, 0x53, 0x4b, 0x97, 0x39, 0x5a, 0x3a, 0x1c, 0xd5,
	0x92, 0x80, 0x3f, 0x05, 0xc1, 0xa1, 0x24, 0x98, 0xcd, 0xd0, 0xd5, 0x7b, 0x12, 0x5e, 0x90, 0xf8,
	0xea, 0x58, 0xbc, 0x59, 0x11, 0x17, 0xe3, 0x16, 0x43, 0xc5, 0xb8, 0x36, 0xf4, 0xe5, 0x95, 0xe4,
	0xae, 0x3e, 0x48, 0x88, 0xc4, 0x49, 0x4c, 0x2a, 0xef, 0x48, 0x38, 0x14, 0x27, 0xc1, 0x3d, 0x8e,
	0xa5, 0xb9, 0xf7, 0x25, 0x5c, 0xff, 0x9e, 0x77, 0x13, 0x73, 0x95, 0x45, 0x70, 0xa1, 0xda, 0x63,
	0x0f, 0xc8, 0x22, 0xc5, 0xf0, 0x0c, 0xa7, 0x18, 0x1e, 0xb4, 0x99, 0x4e, 0x81, 0xcd, 0x74, 0x35,
	0x6d, 0x66, 0x86, 0x33, 0x3d, 0xa3, 0x01, 0x7b, 0x0e, 0xf2, 0xae, 0x8c, 0xe1, 0x62, 0x63, 0xa8,
	0x95, 0xa5, 0xc1, 0x37, 0x49, 0x1a, 0x24, 0x73, 0x15, 0x84, 0x11, 0x5b, 0xdb, 0x15, 0xe8, 0x2c,
	0xab, 0x8e, 0x9a, 0xa6, 0xf0, 0x8b, 0x29, 0x2d, 0xa8, 0x8e, 0x4a, 0xad, 0x0c, 0x23, 0x16, 0xce,
	0x3e, 0x48, 0x48, 0x80, 0x5c, 0x7e, 0x94, 0xeb, 0x38, 0xa0, 0x70, 0xfb, 0x98, 0x31, 0xe5, 0xa0,
	0xdb, 0x6e, 0x68, 0x1a, 0xb2, 0x89, 0x1d, 0xf5, 0x14, 0xbd, 0xcf, 0x60, 0xf0, 0xde, 0x17, 0x24,
	0x14, 0x70, 0xed, 0xad, 0x96, 0xfe, 0x49, 0x8e, 0xf4, 0x47, 0x04, 0xd2, 0x73, 0x18, 0x53, 0x6e,
	0xc2, 0xe1, 0x44, 0xa0, 0x96, 0xf4, 0xf1, 0xe7, 0x6e, 0x18, 0xf2, 0x28, 0x92, 0x73, 0xac, 0x04,
	0x15, 0xa4, 0x3a, 0xe7, 0xb9, 0x02, 0xe3, 0x76, 0xdd, 0x74, 0x4a, 0xcc, 0x43, 0xec, 0x92, 0x63,
	0x96, 0x34, 0xcc, 0x71, 0x49, 0xad, 0x56, 0xa9, 0x3b, 0xe6, 0x6c, 0xb6, 0x3c, 0x58, 0x2c, 0xdb,
	0xb7, 0x4d, 0x22, 0xd2, 0x6c, 0xb5, 0x2a, 0x3f, 0x03, 0x53, 0x65, 0x16, 0x38, 0xc4, 0x64, 0x3a,
	0x31, 0x99, 0x89, 0x72, 0xe8, 0x68, 0x31, 0x44, 0xec, 0x3f, 0x60, 0x37, 0xe6, 0x86, 0xc6, 0x03,
	0x46, 0x22, 0xd7, 0xd5, 0xea, 0x34, 0x4a, 0x45, 0xd9, 0x66, 0x76, 0xe7, 0x0d, 0x21, 0xbf, 0x0c,
	0xa3, 0x3e, 0x66, 0x23, 0xa3, 0x64, 0x5b, 0x1f, 0x25, 0x57, 0x0e, 0xc6, 0xe9, 0xe6, 0x58, 0x1c,
	0x59, 0x70, 0x04, 0xcc, 0x75, 0xb7, 0x7a, 0x12, 0x13, 0x96, 0x05, 0x93, 0x91, 0xeb, 0x22, 0x59,
	0xc8, 0x28, 0x3d, 0xed, 0xa5, 0x18, 0xbe, 0x44, 0x64, 0xc4, 0x3b, 0x30, 0xb9, 0x82, 0x8d, 0xb8,
	0x64, 0x12, 0x2b, 0x8e, 0x6a, 0xb0, 0xb7, 0x75, 0x0d, 0x8e, 0xae, 0x44, 0x1d, 0x83, 0x29, 0xb1,
	0x08, 0x07, 0x43, 0x43, 0x0a, 0x2d, 0x0c, 0xb0, 0x85, 0xed, 0x5b, 0x89, 0xd6, 0x15, 0x42, 0x46,
	0x76, 0x2f, 0x4e, 0x0c, 0xa2, 0xbc, 0xbe, 0x76, 0x95, 0x27, 0x10, 0x06, 0x53, 0x2d, 0x9c, 0xe4,
	0x84, 0x94, 0xf1, 0x48, 0x48, 0xf1, 0xfb, 0xb6, 0xf2, 0x20, 0x0b, 0x63, 0xbc, 0x0e, 0x16, 0x39,
	0xa6, 0x61, 0x10, 0x5b, 0x19, 0x55, 0x44, 0x30, 0x8a, 0xec, 0x72, 0xbb, 0x68, 0x10, 0x26, 0x1d,
	0x72, 0x01, 0x46, 0x7c, 0x56, 0x13, 0xc2, 0xea, 0xc0, 0x58, 0xc3, 0x4d, 0x80, 0x20, 0xee, 0x11,
	0xd8, 0xd5, 0xb4, 0x68, 0x6f, 0x1d, 0x40, 0xe2, 0xc3, 0x4e, 0x66, 0xa0, 0x74, 0x2d, 0x70, 0x0e,
	0x86, 0xc3, 0xd6, 0xe9, 0x61, 0x90, 0x50, 0xb0, 0x3b, 0x64, 0x66, 0x14, 0x6f, 0x16, 0xc6, 0x43,
	0x93, 0x13, 0xe2, 0xb1, 0x0b, 0xf3, 0x98, 0x0f, 0xe8, 0x39, 0xc8, 0xe6, 0x65, 0x18, 0xe5, 0xcd,
	0xaf, 0x37, 0x7c, 0x96, 0x04, 0xb4, 0xe8, 0x44, 0x51, 0x0e, 0xce, 0x43, 0xce, 0x5b, 0xc5, 0xf8,
	0xfd, 0x17, 0xaf, 0x4d, 0xba, 0x09, 0xeb, 0xb4, 0xbf, 0x99, 0xd8, 0xf0, 0x72, 0xe6, 0x2c, 0x0c,
	0xd3, 0xe5, 0x4c, 0x04, 0xaf, 0x07, 0xe3, 0x0d, 0x91, 0xee, 0x10, 0xda, 0x3c, 0x4c, 0x78, 0xe3,
	0x45, 0xfd, 0x19, 0x63, 0xf7, 0x62, 0xec, 0x51, 0x0a, 0x15, 0x32, 0x3c, 0x42, 0x64, 0x16, 0xc6,
	0xe9, 0xd8, 0x02, 0x1a, 0xc4, 0x3b, 0xf2, 0x04, 0x88, 0x4b, 0xe2, 0x9f, 0x41, 0xf1, 0xf8, 0xe0,
	0xbb, 0x07, 0xa6, 0xd3, 0x47, 0xe2, 0x38, 0x85, 0xe4, 0xe4, 0x34, 0x4c, 0xeb, 0x69, 0xd8, 0x47,
	0xd9, 0x89, 0x21, 0xd5, 0x8f, 0x49, 0x51, 0xbe, 0x05, 0x94, 0x7c, 0xf9, 0xef, 0xa7, 0x12, 0x4c,
	0x70, 0xb6, 0x43, 0x69, 0x2a, 0x02, 0x9b, 0xb6, 0x4f, 0xb9, 0xc4, 0xf1, 0xe0, 0x83, 0x71, 0xbb,
	0x39, 0x7f, 0x65, 0xe0, 0x27, 0x12, 0x3c, 0x11, 0x0f, 0x92, 0x76, 0x93, 0xf2, 0x42, 0xb8, 0x3e,
	0x70, 0x21, 0x9d, 0x44, 0x8f, 0x56, 0x25, 0xf8, 0x53, 0x07, 0x8c, 0xc5, 0xd1, 0xfa, 0x1c, 0xd6,
	0x0a, 0xe4, 0x7f, 0x81, 0x1d, 0xf8, 0x12, 0x8d, 0x6e, 0x1a, 0xa5, 0x32, 0xaa, 0x3a, 0x2a, 0x5e,
	0xdd, 0xf7, 0x9d, 0x3a, 0x1c, 0x7b, 0x1b, 0x89, 0x62, 0x2c, 0xb8, 0x08, 0xd4, 0x40, 0xb6, 0xd7,
	0xfd, 0x8d, 0xf2, 0x25, 0xc8, 0xd6, 0xd5, 0x0d, 0xb3, 0xe1, 0xb4, 0x72, 0x42, 0x4f, 0x51, 0x7c,
	0x2a, 0xff, 0x25, 0x59, 0x03, 0x73, 0x76, 0xb6, 0x9f, 0xaa, 0xd9, 0x27, 0xae, 0x85, 0xe3, 0x19,
	0x54, 0x7e, 0x2e, 0xe1, 0xc5, 0x70, 0x3c, 0xd4, 0xe3, 0x6d, 0xfc, 0x7f, 0xa3, 0x95, 0x48, 0x9c,
	0x69, 0x42, 0xca, 0xfa, 0xec, 0x76, 0x9e, 0xac, 0xbb, 0xa6, 0xda, 0xeb, 0xd8, 0xd4, 0xba, 0x68,
	0xf7, 0x92, 0x6a, 0xaf, 0x7b, 0x02, 0x65, 0x9b, 0x02, 0x25, 0xee, 0xe9, 0xb8, 0x02, 0x2a, 0x0a,
	0x29, 0x12, 0xf1, 0xfa, 0xd8, 0x26, 0xf5, 0x7f, 0x3a, 0xf0, 0xdd, 0x56, 0xd1, 0x66, 0xe7, 0x73,
	0xa4, 0xa4, 0x0b, 0x1c, 0x25, 0xed, 0x8f, 0x2a, 0x29, 0x2a, 0xa3, 0x72, 0x00, 0x17, 0x88, 0x44,
	0xdd, 0x4c, 0x55, 0xaf, 0x49, 0xd0, 0xcb, 0x96, 0xc1, 0x41, 0x05, 0x48, 0x49, 0x0a, 0xe8, 0x48,
	0x54, 0x40, 0x26, 0x5e, 0x01, 0x9d, 0x02, 0x05, 0x34, 0xcb, 0x17, 0xca, 0x8f, 0x48, 0xaa, 0xf5,
	0x6d, 0x5e, 0xc3, 0x2b, 0x86, 0xad, 0xdb, 0x77, 0x27, 0xa6, 0xd8, 0x18, 0xae, 0x94, 0x1b, 0x38,
	0xc3, 0xc6, 0x40, 0xb4, 0xb4, 0xe3, 0xfe, 0xdf, 0x0e, 0xd8, 0xbd, 0x64, 0x57, 0x96, 0x99, 0xaa,
	0x6f, 0x5b, 0xaa, 0x61, 0xaf, 0xc6, 0xd8, 0xf2, 0x09, 0x18, 0xb2, 0xcd, 0x86, 0xa5, 0xa1, 0x12,
	0x6f, 0xd2, 0x64, 0xd2, 0xb7, 0xec, 0x9f, 0x3a, 0xbc, 0x1e, 0xb7, 0x1d, 0xdd, 0x20, 0xa7, 0xdd,
	0x3c, 0x63, 0x1f, 0xf6, 0x01, 0x2c, 0xf3, 0xef, 0x68, 0x76, 0xb6, 0x76, 0x47, 0x73, 0x3a, 0xa4,
	0xdf, 0x09, 0xbf, 0x7e, 0xa3, 0xe2, 0x2a, 0x93, 0xb8, 0x8c, 0x1e, 0xed, 0x60, 0x06, 0xfd, 0x6a,
	0x07, 0xbe, 0xc7, 0x79, 0xed, 0xbe, 0x83, 0x2c, 0x43, 0xad, 0xfe, 0xa3, 0xe8, 0xe9, 0x58, 0x48,
	0x4f, 0x81, 0xbb, 0xfd, 0x61, 0x61, 0xe9, 0xdd, 0xfe, 0x70, 0x33, 0xd3, 0xd1, 0xc7, 0x12, 0xae,
	0xdf, 0xdc, 0xd0, 0xef, 0x34, 0x74, 0x7c, 0x0b, 0x99, 0x2e, 0x18, 0x1e, 0xad, 0x7e, 0x13, 0x08,
	0x1e, 0x99, 0x50, 0xf0, 0x60, 0x0b, 0x80, 0xce, 0xf6, 0x16, 0x00, 0x92, 0xb7, 0x00, 0x38, 0x1e,
	0xb7, 0x6b, 0x8d, 0x48, 0xa4, 0x4c, 0xe0, 0x4d, 0x6b, 0xa4, 0x9d, 0xa9, 0xe2, 0x0d, 0x92, 0x4c,
	0xaf, 0xd5, 0x90, 0x55, 0x41, 0x86, 0xb6, 0xb1, 0x8c, 0xef, 0x67, 0xd0, 0x57, 0x0e, 0x5b, 0xa6,
	0x8e, 0xc2, 0xc9, 0xb8, 0xc4, 0xc7, 0x65, 0x86, 0x26, 0x3e, 0x6e, 0x5f, 0xf3, 0xfe, 0x78, 0x07,
	0x7e, 0xb4, 0xb1, 0x68, 0xb8, 0x9b, 0x22, 0x9b, 0x49, 0x4b, 0x8e, 0x8c, 0x1f, 0x13, 0x17, 0x08,
	0xe8, 0xa5, 0x33, 0x64, 0x26, 0x97, 0x98, 0x7f, 0xb4, 0xb2, 0x58, 0xa5, 0x3e, 0x72, 0x2a, 0xa4,
	0x54, 0x25, 0x78, 0x1e, 0xcc, 0xd3, 0x09, 0x7d, 0x6c, 0xc0, 0xef, 0x0c, 0xab, 0x75, 0x01, 0x7d,
	0xa1, 0xd6, 0xb0, 0x5a, 0xf9, 0x3a, 0xa1, 0x6a, 0xe5, 0x77, 0x32, 0xb5, 0xbe, 0x27, 0x61, 0xe7,
	0xbc, 0x65, 0xe9, 0x77, 0xf5, 0x2a, 0xaa, 0xa0, 0xf2, 0xb5, 0xfb, 0x48, 0x6b, 0x38, 0x68, 0xde,
	0x34, 0x1c, 0x4b, 0xd5, 0xc4, 0xfe, 0x37, 0x04, 0x5d, 0xab, 0x0d, 0xa3, 0x6c, 0x53, 0x55, 0x92,
	0x0f, 0xf9, 0x30, 0x0c, 0x68, 0x14, 0xb3, 0xa4, 0x92, 0xb7, 0x1e, 0x54, 0x69, 0x3b, 0xbd, 0x76,
	0xfa, 0x04, 0x44, 0x96, 0xe9, 0xd2, 0x80, 0xe8, 0x89, 0x64, 0xfb, 0xcb, 0x82, 0x83, 0xf6, 0x03,
	0x7e, 0x71, 0x85, 0xbc, 0xba, 0x81, 0x64, 0x7f, 0x1c, 0x00, 0x4b, 0xf7, 0x2f, 0x03, 0x60, 0x7e,
	0x4b, 0x65, 0x7d, 0x75, 0x15, 0x67, 0xfc, 0xd8, 0x34, 0x70, 0xc2, 0x9d, 0xaa, 0x37, 0xff, 0x30,
	0x79, 0xa8, 0xa2, 0x3b, 0x6b, 0x8d, 0x95, 0x69, 0xcd, 0xac, 0xd1, 0xc7, 0x7e, 0xf4, 0xbf, 0xe3,
	0x76, 0x79, 0x7d, 0xc6, 0xd9, 0xa8, 0x23, 0x1b, 0x23, 0xd8, 0xc5, 0x5e, 0x4c, 0x7e, 0x41, 0x5f,
	0x5d, 0x2d, 0x0c, 0x72, 0x64, 0x52, 0x5e, 0x82, 0x81, 0x25, 0xbb, 0x52, 0x44, 0xf7, 0x54, 0xab,
	0x6c, 0xdf, 0xac, 0x3b, 0x37, 0x1b, 0x42, 0x4d, 0x93, 0x3a, 0x21, 0x47, 0x29, 0x23, 0x7e, 0xa5,
	0x04, 0x48, 0x29, 0x79, 0x1c, 0x50, 0x03, 0x6d, 0xfe, 0xf7, 0x2d, 0xbb, 0x71, 0xa7, 0x56, 0x55,
	0xf5, 0xda, 0x0d, 0x53, 0x5b, 0x47, 0xe5, 0xeb, 0x78, 0xf2, 0xc4, 0x4e, 0x34, 0x58, 0xc5, 0x60,
	0xb3, 0xc4, 0xd2, 0x6f, 0x35, 0x56, 0x9e, 0x41, 0x1b, 0x78, 0xe2, 0xfb, 0x8b, 0xbc, 0x2e, 0x79,
	0x0c, 0x7a, 0x6d, 0xbd, 0x62, 0xa8, 0x4e, 0xc3, 0x22, 0x9b, 0xf0, 0xfe, 0x62, 0xb3, 0x21, 0x7e,
	0xbd, 0x11, 0xe5, 0x8b, 0xae, 0x37, 0xa2, 0x1d, 0x4c, 0xa4, 0xff, 0x26, 0x4f, 0x5d, 0x96, 0xf5,
	0x8a, 0x81, 0x97, 0xd0, 0xcb, 0x90, 0x75, 0xff, 0xa6, 0x82, 0xf4, 0xcf, 0x5d, 0xfa, 0xe4, 0xe1,
	0x64, 0xd6, 0xc6, 0x2d, 0x7f, 0x7d, 0x38, 0x79, 0x3c, 0xc5, 0x2c, 0xce, 0x6a, 0x1a, 0xb5, 0xd3,
	0x22, 0x25, 0x25, 0x8f, 0x41, 0xe7, 0x02, 0x59, 0xca, 0xba, 0x24, 0x7b, 0x3e, 0x79, 0x38, 0x89,
	0x6d, 0xb6, 0x88, 0x5b, 0x95, 0xfb, 0xf8, 0xd1, 0x10, 0xe6, 0xc0, 0xd4, 0xe4, 0x03, 0x44, 0x7e,
	0x72, 0xd9, 0x8b, 0xd4, 0x3e, 0x30, 0x82, 0xfb, 0x5d, 0xec, 0x71, 0xbb, 0xf0, 0x75, 0xae, 0x79,
	0xe8, 0xba, 0xab, 0x56, 0x1b, 0x88, 0xee, 0x5c, 0x0f, 0xc6, 0x25, 0x64, 0x9f, 0x7c, 0xde, 0x6e,
	0x1c, 0xe3, 0x2a, 0x5f, 0xce, 0x60, 0x3f, 0x9f, 0x2d, 0xd7, 0x74, 0x83, 0xd4, 0x84, 0x39, 0x5b,
	0xea, 0xf6, 0xb6, 0x5b, 0xcf, 0xc2, 0x80, 0xef, 0x1e, 0x25, 0xa9, 0xc5, 0x34, 0x4b, 0x2a, 0x52,
	0x52, 0xf0, 0xda, 0xd9, 0x44, 0xc6, 0xd7, 0x9b, 0x84, 0x57, 0x39, 0x3b, 0x5b, 0xbf, 0xca, 0xd9,
	0x25, 0xbe, 0xca, 0x79, 0x15, 0xb2, 0xb6, 0xa3, 0x3a, 0x0d, 0x9b, 0x5e, 0xb3, 0x3b, 0x14, 0xab,
	0x56, 0x2c, 0xeb, 0x32, 0x86, 0x2f, 0x52, 0xbc, 0x42, 0x21, 0xae, 0xb8, 0x11, 0xaf, 0x68, 0xe5,
	0x28, 0xae, 0x6d, 0xc4, 0x03, 0x31, 0xc3, 0xfd, 0x0e, 0x79, 0xd8, 0x34, 0x4b, 0x1e, 0xad, 0xbd,
	0x82, 0x96, 0x1d, 0x75, 0x1d, 0x3d, 0x65, 0xa9, 0x86, 0x23, 0xf6, 0xc6, 0xeb, 0x90, 0xad, 0x60,
	0x08, 0xba, 0xa9, 0x9a, 0x8e, 0x13, 0x0f, 0xd3, 0xf2, 0xc8, 0x63, 0xd5, 0x16, 0x29, 0x76, 0xe1,
	0x44, 0xdc, 0xab, 0x26, 0x1e, 0x47, 0xca, 0x3e, 0xfc, 0x34, 0x82, 0xd7, 0xc5, 0x04, 0xda, 0xc0,
	0xb1, 0x65, 0xd6, 0xe5, 0x46, 0x75, 0x7c, 0x10, 0x42, 0x69, 0x72, 0xd0, 0x8d, 0xf9, 0x61, 0xd7,
	0x32, 0xbd, 0xcf, 0xf8, 0x28, 0x11, 0x1d, 0x81, 0x46, 0x89, 0x68, 0x87, 0xc7, 0xdb, 0xa9, 0x5f,
	0x1d, 0x84, 0xcc, 0x92, 0x5d, 0x91, 0x55, 0xe8, 0xf6, 0x1e, 0xf7, 0x3d, 0x91, 0xe0, 0x71, 0x14,
	0x2e, 0x3f, 0x9d, 0x0e, 0x8e, 0xe5, 0x97, 0x32, 0xf4, 0xb0, 0x77, 0x77, 0x49, 0x5e, 0xed, 0x01,
	0xe6, 0x67, 0x52, 0x02, 0xb2, 0x51, 0xbe, 0x26, 0xc1, 0xb0, 0xe8, 0x41, 0xd2, 0xb9, 0x04, 0x62,
	0x02, 0xbc, 0xfc, 0x93, 0xed, 0xe1, 0x31, 0x9e, 0x5e, 0x97, 0x60, 0x2c, 0xf6, 0xf1, 0xcc, 0xa5,
	0x74, 0x03, 0x70, 0x91, 0xf3, 0xf3, 0x8f, 0x80, 0xcc, 0x58, 0xfc, 0xae, 0x04, 0x7b, 0x13, 0x6f,
	0x11, 0x5f, 0x49, 0x37, 0x92, 0x90, 0x40, 0xfe, 0xa9, 0x47, 0x24, 0xc0, 0xd8, 0x7d, 0x20, 0xc1,
	0x10, 0xf7, 0xe5, 0xe3, 0xe9, 0x84, 0x11, 0x78, 0x48, 0xf9, 0x4b, 0x6d, 0x20, 0x31, 0x56, 0xbe,
	0x29, 0x41, 0x3e, 0xe6, 0xd5, 0xe1, 0xc5, 0x04, 0xda, 0x62, 0xd4, 0xfc, 0x6c, 0xdb, 0xa8, 0x8c,
	0xb9, 0x2f, 0x49, 0xb0, 0x9b, 0x7f, 0x33, 0xf4, 0x4c, 0x6a, 0x99, 0x7d, 0x58, 0xf9, 0x7f, 0x6a,
	0x07, 0x8b, 0x71, 0xb3, 0x01, 0x3b, 0xc3, 0x17, 0x92, 0x92, 0x82, 0x48, 0x08, 0x3e, 0x7f, 0xae,
	0x35, 0xf8, 0x80, 0x22, 0xf8, 0x77, 0x83, 0xce, 0xa4, 0xd2, 0x72, 0x08, 0x2b, 0x51, 0x11, 0xf1,
	0x77, 0x7b, 0xfe, 0x0b, 0x76, 0x45, 0xef, 0xa8, 0x9c, 0x48, 0x43, 0xd2, 0x8f, 0x91, 0xbf, 0xd0,
	0x2a, 0x06, 0x63, 0xe0, 0x1b, 0x12, 0x8c, 0x88, 0xb7, 0x37, 0x49, 0x74, 0x85, 0x98, 0xf9, 0xab,
	0xed, 0x62, 0x06, 0xdc, 0x29, 0xe6, 0x32, 0xea, 0xc5, 0x54, 0x06, 0xc8, 0x43, 0x4d, 0x74, 0xa7,
	0x14, 0x97, 0x48, 0xdd, 0x28, 0x99, 0x78, 0xb5, 0xf1, 0x4a, 0x7a, 0xb7, 0xe5, 0x12, 0x48, 0x8c,
	0x92, 0xa9, 0xef, 0x23, 0xbe, 0x26, 0xc1, 0x68, 0xdc, 0x59, 0x70, 0xa1, 0x45, 0x8d, 0xf8, 0x23,
	0xc1, 0x5c, 0xfb, 0xb8, 0xc1, 0xe8, 0xc4, 0x3d, 0x2d, 0x3a, 0x93, 0xca, 0xcd, 0x43, 0x58, 0xc9,
	0xd1, 0x29, 0xee, 0x70, 0x06, 0x6b, 0x2b, 0xae, 0x9c, 0x5f, 0x48, 0xef, 0xf2, 0x61, 0xdc, 0x44,
	0x6d, 0xa5, 0x29, 0xc7, 0xfb, 0x52, 0xb4, 0xf8, 0x8d, 0x5e, 0xca, 0x14, 0x2d, 0x24, 0x90, 0x36,
	0x45, 0x27, 0x3e, 0x4d, 0x92, 0xbf, 0x25, 0xc1, 0x78, 0xfc, 0x95, 0xe9, 0x74, 0xc9, 0x44, 0x80,
	0x9d, 0x5f, 0x78, 0x14, 0x6c, 0xc6, 0xe5, 0xb7, 0x25, 0x98, 0x48, 0x38, 0x3a, 0xbe, 0xdc, 0xfa,
	0x40, 0x7e, 0x47, 0xb9, 0xf6, 0x48, 0xe8, 0x8c, 0xd1, 0xaf, 0x4b, 0x90, 0x13, 0x9e, 0x1b, 0x9e,
	0x4f, 0x65, 0xf8, 0x51, 0xc4, 0xfc, 0x95, 0x36, 0x11, 0x03, 0xfa, 0x4b, 0xb8, 0x7e, 0x7a, 0x39,
	0xbd, 0xed, 0x73, 0xd0, 0x13, 0xf5, 0x97, 0xf2, 0xfa, 0xe8, 0xab, 0x12, 0xc8, 0x9c, 0x53, 0xaa,
	0x93, 0x49, 0xe5, 0x85, 0x08, 0x4a, 0xfe, 0x62, 0xcb, 0x28, 0x8c, 0x89, 0xff, 0x84, 0x81, 0xc8,
	0xf9, 0x4f, 0xd2, 0x0e, 0x27, 0x8c, 0x90, 0x3f, 0xdf, 0x22, 0x82, 0x7f, 0xd5, 0x11, 0x3d, 0x59,
	0x49, 0x5a, 0x75, 0x44, 0x30, 0x12, 0x57, 0x1d, 0xc2, 0x33, 0x0d, 0x1c, 0xef, 0xf9, 0x07, 0x1a,
	0x49, 0xf1, 0x9e, 0x8b, 0x95, 0x18, 0xef, 0x63, 0xcf, 0x24, 0xe4, 0xaf, 0x48, 0xb0, 0x47, 0x70,
	0x20, 0x71, 0x36, 0x31, 0x08, 0xf2, 0xd0, 0xf2, 0x97, 0xdb, 0x42, 0x0b, 0x30, 0x24, 0x28, 0xe5,
	0x9f, 0x4d, 0xdc, 0x6b, 0xb7, 0xc5, 0x50, 0x7c, 0x1d, 0x5c, 0xb6, 0x61, 0x7b, 0xb0, 0x1a, 0x7b,
	0x2c, 0x81, 0x5e, 0x00, 0x3a, 0x7f, 0xa6, 0x15, 0xe8, 0x40, 0x44, 0x49, 0xa8, 0xdb, 0x25, 0x89,
	0x15, 0x8f, 0x9e, 0x18, 0x51, 0xd2, 0xd5, 0xa9, 0xe4, 0x3a, 0xf4, 0x07, 0x7e, 0xe5, 0xe9, 0x68,
	0x02, 0x59, 0x3f, 0x70, 0xfe, 0x74, 0x0b, 0xc0, 0xfe, 0xf0, 0x11, 0xf9, 0xfd, 0xba, 0x99, 0x54,
	0x84, 0x9a, 0x08, 0x89, 0xe1, 0x43, 0xf4, 0xc3, 0x6b, 0xd8, 0x3c, 0x05, 0xbf, 0xba, 0x76, 0x36,
	0x15, 0xcd, 0x30, 0x5a, 0xa2, 0x79, 0xc6, 0xff, 0xd4, 0x16, 0x2e, 0x02, 0x70, 0xab, 0x84, 0x49,
	0xca, 0xe5, 0x21, 0x25, 0x16, 0x01, 0xe2, 0x4a, 0x7c, 0x38, 0xbb, 0x70, 0x0a, 0x7c, 0x49, 0xd9,
	0x25, 0x8a, 0x92, 0x98, 0x5d, 0xc4, 0xb5, 0xbc, 0xb9, 0xb5, 0x77, 0x3f, 0x98, 0x90, 0xde, 0xff,
	0x60, 0x42, 0xfa, 0xe3, 0x07, 0x13, 0xd2, 0x57, 0x3f, 0x9c, 0xd8, 0xf6, 0xfe, 0x87, 0x13, 0xdb,
	0x7e, 0xf7, 0xe1, 0xc4, 0xb6, 0x7f, 0x7f, 0xd6, 0x57, 0xdd, 0x5f, 0xf4, 0xc8, 0xdf, 0x50, 0x57,
	0xec, 0x19, 0x36, 0xd8, 0x71, 0xcd, 0xb4, 0x90, 0xff, 0x73, 0x4d, 0xd5, 0x8d, 0x99, 0x9a, 0x59,
	0x6e, 0x54, 0x91, 0xdd, 0xfc, 0x5d, 0x46, 0x7c, 0x12, 0xb0, 0x92, 0xc5, 0xbf, 0xa9, 0x78, 0xfa,
	0xef, 0x01, 0x00, 0x00, 0xff, 0xff, 0x80, 0xf5, 0x7b, 0xe9, 0x95, 0x52, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Deposit defines a method for transferring coins from the sender's bank
	// balance into the subaccount's exchange deposits
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error)
	// Withdraw defines a method for withdrawing coins from a subaccount's
	// deposits to the user's bank balance
	Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error)
	// InstantSpotMarketLaunch defines method for creating a spot market by paying
	// listing fee without governance
	InstantSpotMarketLaunch(ctx context.Context, in *MsgInstantSpotMarketLaunch, opts ...grpc.CallOption) (*MsgInstantSpotMarketLaunchResponse, error)
	// InstantPerpetualMarketLaunch defines a method for creating a new perpetual
	// futures market by paying listing fee without governance
	InstantPerpetualMarketLaunch(ctx context.Context, in *MsgInstantPerpetualMarketLaunch, opts ...grpc.CallOption) (*MsgInstantPerpetualMarketLaunchResponse, error)
	// InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry
	// futures market by paying listing fee without governance
	InstantExpiryFuturesMarketLaunch(ctx context.Context, in *MsgInstantExpiryFuturesMarketLaunch, opts ...grpc.CallOption) (*MsgInstantExpiryFuturesMarketLaunchResponse, error)
	// CreateSpotLimitOrder defines a method for creating a new spot limit order.
	CreateSpotLimitOrder(ctx context.Context, in *MsgCreateSpotLimitOrder, opts ...grpc.CallOption) (*MsgCreateSpotLimitOrderResponse, error)
	// BatchCreateSpotLimitOrder defines a method for creating a new batch of spot
	// limit orders.
	BatchCreateSpotLimitOrders(ctx context.Context, in *MsgBatchCreateSpotLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateSpotLimitOrdersResponse, error)
	// CreateSpotMarketOrder defines a method for creating a new spot market
	// order.
	CreateSpotMarketOrder(ctx context.Context, in *MsgCreateSpotMarketOrder, opts ...grpc.CallOption) (*MsgCreateSpotMarketOrderResponse, error)
	// MsgCancelSpotOrder defines a method for cancelling a spot order.
	CancelSpotOrder(ctx context.Context, in *MsgCancelSpotOrder, opts ...grpc.CallOption) (*MsgCancelSpotOrderResponse, error)
	// BatchCancelSpotOrders defines a method for cancelling a batch of spot
	// orders in a given market.
	BatchCancelSpotOrders(ctx context.Context, in *MsgBatchCancelSpotOrders, opts ...grpc.CallOption) (*MsgBatchCancelSpotOrdersResponse, error)
	// BatchUpdateOrders defines a method for updating a batch of orders.
	BatchUpdateOrders(ctx context.Context, in *MsgBatchUpdateOrders, opts ...grpc.CallOption) (*MsgBatchUpdateOrdersResponse, error)
	// PrivilegedExecuteContract defines a method for executing a Cosmwasm
	// contract from the exchange module with privileged capabilities.
	PrivilegedExecuteContract(ctx context.Context, in *MsgPrivilegedExecuteContract, opts ...grpc.CallOption) (*MsgPrivilegedExecuteContractResponse, error)
	// CreateDerivativeLimitOrder defines a method for creating a new derivative
	// limit order.
	CreateDerivativeLimitOrder(ctx context.Context, in *MsgCreateDerivativeLimitOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeLimitOrderResponse, error)
	// BatchCreateDerivativeLimitOrders defines a method for creating a new batch
	// of derivative limit orders.
	BatchCreateDerivativeLimitOrders(ctx context.Context, in *MsgBatchCreateDerivativeLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateDerivativeLimitOrdersResponse, error)
	// MsgCreateDerivativeLimitOrder defines a method for creating a new
	// derivative market order.
	CreateDerivativeMarketOrder(ctx context.Context, in *MsgCreateDerivativeMarketOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeMarketOrderResponse, error)
	// MsgCancelDerivativeOrder defines a method for cancelling a derivative
	// order.
	CancelDerivativeOrder(ctx context.Context, in *MsgCancelDerivativeOrder, opts ...grpc.CallOption) (*MsgCancelDerivativeOrderResponse, error)
	// MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of
	// derivative limit orders.
	BatchCancelDerivativeOrders(ctx context.Context, in *MsgBatchCancelDerivativeOrders, opts ...grpc.CallOption) (*MsgBatchCancelDerivativeOrdersResponse, error)
	// InstantBinaryOptionsMarketLaunch defines method for creating a binary
	// options market by paying listing fee without governance
	InstantBinaryOptionsMarketLaunch(ctx context.Context, in *MsgInstantBinaryOptionsMarketLaunch, opts ...grpc.CallOption) (*MsgInstantBinaryOptionsMarketLaunchResponse, error)
	// CreateBinaryOptionsLimitOrder defines a method for creating a new binary
	// options limit order.
	CreateBinaryOptionsLimitOrder(ctx context.Context, in *MsgCreateBinaryOptionsLimitOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsLimitOrderResponse, error)
	// CreateBinaryOptionsMarketOrder defines a method for creating a new binary
	// options market order.
	CreateBinaryOptionsMarketOrder(ctx context.Context, in *MsgCreateBinaryOptionsMarketOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsMarketOrderResponse, error)
	// MsgCancelBinaryOptionsOrder defines a method for cancelling a binary
	// options order.
	CancelBinaryOptionsOrder(ctx context.Context, in *MsgCancelBinaryOptionsOrder, opts ...grpc.CallOption) (*MsgCancelBinaryOptionsOrderResponse, error)
	// BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of
	// binary options limit orders.
	BatchCancelBinaryOptionsOrders(ctx context.Context, in *MsgBatchCancelBinaryOptionsOrders, opts ...grpc.CallOption) (*MsgBatchCancelBinaryOptionsOrdersResponse, error)
	// SubaccountTransfer defines a method for transfer between subaccounts
	SubaccountTransfer(ctx context.Context, in *MsgSubaccountTransfer, opts ...grpc.CallOption) (*MsgSubaccountTransferResponse, error)
	// ExternalTransfer defines a method for transfer between external accounts
	ExternalTransfer(ctx context.Context, in *MsgExternalTransfer, opts ...grpc.CallOption) (*MsgExternalTransferResponse, error)
	// LiquidatePosition defines a method for liquidating a position
	LiquidatePosition(ctx context.Context, in *MsgLiquidatePosition, opts ...grpc.CallOption) (*MsgLiquidatePositionResponse, error)
	// EmergencySettleMarket defines a method for emergency settling a market
	EmergencySettleMarket(ctx context.Context, in *MsgEmergencySettleMarket, opts ...grpc.CallOption) (*MsgEmergencySettleMarketResponse, error)
	// IncreasePositionMargin defines a method for increasing margin of a position
	IncreasePositionMargin(ctx context.Context, in *MsgIncreasePositionMargin, opts ...grpc.CallOption) (*MsgIncreasePositionMarginResponse, error)
	// DecreasePositionMargin defines a method for decreasing margin of a position
	DecreasePositionMargin(ctx context.Context, in *MsgDecreasePositionMargin, opts ...grpc.CallOption) (*MsgDecreasePositionMarginResponse, error)
	// RewardsOptOut defines a method for opting out of rewards
	RewardsOptOut(ctx context.Context, in *MsgRewardsOptOut, opts ...grpc.CallOption) (*MsgRewardsOptOutResponse, error)
	// AdminUpdateBinaryOptionsMarket defines method for updating a binary options
	// market by admin
	AdminUpdateBinaryOptionsMarket(ctx context.Context, in *MsgAdminUpdateBinaryOptionsMarket, opts ...grpc.CallOption) (*MsgAdminUpdateBinaryOptionsMarketResponse, error)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// UpdateSpotMarket modifies certain spot market fields (admin only)
	UpdateSpotMarket(ctx context.Context, in *MsgUpdateSpotMarket, opts ...grpc.CallOption) (*MsgUpdateSpotMarketResponse, error)
	// UpdateDerivativeMarket modifies certain derivative market fields (admin
	// only)
	UpdateDerivativeMarket(ctx context.Context, in *MsgUpdateDerivativeMarket, opts ...grpc.CallOption) (*MsgUpdateDerivativeMarketResponse, error)
	AuthorizeStakeGrants(ctx context.Context, in *MsgAuthorizeStakeGrants, opts ...grpc.CallOption) (*MsgAuthorizeStakeGrantsResponse, error)
	ActivateStakeGrant(ctx context.Context, in *MsgActivateStakeGrant, opts ...grpc.CallOption) (*MsgActivateStakeGrantResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error) {
	out := new(MsgDepositResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error) {
	out := new(MsgWithdrawResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/Withdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantSpotMarketLaunch(ctx context.Context, in *MsgInstantSpotMarketLaunch, opts ...grpc.CallOption) (*MsgInstantSpotMarketLaunchResponse, error) {
	out := new(MsgInstantSpotMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantSpotMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantPerpetualMarketLaunch(ctx context.Context, in *MsgInstantPerpetualMarketLaunch, opts ...grpc.CallOption) (*MsgInstantPerpetualMarketLaunchResponse, error) {
	out := new(MsgInstantPerpetualMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantPerpetualMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantExpiryFuturesMarketLaunch(ctx context.Context, in *MsgInstantExpiryFuturesMarketLaunch, opts ...grpc.CallOption) (*MsgInstantExpiryFuturesMarketLaunchResponse, error) {
	out := new(MsgInstantExpiryFuturesMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantExpiryFuturesMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSpotLimitOrder(ctx context.Context, in *MsgCreateSpotLimitOrder, opts ...grpc.CallOption) (*MsgCreateSpotLimitOrderResponse, error) {
	out := new(MsgCreateSpotLimitOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateSpotLimitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCreateSpotLimitOrders(ctx context.Context, in *MsgBatchCreateSpotLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateSpotLimitOrdersResponse, error) {
	out := new(MsgBatchCreateSpotLimitOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCreateSpotLimitOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSpotMarketOrder(ctx context.Context, in *MsgCreateSpotMarketOrder, opts ...grpc.CallOption) (*MsgCreateSpotMarketOrderResponse, error) {
	out := new(MsgCreateSpotMarketOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateSpotMarketOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelSpotOrder(ctx context.Context, in *MsgCancelSpotOrder, opts ...grpc.CallOption) (*MsgCancelSpotOrderResponse, error) {
	out := new(MsgCancelSpotOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CancelSpotOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelSpotOrders(ctx context.Context, in *MsgBatchCancelSpotOrders, opts ...grpc.CallOption) (*MsgBatchCancelSpotOrdersResponse, error) {
	out := new(MsgBatchCancelSpotOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCancelSpotOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchUpdateOrders(ctx context.Context, in *MsgBatchUpdateOrders, opts ...grpc.CallOption) (*MsgBatchUpdateOrdersResponse, error) {
	out := new(MsgBatchUpdateOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchUpdateOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PrivilegedExecuteContract(ctx context.Context, in *MsgPrivilegedExecuteContract, opts ...grpc.CallOption) (*MsgPrivilegedExecuteContractResponse, error) {
	out := new(MsgPrivilegedExecuteContractResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/PrivilegedExecuteContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDerivativeLimitOrder(ctx context.Context, in *MsgCreateDerivativeLimitOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeLimitOrderResponse, error) {
	out := new(MsgCreateDerivativeLimitOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateDerivativeLimitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCreateDerivativeLimitOrders(ctx context.Context, in *MsgBatchCreateDerivativeLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateDerivativeLimitOrdersResponse, error) {
	out := new(MsgBatchCreateDerivativeLimitOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCreateDerivativeLimitOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDerivativeMarketOrder(ctx context.Context, in *MsgCreateDerivativeMarketOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeMarketOrderResponse, error) {
	out := new(MsgCreateDerivativeMarketOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateDerivativeMarketOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelDerivativeOrder(ctx context.Context, in *MsgCancelDerivativeOrder, opts ...grpc.CallOption) (*MsgCancelDerivativeOrderResponse, error) {
	out := new(MsgCancelDerivativeOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CancelDerivativeOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelDerivativeOrders(ctx context.Context, in *MsgBatchCancelDerivativeOrders, opts ...grpc.CallOption) (*MsgBatchCancelDerivativeOrdersResponse, error) {
	out := new(MsgBatchCancelDerivativeOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCancelDerivativeOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantBinaryOptionsMarketLaunch(ctx context.Context, in *MsgInstantBinaryOptionsMarketLaunch, opts ...grpc.CallOption) (*MsgInstantBinaryOptionsMarketLaunchResponse, error) {
	out := new(MsgInstantBinaryOptionsMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantBinaryOptionsMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBinaryOptionsLimitOrder(ctx context.Context, in *MsgCreateBinaryOptionsLimitOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsLimitOrderResponse, error) {
	out := new(MsgCreateBinaryOptionsLimitOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsLimitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBinaryOptionsMarketOrder(ctx context.Context, in *MsgCreateBinaryOptionsMarketOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsMarketOrderResponse, error) {
	out := new(MsgCreateBinaryOptionsMarketOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsMarketOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelBinaryOptionsOrder(ctx context.Context, in *MsgCancelBinaryOptionsOrder, opts ...grpc.CallOption) (*MsgCancelBinaryOptionsOrderResponse, error) {
	out := new(MsgCancelBinaryOptionsOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CancelBinaryOptionsOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelBinaryOptionsOrders(ctx context.Context, in *MsgBatchCancelBinaryOptionsOrders, opts ...grpc.CallOption) (*MsgBatchCancelBinaryOptionsOrdersResponse, error) {
	out := new(MsgBatchCancelBinaryOptionsOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCancelBinaryOptionsOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubaccountTransfer(ctx context.Context, in *MsgSubaccountTransfer, opts ...grpc.CallOption) (*MsgSubaccountTransferResponse, error) {
	out := new(MsgSubaccountTransferResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/SubaccountTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ExternalTransfer(ctx context.Context, in *MsgExternalTransfer, opts ...grpc.CallOption) (*MsgExternalTransferResponse, error) {
	out := new(MsgExternalTransferResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/ExternalTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LiquidatePosition(ctx context.Context, in *MsgLiquidatePosition, opts ...grpc.CallOption) (*MsgLiquidatePositionResponse, error) {
	out := new(MsgLiquidatePositionResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/LiquidatePosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) EmergencySettleMarket(ctx context.Context, in *MsgEmergencySettleMarket, opts ...grpc.CallOption) (*MsgEmergencySettleMarketResponse, error) {
	out := new(MsgEmergencySettleMarketResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/EmergencySettleMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IncreasePositionMargin(ctx context.Context, in *MsgIncreasePositionMargin, opts ...grpc.CallOption) (*MsgIncreasePositionMarginResponse, error) {
	out := new(MsgIncreasePositionMarginResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/IncreasePositionMargin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DecreasePositionMargin(ctx context.Context, in *MsgDecreasePositionMargin, opts ...grpc.CallOption) (*MsgDecreasePositionMarginResponse, error) {
	out := new(MsgDecreasePositionMarginResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/DecreasePositionMargin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RewardsOptOut(ctx context.Context, in *MsgRewardsOptOut, opts ...grpc.CallOption) (*MsgRewardsOptOutResponse, error) {
	out := new(MsgRewardsOptOutResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/RewardsOptOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AdminUpdateBinaryOptionsMarket(ctx context.Context, in *MsgAdminUpdateBinaryOptionsMarket, opts ...grpc.CallOption) (*MsgAdminUpdateBinaryOptionsMarketResponse, error) {
	out := new(MsgAdminUpdateBinaryOptionsMarketResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/AdminUpdateBinaryOptionsMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateSpotMarket(ctx context.Context, in *MsgUpdateSpotMarket, opts ...grpc.CallOption) (*MsgUpdateSpotMarketResponse, error) {
	out := new(MsgUpdateSpotMarketResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/UpdateSpotMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDerivativeMarket(ctx context.Context, in *MsgUpdateDerivativeMarket, opts ...grpc.CallOption) (*MsgUpdateDerivativeMarketResponse, error) {
	out := new(MsgUpdateDerivativeMarketResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/UpdateDerivativeMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AuthorizeStakeGrants(ctx context.Context, in *MsgAuthorizeStakeGrants, opts ...grpc.CallOption) (*MsgAuthorizeStakeGrantsResponse, error) {
	out := new(MsgAuthorizeStakeGrantsResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/AuthorizeStakeGrants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ActivateStakeGrant(ctx context.Context, in *MsgActivateStakeGrant, opts ...grpc.CallOption) (*MsgActivateStakeGrantResponse, error) {
	out := new(MsgActivateStakeGrantResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/ActivateStakeGrant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Deposit defines a method for transferring coins from the sender's bank
	// balance into the subaccount's exchange deposits
	Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error)
	// Withdraw defines a method for withdrawing coins from a subaccount's
	// deposits to the user's bank balance
	Withdraw(context.Context, *MsgWithdraw) (*MsgWithdrawResponse, error)
	// InstantSpotMarketLaunch defines method for creating a spot market by paying
	// listing fee without governance
	InstantSpotMarketLaunch(context.Context, *MsgInstantSpotMarketLaunch) (*MsgInstantSpotMarketLaunchResponse, error)
	// InstantPerpetualMarketLaunch defines a method for creating a new perpetual
	// futures market by paying listing fee without governance
	InstantPerpetualMarketLaunch(context.Context, *MsgInstantPerpetualMarketLaunch) (*MsgInstantPerpetualMarketLaunchResponse, error)
	// InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry
	// futures market by paying listing fee without governance
	InstantExpiryFuturesMarketLaunch(context.Context, *MsgInstantExpiryFuturesMarketLaunch) (*MsgInstantExpiryFuturesMarketLaunchResponse, error)
	// CreateSpotLimitOrder defines a method for creating a new spot limit order.
	CreateSpotLimitOrder(context.Context, *MsgCreateSpotLimitOrder) (*MsgCreateSpotLimitOrderResponse, error)
	// BatchCreateSpotLimitOrder defines a method for creating a new batch of spot
	// limit orders.
	BatchCreateSpotLimitOrders(context.Context, *MsgBatchCreateSpotLimitOrders) (*MsgBatchCreateSpotLimitOrdersResponse, error)
	// CreateSpotMarketOrder defines a method for creating a new spot market
	// order.
	CreateSpotMarketOrder(context.Context, *MsgCreateSpotMarketOrder) (*MsgCreateSpotMarketOrderResponse, error)
	// MsgCancelSpotOrder defines a method for cancelling a spot order.
	CancelSpotOrder(context.Context, *MsgCancelSpotOrder) (*MsgCancelSpotOrderResponse, error)
	// BatchCancelSpotOrders defines a method for cancelling a batch of spot
	// orders in a given market.
	BatchCancelSpotOrders(context.Context, *MsgBatchCancelSpotOrders) (*MsgBatchCancelSpotOrdersResponse, error)
	// BatchUpdateOrders defines a method for updating a batch of orders.
	BatchUpdateOrders(context.Context, *MsgBatchUpdateOrders) (*MsgBatchUpdateOrdersResponse, error)
	// PrivilegedExecuteContract defines a method for executing a Cosmwasm
	// contract from the exchange module with privileged capabilities.
	PrivilegedExecuteContract(context.Context, *MsgPrivilegedExecuteContract) (*MsgPrivilegedExecuteContractResponse, error)
	// CreateDerivativeLimitOrder defines a method for creating a new derivative
	// limit order.
	CreateDerivativeLimitOrder(context.Context, *MsgCreateDerivativeLimitOrder) (*MsgCreateDerivativeLimitOrderResponse, error)
	// BatchCreateDerivativeLimitOrders defines a method for creating a new batch
	// of derivative limit orders.
	BatchCreateDerivativeLimitOrders(context.Context, *MsgBatchCreateDerivativeLimitOrders) (*MsgBatchCreateDerivativeLimitOrdersResponse, error)
	// MsgCreateDerivativeLimitOrder defines a method for creating a new
	// derivative market order.
	CreateDerivativeMarketOrder(context.Context, *MsgCreateDerivativeMarketOrder) (*MsgCreateDerivativeMarketOrderResponse, error)
	// MsgCancelDerivativeOrder defines a method for cancelling a derivative
	// order.
	CancelDerivativeOrder(context.Context, *MsgCancelDerivativeOrder) (*MsgCancelDerivativeOrderResponse, error)
	// MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of
	// derivative limit orders.
	BatchCancelDerivativeOrders(context.Context, *MsgBatchCancelDerivativeOrders) (*MsgBatchCancelDerivativeOrdersResponse, error)
	// InstantBinaryOptionsMarketLaunch defines method for creating a binary
	// options market by paying listing fee without governance
	InstantBinaryOptionsMarketLaunch(context.Context, *MsgInstantBinaryOptionsMarketLaunch) (*MsgInstantBinaryOptionsMarketLaunchResponse, error)
	// CreateBinaryOptionsLimitOrder defines a method for creating a new binary
	// options limit order.
	CreateBinaryOptionsLimitOrder(context.Context, *MsgCreateBinaryOptionsLimitOrder) (*MsgCreateBinaryOptionsLimitOrderResponse, error)
	// CreateBinaryOptionsMarketOrder defines a method for creating a new binary
	// options market order.
	CreateBinaryOptionsMarketOrder(context.Context, *MsgCreateBinaryOptionsMarketOrder) (*MsgCreateBinaryOptionsMarketOrderResponse, error)
	// MsgCancelBinaryOptionsOrder defines a method for cancelling a binary
	// options order.
	CancelBinaryOptionsOrder(context.Context, *MsgCancelBinaryOptionsOrder) (*MsgCancelBinaryOptionsOrderResponse, error)
	// BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of
	// binary options limit orders.
	BatchCancelBinaryOptionsOrders(context.Context, *MsgBatchCancelBinaryOptionsOrders) (*MsgBatchCancelBinaryOptionsOrdersResponse, error)
	// SubaccountTransfer defines a method for transfer between subaccounts
	SubaccountTransfer(context.Context, *MsgSubaccountTransfer) (*MsgSubaccountTransferResponse, error)
	// ExternalTransfer defines a method for transfer between external accounts
	ExternalTransfer(context.Context, *MsgExternalTransfer) (*MsgExternalTransferResponse, error)
	// LiquidatePosition defines a method for liquidating a position
	LiquidatePosition(context.Context, *MsgLiquidatePosition) (*MsgLiquidatePositionResponse, error)
	// EmergencySettleMarket defines a method for emergency settling a market
	EmergencySettleMarket(context.Context, *MsgEmergencySettleMarket) (*MsgEmergencySettleMarketResponse, error)
	// IncreasePositionMargin defines a method for increasing margin of a position
	IncreasePositionMargin(context.Context, *MsgIncreasePositionMargin) (*MsgIncreasePositionMarginResponse, error)
	// DecreasePositionMargin defines a method for decreasing margin of a position
	DecreasePositionMargin(context.Context, *MsgDecreasePositionMargin) (*MsgDecreasePositionMarginResponse, error)
	// RewardsOptOut defines a method for opting out of rewards
	RewardsOptOut(context.Context, *MsgRewardsOptOut) (*MsgRewardsOptOutResponse, error)
	// AdminUpdateBinaryOptionsMarket defines method for updating a binary options
	// market by admin
	AdminUpdateBinaryOptionsMarket(context.Context, *MsgAdminUpdateBinaryOptionsMarket) (*MsgAdminUpdateBinaryOptionsMarketResponse, error)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// UpdateSpotMarket modifies certain spot market fields (admin only)
	UpdateSpotMarket(context.Context, *MsgUpdateSpotMarket) (*MsgUpdateSpotMarketResponse, error)
	// UpdateDerivativeMarket modifies certain derivative market fields (admin
	// only)
	UpdateDerivativeMarket(context.Context, *MsgUpdateDerivativeMarket) (*MsgUpdateDerivativeMarketResponse, error)
	AuthorizeStakeGrants(context.Context, *MsgAuthorizeStakeGrants) (*MsgAuthorizeStakeGrantsResponse, error)
	ActivateStakeGrant(context.Context, *MsgActivateStakeGrant) (*MsgActivateStakeGrantResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Deposit(ctx context.Context, req *MsgDeposit) (*MsgDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (*UnimplementedMsgServer) Withdraw(ctx context.Context, req *MsgWithdraw) (*MsgWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}
func (*UnimplementedMsgServer) InstantSpotMarketLaunch(ctx context.Context, req *MsgInstantSpotMarketLaunch) (*MsgInstantSpotMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantSpotMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) InstantPerpetualMarketLaunch(ctx context.Context, req *MsgInstantPerpetualMarketLaunch) (*MsgInstantPerpetualMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantPerpetualMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) InstantExpiryFuturesMarketLaunch(ctx context.Context, req *MsgInstantExpiryFuturesMarketLaunch) (*MsgInstantExpiryFuturesMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantExpiryFuturesMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) CreateSpotLimitOrder(ctx context.Context, req *MsgCreateSpotLimitOrder) (*MsgCreateSpotLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSpotLimitOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCreateSpotLimitOrders(ctx context.Context, req *MsgBatchCreateSpotLimitOrders) (*MsgBatchCreateSpotLimitOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateSpotLimitOrders not implemented")
}
func (*UnimplementedMsgServer) CreateSpotMarketOrder(ctx context.Context, req *MsgCreateSpotMarketOrder) (*MsgCreateSpotMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSpotMarketOrder not implemented")
}
func (*UnimplementedMsgServer) CancelSpotOrder(ctx context.Context, req *MsgCancelSpotOrder) (*MsgCancelSpotOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSpotOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCancelSpotOrders(ctx context.Context, req *MsgBatchCancelSpotOrders) (*MsgBatchCancelSpotOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelSpotOrders not implemented")
}
func (*UnimplementedMsgServer) BatchUpdateOrders(ctx context.Context, req *MsgBatchUpdateOrders) (*MsgBatchUpdateOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateOrders not implemented")
}
func (*UnimplementedMsgServer) PrivilegedExecuteContract(ctx context.Context, req *MsgPrivilegedExecuteContract) (*MsgPrivilegedExecuteContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecuteContract not implemented")
}
func (*UnimplementedMsgServer) CreateDerivativeLimitOrder(ctx context.Context, req *MsgCreateDerivativeLimitOrder) (*MsgCreateDerivativeLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDerivativeLimitOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCreateDerivativeLimitOrders(ctx context.Context, req *MsgBatchCreateDerivativeLimitOrders) (*MsgBatchCreateDerivativeLimitOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateDerivativeLimitOrders not implemented")
}
func (*UnimplementedMsgServer) CreateDerivativeMarketOrder(ctx context.Context, req *MsgCreateDerivativeMarketOrder) (*MsgCreateDerivativeMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDerivativeMarketOrder not implemented")
}
func (*UnimplementedMsgServer) CancelDerivativeOrder(ctx context.Context, req *MsgCancelDerivativeOrder) (*MsgCancelDerivativeOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelDerivativeOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCancelDerivativeOrders(ctx context.Context, req *MsgBatchCancelDerivativeOrders) (*MsgBatchCancelDerivativeOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelDerivativeOrders not implemented")
}
func (*UnimplementedMsgServer) InstantBinaryOptionsMarketLaunch(ctx context.Context, req *MsgInstantBinaryOptionsMarketLaunch) (*MsgInstantBinaryOptionsMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantBinaryOptionsMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) CreateBinaryOptionsLimitOrder(ctx context.Context, req *MsgCreateBinaryOptionsLimitOrder) (*MsgCreateBinaryOptionsLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBinaryOptionsLimitOrder not implemented")
}
func (*UnimplementedMsgServer) CreateBinaryOptionsMarketOrder(ctx context.Context, req *MsgCreateBinaryOptionsMarketOrder) (*MsgCreateBinaryOptionsMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBinaryOptionsMarketOrder not implemented")
}
func (*UnimplementedMsgServer) CancelBinaryOptionsOrder(ctx context.Context, req *MsgCancelBinaryOptionsOrder) (*MsgCancelBinaryOptionsOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBinaryOptionsOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCancelBinaryOptionsOrders(ctx context.Context, req *MsgBatchCancelBinaryOptionsOrders) (*MsgBatchCancelBinaryOptionsOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelBinaryOptionsOrders not implemented")
}
func (*UnimplementedMsgServer) SubaccountTransfer(ctx context.Context, req *MsgSubaccountTransfer) (*MsgSubaccountTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubaccountTransfer not implemented")
}
func (*UnimplementedMsgServer) ExternalTransfer(ctx context.Context, req *MsgExternalTransfer) (*MsgExternalTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExternalTransfer not implemented")
}
func (*UnimplementedMsgServer) LiquidatePosition(ctx context.Context, req *MsgLiquidatePosition) (*MsgLiquidatePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidatePosition not implemented")
}
func (*UnimplementedMsgServer) EmergencySettleMarket(ctx context.Context, req *MsgEmergencySettleMarket) (*MsgEmergencySettleMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergencySettleMarket not implemented")
}
func (*UnimplementedMsgServer) IncreasePositionMargin(ctx context.Context, req *MsgIncreasePositionMargin) (*MsgIncreasePositionMarginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncreasePositionMargin not implemented")
}
func (*UnimplementedMsgServer) DecreasePositionMargin(ctx context.Context, req *MsgDecreasePositionMargin) (*MsgDecreasePositionMarginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecreasePositionMargin not implemented")
}
func (*UnimplementedMsgServer) RewardsOptOut(ctx context.Context, req *MsgRewardsOptOut) (*MsgRewardsOptOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardsOptOut not implemented")
}
func (*UnimplementedMsgServer) AdminUpdateBinaryOptionsMarket(ctx context.Context, req *MsgAdminUpdateBinaryOptionsMarket) (*MsgAdminUpdateBinaryOptionsMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminUpdateBinaryOptionsMarket not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) UpdateSpotMarket(ctx context.Context, req *MsgUpdateSpotMarket) (*MsgUpdateSpotMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSpotMarket not implemented")
}
func (*UnimplementedMsgServer) UpdateDerivativeMarket(ctx context.Context, req *MsgUpdateDerivativeMarket) (*MsgUpdateDerivativeMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDerivativeMarket not implemented")
}
func (*UnimplementedMsgServer) AuthorizeStakeGrants(ctx context.Context, req *MsgAuthorizeStakeGrants) (*MsgAuthorizeStakeGrantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthorizeStakeGrants not implemented")
}
func (*UnimplementedMsgServer) ActivateStakeGrant(ctx context.Context, req *MsgActivateStakeGrant) (*MsgActivateStakeGrantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateStakeGrant not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/Withdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Withdraw(ctx, req.(*MsgWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantSpotMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantSpotMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantSpotMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantSpotMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantSpotMarketLaunch(ctx, req.(*MsgInstantSpotMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantPerpetualMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantPerpetualMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantPerpetualMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantPerpetualMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantPerpetualMarketLaunch(ctx, req.(*MsgInstantPerpetualMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantExpiryFuturesMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantExpiryFuturesMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantExpiryFuturesMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantExpiryFuturesMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantExpiryFuturesMarketLaunch(ctx, req.(*MsgInstantExpiryFuturesMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSpotLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSpotLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSpotLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateSpotLimitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSpotLimitOrder(ctx, req.(*MsgCreateSpotLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCreateSpotLimitOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCreateSpotLimitOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCreateSpotLimitOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCreateSpotLimitOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCreateSpotLimitOrders(ctx, req.(*MsgBatchCreateSpotLimitOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSpotMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSpotMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSpotMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateSpotMarketOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSpotMarketOrder(ctx, req.(*MsgCreateSpotMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelSpotOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelSpotOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelSpotOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CancelSpotOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelSpotOrder(ctx, req.(*MsgCancelSpotOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelSpotOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelSpotOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelSpotOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCancelSpotOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelSpotOrders(ctx, req.(*MsgBatchCancelSpotOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchUpdateOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchUpdateOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchUpdateOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchUpdateOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchUpdateOrders(ctx, req.(*MsgBatchUpdateOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PrivilegedExecuteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPrivilegedExecuteContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PrivilegedExecuteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/PrivilegedExecuteContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PrivilegedExecuteContract(ctx, req.(*MsgPrivilegedExecuteContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDerivativeLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDerivativeLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDerivativeLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateDerivativeLimitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDerivativeLimitOrder(ctx, req.(*MsgCreateDerivativeLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCreateDerivativeLimitOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCreateDerivativeLimitOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCreateDerivativeLimitOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCreateDerivativeLimitOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCreateDerivativeLimitOrders(ctx, req.(*MsgBatchCreateDerivativeLimitOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDerivativeMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDerivativeMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDerivativeMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateDerivativeMarketOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDerivativeMarketOrder(ctx, req.(*MsgCreateDerivativeMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelDerivativeOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelDerivativeOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelDerivativeOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CancelDerivativeOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelDerivativeOrder(ctx, req.(*MsgCancelDerivativeOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelDerivativeOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelDerivativeOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelDerivativeOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCancelDerivativeOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelDerivativeOrders(ctx, req.(*MsgBatchCancelDerivativeOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantBinaryOptionsMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantBinaryOptionsMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantBinaryOptionsMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantBinaryOptionsMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantBinaryOptionsMarketLaunch(ctx, req.(*MsgInstantBinaryOptionsMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBinaryOptionsLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBinaryOptionsLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBinaryOptionsLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsLimitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBinaryOptionsLimitOrder(ctx, req.(*MsgCreateBinaryOptionsLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBinaryOptionsMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBinaryOptionsMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBinaryOptionsMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsMarketOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBinaryOptionsMarketOrder(ctx, req.(*MsgCreateBinaryOptionsMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelBinaryOptionsOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelBinaryOptionsOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelBinaryOptionsOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CancelBinaryOptionsOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelBinaryOptionsOrder(ctx, req.(*MsgCancelBinaryOptionsOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelBinaryOptionsOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelBinaryOptionsOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelBinaryOptionsOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCancelBinaryOptionsOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelBinaryOptionsOrders(ctx, req.(*MsgBatchCancelBinaryOptionsOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubaccountTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubaccountTransfer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubaccountTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/SubaccountTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubaccountTransfer(ctx, req.(*MsgSubaccountTransfer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ExternalTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgExternalTransfer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ExternalTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/ExternalTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ExternalTransfer(ctx, req.(*MsgExternalTransfer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LiquidatePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLiquidatePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LiquidatePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/LiquidatePosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LiquidatePosition(ctx, req.(*MsgLiquidatePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_EmergencySettleMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEmergencySettleMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).EmergencySettleMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/EmergencySettleMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).EmergencySettleMarket(ctx, req.(*MsgEmergencySettleMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IncreasePositionMargin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIncreasePositionMargin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IncreasePositionMargin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/IncreasePositionMargin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IncreasePositionMargin(ctx, req.(*MsgIncreasePositionMargin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DecreasePositionMargin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDecreasePositionMargin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DecreasePositionMargin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/DecreasePositionMargin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DecreasePositionMargin(ctx, req.(*MsgDecreasePositionMargin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RewardsOptOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRewardsOptOut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RewardsOptOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/RewardsOptOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RewardsOptOut(ctx, req.(*MsgRewardsOptOut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AdminUpdateBinaryOptionsMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAdminUpdateBinaryOptionsMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AdminUpdateBinaryOptionsMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/AdminUpdateBinaryOptionsMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AdminUpdateBinaryOptionsMarket(ctx, req.(*MsgAdminUpdateBinaryOptionsMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateSpotMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateSpotMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateSpotMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/UpdateSpotMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateSpotMarket(ctx, req.(*MsgUpdateSpotMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDerivativeMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDerivativeMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDerivativeMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/UpdateDerivativeMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDerivativeMarket(ctx, req.(*MsgUpdateDerivativeMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AuthorizeStakeGrants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAuthorizeStakeGrants)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AuthorizeStakeGrants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/AuthorizeStakeGrants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AuthorizeStakeGrants(ctx, req.(*MsgAuthorizeStakeGrants))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ActivateStakeGrant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActivateStakeGrant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ActivateStakeGrant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/ActivateStakeGrant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ActivateStakeGrant(ctx, req.(*MsgActivateStakeGrant))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "injective.exchange.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _Msg_Withdraw_Handler,
		},
		{
			MethodName: "InstantSpotMarketLaunch",
			Handler:    _Msg_InstantSpotMarketLaunch_Handler,
		},
		{
			MethodName: "InstantPerpetualMarketLaunch",
			Handler:    _Msg_InstantPerpetualMarketLaunch_Handler,
		},
		{
			MethodName: "InstantExpiryFuturesMarketLaunch",
			Handler:    _Msg_InstantExpiryFuturesMarketLaunch_Handler,
		},
		{
			MethodName: "CreateSpotLimitOrder",
			Handler:    _Msg_CreateSpotLimitOrder_Handler,
		},
		{
			MethodName: "BatchCreateSpotLimitOrders",
			Handler:    _Msg_BatchCreateSpotLimitOrders_Handler,
		},
		{
			MethodName: "CreateSpotMarketOrder",
			Handler:    _Msg_CreateSpotMarketOrder_Handler,
		},
		{
			MethodName: "CancelSpotOrder",
			Handler:    _Msg_CancelSpotOrder_Handler,
		},
		{
			MethodName: "BatchCancelSpotOrders",
			Handler:    _Msg_BatchCancelSpotOrders_Handler,
		},
		{
			MethodName: "BatchUpdateOrders",
			Handler:    _Msg_BatchUpdateOrders_Handler,
		},
		{
			MethodName: "PrivilegedExecuteContract",
			Handler:    _Msg_PrivilegedExecuteContract_Handler,
		},
		{
			MethodName: "CreateDerivativeLimitOrder",
			Handler:    _Msg_CreateDerivativeLimitOrder_Handler,
		},
		{
			MethodName: "BatchCreateDerivativeLimitOrders",
			Handler:    _Msg_BatchCreateDerivativeLimitOrders_Handler,
		},
		{
			MethodName: "CreateDerivativeMarketOrder",
			Handler:    _Msg_CreateDerivativeMarketOrder_Handler,
		},
		{
			MethodName: "CancelDerivativeOrder",
			Handler:    _Msg_CancelDerivativeOrder_Handler,
		},
		{
			MethodName: "BatchCancelDerivativeOrders",
			Handler:    _Msg_BatchCancelDerivativeOrders_Handler,
		},
		{
			MethodName: "InstantBinaryOptionsMarketLaunch",
			Handler:    _Msg_InstantBinaryOptionsMarketLaunch_Handler,
		},
		{
			MethodName: "CreateBinaryOptionsLimitOrder",
			Handler:    _Msg_CreateBinaryOptionsLimitOrder_Handler,
		},
		{
			MethodName: "CreateBinaryOptionsMarketOrder",
			Handler:    _Msg_CreateBinaryOptionsMarketOrder_Handler,
		},
		{
			MethodName: "CancelBinaryOptionsOrder",
			Handler:    _Msg_CancelBinaryOptionsOrder_Handler,
		},
		{
			MethodName: "BatchCancelBinaryOptionsOrders",
			Handler:    _Msg_BatchCancelBinaryOptionsOrders_Handler,
		},
		{
			MethodName: "SubaccountTransfer",
			Handler:    _Msg_SubaccountTransfer_Handler,
		},
		{
			MethodName: "ExternalTransfer",
			Handler:    _Msg_ExternalTransfer_Handler,
		},
		{
			MethodName: "LiquidatePosition",
			Handler:    _Msg_LiquidatePosition_Handler,
		},
		{
			MethodName: "EmergencySettleMarket",
			Handler:    _Msg_EmergencySettleMarket_Handler,
		},
		{
			MethodName: "IncreasePositionMargin",
			Handler:    _Msg_IncreasePositionMargin_Handler,
		},
		{
			MethodName: "DecreasePositionMargin",
			Handler:    _Msg_DecreasePositionMargin_Handler,
		},
		{
			MethodName: "RewardsOptOut",
			Handler:    _Msg_RewardsOptOut_Handler,
		},
		{
			MethodName: "AdminUpdateBinaryOptionsMarket",
			Handler:    _Msg_AdminUpdateBinaryOptionsMarket_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "UpdateSpotMarket",
			Handler:    _Msg_UpdateSpotMarket_Handler,
		},
		{
			MethodName: "UpdateDerivativeMarket",
			Handler:    _Msg_UpdateDerivativeMarket_Handler,
		},
		{
			MethodName: "AuthorizeStakeGrants",
			Handler:    _Msg_AuthorizeStakeGrants_Handler,
		},
		{
			MethodName: "ActivateStakeGrant",
			Handler:    _Msg_ActivateStakeGrant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "injective/exchange/v1beta1/tx.proto",
}

func (m *MsgUpdateSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewMinNotional.Size()
		i -= size
		if _, err := m.NewMinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.NewMinQuantityTickSize.Size()
		i -= size
		if _, err := m.NewMinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.NewMinPriceTickSize.Size()
		i -= size
		if _, err := m.NewMinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.NewTicker) > 0 {
		i -= len(m.NewTicker)
		copy(dAtA[i:], m.NewTicker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewTicker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateSpotMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSpotMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSpotMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewMaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.NewMaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.NewInitialMarginRatio.Size()
		i -= size
		if _, err := m.NewInitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.NewMinNotional.Size()
		i -= size
		if _, err := m.NewMinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.NewMinQuantityTickSize.Size()
		i -= size
		if _, err := m.NewMinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.NewMinPriceTickSize.Size()
		i -= size
		if _, err := m.NewMinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.NewTicker) > 0 {
		i -= len(m.NewTicker)
		copy(dAtA[i:], m.NewTicker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewTicker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDerivativeMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDerivativeMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDerivativeMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotLimitOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotLimitOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotLimitOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateSpotLimitOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateSpotLimitOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateSpotLimitOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedOrdersCids) > 0 {
		for iNdEx := len(m.FailedOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedOrdersCids[iNdEx])
			copy(dAtA[i:], m.FailedOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.FailedOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CreatedOrdersCids) > 0 {
		for iNdEx := len(m.CreatedOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CreatedOrdersCids[iNdEx])
			copy(dAtA[i:], m.CreatedOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CreatedOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrderHashes) > 0 {
		for iNdEx := len(m.OrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrderHashes[iNdEx])
			copy(dAtA[i:], m.OrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHashes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantSpotMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantSpotMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantSpotMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantSpotMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantSpotMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantSpotMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInstantPerpetualMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantPerpetualMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantPerpetualMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x38
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantPerpetualMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantPerpetualMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantPerpetualMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInstantBinaryOptionsMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantBinaryOptionsMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantBinaryOptionsMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x5a
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x50
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x30
	}
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OracleProvider) > 0 {
		i -= len(m.OracleProvider)
		copy(dAtA[i:], m.OracleProvider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleProvider)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OracleSymbol) > 0 {
		i -= len(m.OracleSymbol)
		copy(dAtA[i:], m.OracleSymbol)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInstantExpiryFuturesMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantExpiryFuturesMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantExpiryFuturesMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinNotional.Size()
		i -= size
		if _, err := m.MinNotional.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Expiry != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotMarketOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotMarketOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotMarketOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotMarketOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotMarketOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotMarketOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotMarketOrderResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarketOrderResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarketOrderResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeLimitOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeLimitOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeLimitOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateDerivativeLimitOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateDerivativeLimitOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateDerivativeLimitOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedOrdersCids) > 0 {
		for iNdEx := len(m.FailedOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedOrdersCids[iNdEx])
			copy(dAtA[i:], m.FailedOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.FailedOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CreatedOrdersCids) > 0 {
		for iNdEx := len(m.CreatedOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CreatedOrdersCids[iNdEx])
			copy(dAtA[i:], m.CreatedOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CreatedOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrderHashes) > 0 {
		for iNdEx := len(m.OrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrderHashes[iNdEx])
			copy(dAtA[i:], m.OrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHashes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelSpotOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelSpotOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelSpotOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelSpotOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelSpotOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelSpotOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelSpotOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelSpotOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelSpotOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Success) > 0 {
		for iNdEx := len(m.Success) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Success[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.Success)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelBinaryOptionsOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelBinaryOptionsOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelBinaryOptionsOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Success) > 0 {
		for iNdEx := len(m.Success) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Success[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.Success)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchUpdateOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchUpdateOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchUpdateOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BinaryOptionsOrdersToCreate) > 0 {
		for iNdEx := len(m.BinaryOptionsOrdersToCreate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsOrdersToCreate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.BinaryOptionsMarketIdsToCancelAll) > 0 {
		for iNdEx := len(m.BinaryOptionsMarketIdsToCancelAll) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BinaryOptionsMarketIdsToCancelAll[iNdEx])
			copy(dAtA[i:], m.BinaryOptionsMarketIdsToCancelAll[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.BinaryOptionsMarketIdsToCancelAll[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BinaryOptionsOrdersToCancel) > 0 {
		for iNdEx := len(m.BinaryOptionsOrdersToCancel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsOrdersToCancel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.DerivativeOrdersToCreate) > 0 {
		for iNdEx := len(m.DerivativeOrdersToCreate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrdersToCreate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SpotOrdersToCreate) > 0 {
		for iNdEx := len(m.SpotOrdersToCreate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrdersToCreate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DerivativeOrdersToCancel) > 0 {
		for iNdEx := len(m.DerivativeOrdersToCancel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrdersToCancel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SpotOrdersToCancel) > 0 {
		for iNdEx := len(m.SpotOrdersToCancel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrdersToCancel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DerivativeMarketIdsToCancelAll) > 0 {
		for iNdEx := len(m.DerivativeMarketIdsToCancelAll) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DerivativeMarketIdsToCancelAll[iNdEx])
			copy(dAtA[i:], m.DerivativeMarketIdsToCancelAll[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.DerivativeMarketIdsToCancelAll[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SpotMarketIdsToCancelAll) > 0 {
		for iNdEx := len(m.SpotMarketIdsToCancelAll) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SpotMarketIdsToCancelAll[iNdEx])
			copy(dAtA[i:], m.SpotMarketIdsToCancelAll[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.SpotMarketIdsToCancelAll[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchUpdateOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchUpdateOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchUpdateOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedBinaryOptionsOrdersCids) > 0 {
		for iNdEx := len(m.FailedBinaryOptionsOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedBinaryOptionsOrdersCids[iNdEx])
			copy(dAtA[i:], m.FailedBinaryOptionsOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.FailedBinaryOptionsOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CreatedBinaryOptionsOrdersCids) > 0 {
		for iNdEx := len(m.CreatedBinaryOptionsOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CreatedBinaryOptionsOrdersCids[iNdEx])
			copy(dAtA[i:], m.CreatedBinaryOptionsOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CreatedBinaryOptionsOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FailedDerivativeOrdersCids) > 0 {
		for iNdEx := len(m.FailedDerivativeOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedDerivativeOrdersCids[iNdEx])
			copy(dAtA[i:], m.FailedDerivativeOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.FailedDerivativeOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CreatedDerivativeOrdersCids) > 0 {
		for iNdEx := len(m.CreatedDerivativeOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CreatedDerivativeOrdersCids[iNdEx])
			copy(dAtA[i:], m.CreatedDerivativeOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CreatedDerivativeOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.FailedSpotOrdersCids) > 0 {
		for iNdEx := len(m.FailedSpotOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedSpotOrdersCids[iNdEx])
			copy(dAtA[i:], m.FailedSpotOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.FailedSpotOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CreatedSpotOrdersCids) > 0 {
		for iNdEx := len(m.CreatedSpotOrdersCids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CreatedSpotOrdersCids[iNdEx])
			copy(dAtA[i:], m.CreatedSpotOrdersCids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.CreatedSpotOrdersCids[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BinaryOptionsOrderHashes) > 0 {
		for iNdEx := len(m.BinaryOptionsOrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BinaryOptionsOrderHashes[iNdEx])
			copy(dAtA[i:], m.BinaryOptionsOrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.BinaryOptionsOrderHashes[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BinaryOptionsCancelSuccess) > 0 {
		for iNdEx := len(m.BinaryOptionsCancelSuccess) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.BinaryOptionsCancelSuccess[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.BinaryOptionsCancelSuccess)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DerivativeOrderHashes) > 0 {
		for iNdEx := len(m.DerivativeOrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DerivativeOrderHashes[iNdEx])
			copy(dAtA[i:], m.DerivativeOrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.DerivativeOrderHashes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SpotOrderHashes) > 0 {
		for iNdEx := len(m.SpotOrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SpotOrderHashes[iNdEx])
			copy(dAtA[i:], m.SpotOrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.SpotOrderHashes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DerivativeCancelSuccess) > 0 {
		for iNdEx := len(m.DerivativeCancelSuccess) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.DerivativeCancelSuccess[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.DerivativeCancelSuccess)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpotCancelSuccess) > 0 {
		for iNdEx := len(m.SpotCancelSuccess) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.SpotCancelSuccess[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.SpotCancelSuccess)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeMarketOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeMarketOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeMarketOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeMarketOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeMarketOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeMarketOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeMarketOrderResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarketOrderResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarketOrderResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Payout.Size()
		i -= size
		if _, err := m.Payout.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.PositionDelta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsMarketOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsMarketOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsMarketOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrderMask != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OrderMask))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelDerivativeOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelDerivativeOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelDerivativeOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCancelBinaryOptionsOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelBinaryOptionsOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelBinaryOptionsOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrderMask != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OrderMask))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelBinaryOptionsOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelBinaryOptionsOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelBinaryOptionsOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OrderData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OrderMask != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OrderMask))
		i--
		dAtA[i] = 0x20
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelDerivativeOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelDerivativeOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelDerivativeOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelDerivativeOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelDerivativeOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelDerivativeOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Success) > 0 {
		for iNdEx := len(m.Success) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Success[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.Success)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubaccountTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubaccountTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubaccountTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.DestinationSubaccountId) > 0 {
		i -= len(m.DestinationSubaccountId)
		copy(dAtA[i:], m.DestinationSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceSubaccountId) > 0 {
		i -= len(m.SourceSubaccountId)
		copy(dAtA[i:], m.SourceSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubaccountTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubaccountTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubaccountTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgExternalTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExternalTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExternalTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.DestinationSubaccountId) > 0 {
		i -= len(m.DestinationSubaccountId)
		copy(dAtA[i:], m.DestinationSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceSubaccountId) > 0 {
		i -= len(m.SourceSubaccountId)
		copy(dAtA[i:], m.SourceSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExternalTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExternalTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExternalTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgLiquidatePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidatePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidatePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgLiquidatePositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidatePositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidatePositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgEmergencySettleMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmergencySettleMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmergencySettleMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEmergencySettleMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmergencySettleMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmergencySettleMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgIncreasePositionMargin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIncreasePositionMargin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIncreasePositionMargin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DestinationSubaccountId) > 0 {
		i -= len(m.DestinationSubaccountId)
		copy(dAtA[i:], m.DestinationSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceSubaccountId) > 0 {
		i -= len(m.SourceSubaccountId)
		copy(dAtA[i:], m.SourceSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIncreasePositionMarginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIncreasePositionMarginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIncreasePositionMarginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDecreasePositionMargin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDecreasePositionMargin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDecreasePositionMargin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DestinationSubaccountId) > 0 {
		i -= len(m.DestinationSubaccountId)
		copy(dAtA[i:], m.DestinationSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceSubaccountId) > 0 {
		i -= len(m.SourceSubaccountId)
		copy(dAtA[i:], m.SourceSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDecreasePositionMarginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDecreasePositionMarginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDecreasePositionMarginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPrivilegedExecuteContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPrivilegedExecuteContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPrivilegedExecuteContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Funds) > 0 {
		i -= len(m.Funds)
		copy(dAtA[i:], m.Funds)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Funds)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPrivilegedExecuteContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPrivilegedExecuteContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPrivilegedExecuteContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FundsDiff) > 0 {
		for iNdEx := len(m.FundsDiff) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FundsDiff[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgRewardsOptOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRewardsOptOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRewardsOptOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRewardsOptOutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRewardsOptOutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRewardsOptOutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgReclaimLockedFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReclaimLockedFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReclaimLockedFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LockedAccountPubKey) > 0 {
		i -= len(m.LockedAccountPubKey)
		copy(dAtA[i:], m.LockedAccountPubKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.LockedAccountPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReclaimLockedFundsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReclaimLockedFundsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReclaimLockedFundsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSignData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSignData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSignData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSignDoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSignDoc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSignDoc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.SignType) > 0 {
		i -= len(m.SignType)
		copy(dAtA[i:], m.SignType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SignType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAdminUpdateBinaryOptionsMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAdminUpdateBinaryOptionsMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAdminUpdateBinaryOptionsMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.SettlementPrice != nil {
		{
			size := m.SettlementPrice.Size()
			i -= size
			if _, err := m.SettlementPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAuthorizeStakeGrants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAuthorizeStakeGrants) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAuthorizeStakeGrants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Grants) > 0 {
		for iNdEx := len(m.Grants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Grants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAuthorizeStakeGrantsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAuthorizeStakeGrantsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAuthorizeStakeGrantsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgActivateStakeGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateStakeGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateStakeGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Granter) > 0 {
		i -= len(m.Granter)
		copy(dAtA[i:], m.Granter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Granter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateStakeGrantResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateStakeGrantResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateStakeGrantResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewTicker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.NewMinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewMinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewMinNotional.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateSpotMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewTicker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.NewMinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewMinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewMinNotional.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewInitialMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.NewMaintenanceMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateDerivativeMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdrawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateSpotLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateSpotLimitOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBatchCreateSpotLimitOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderHashes) > 0 {
		for _, s := range m.OrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CreatedOrdersCids) > 0 {
		for _, s := range m.CreatedOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.FailedOrdersCids) > 0 {
		for _, s := range m.FailedOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgInstantSpotMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinNotional.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantSpotMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInstantPerpetualMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinNotional.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantPerpetualMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInstantBinaryOptionsMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleSymbol)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleProvider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovTx(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovTx(uint64(m.SettlementTimestamp))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinNotional.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInstantExpiryFuturesMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.Expiry != 0 {
		n += 1 + sovTx(uint64(m.Expiry))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinNotional.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateSpotMarketOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateSpotMarketOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *SpotMarketOrderResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Quantity.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Price.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDerivativeLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDerivativeLimitOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateBinaryOptionsLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBatchCreateDerivativeLimitOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderHashes) > 0 {
		for _, s := range m.OrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CreatedOrdersCids) > 0 {
		for _, s := range m.CreatedOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.FailedOrdersCids) > 0 {
		for _, s := range m.FailedOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCancelSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelSpotOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBatchCancelSpotOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCancelSpotOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Success) > 0 {
		n += 1 + sovTx(uint64(len(m.Success))) + len(m.Success)*1
	}
	return n
}

func (m *MsgBatchCancelBinaryOptionsOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Success) > 0 {
		n += 1 + sovTx(uint64(len(m.Success))) + len(m.Success)*1
	}
	return n
}

func (m *MsgBatchUpdateOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.SpotMarketIdsToCancelAll) > 0 {
		for _, s := range m.SpotMarketIdsToCancelAll {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeMarketIdsToCancelAll) > 0 {
		for _, s := range m.DerivativeMarketIdsToCancelAll {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.SpotOrdersToCancel) > 0 {
		for _, e := range m.SpotOrdersToCancel {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeOrdersToCancel) > 0 {
		for _, e := range m.DerivativeOrdersToCancel {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.SpotOrdersToCreate) > 0 {
		for _, e := range m.SpotOrdersToCreate {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeOrdersToCreate) > 0 {
		for _, e := range m.DerivativeOrdersToCreate {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsOrdersToCancel) > 0 {
		for _, e := range m.BinaryOptionsOrdersToCancel {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsMarketIdsToCancelAll) > 0 {
		for _, s := range m.BinaryOptionsMarketIdsToCancelAll {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsOrdersToCreate) > 0 {
		for _, e := range m.BinaryOptionsOrdersToCreate {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchUpdateOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpotCancelSuccess) > 0 {
		n += 1 + sovTx(uint64(len(m.SpotCancelSuccess))) + len(m.SpotCancelSuccess)*1
	}
	if len(m.DerivativeCancelSuccess) > 0 {
		n += 1 + sovTx(uint64(len(m.DerivativeCancelSuccess))) + len(m.DerivativeCancelSuccess)*1
	}
	if len(m.SpotOrderHashes) > 0 {
		for _, s := range m.SpotOrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeOrderHashes) > 0 {
		for _, s := range m.DerivativeOrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsCancelSuccess) > 0 {
		n += 1 + sovTx(uint64(len(m.BinaryOptionsCancelSuccess))) + len(m.BinaryOptionsCancelSuccess)*1
	}
	if len(m.BinaryOptionsOrderHashes) > 0 {
		for _, s := range m.BinaryOptionsOrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CreatedSpotOrdersCids) > 0 {
		for _, s := range m.CreatedSpotOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.FailedSpotOrdersCids) > 0 {
		for _, s := range m.FailedSpotOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CreatedDerivativeOrdersCids) > 0 {
		for _, s := range m.CreatedDerivativeOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.FailedDerivativeOrdersCids) > 0 {
		for _, s := range m.FailedDerivativeOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CreatedBinaryOptionsOrdersCids) > 0 {
		for _, s := range m.CreatedBinaryOptionsOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.FailedBinaryOptionsOrdersCids) > 0 {
		for _, s := range m.FailedBinaryOptionsOrdersCids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateDerivativeMarketOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDerivativeMarketOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *DerivativeMarketOrderResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Quantity.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Price.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.PositionDelta.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Payout.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateBinaryOptionsMarketOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OrderMask != 0 {
		n += 1 + sovTx(uint64(m.OrderMask))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelDerivativeOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCancelBinaryOptionsOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OrderMask != 0 {
		n += 1 + sovTx(uint64(m.OrderMask))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelBinaryOptionsOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OrderData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OrderMask != 0 {
		n += 1 + sovTx(uint64(m.OrderMask))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBatchCancelDerivativeOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCancelDerivativeOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Success) > 0 {
		n += 1 + sovTx(uint64(len(m.Success))) + len(m.Success)*1
	}
	return n
}

func (m *MsgSubaccountTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSubaccountTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgExternalTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgExternalTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgLiquidatePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgLiquidatePositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgEmergencySettleMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgEmergencySettleMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgIncreasePositionMargin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgIncreasePositionMarginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDecreasePositionMargin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDecreasePositionMarginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPrivilegedExecuteContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Funds)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPrivilegedExecuteContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FundsDiff) > 0 {
		for _, e := range m.FundsDiff {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgRewardsOptOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRewardsOptOutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgReclaimLockedFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.LockedAccountPubKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReclaimLockedFundsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSignData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSignDoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SignType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgAdminUpdateBinaryOptionsMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SettlementPrice != nil {
		l = m.SettlementPrice.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovTx(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovTx(uint64(m.SettlementTimestamp))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	return n
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAuthorizeStakeGrants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Grants) > 0 {
		for _, e := range m.Grants {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgAuthorizeStakeGrantsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgActivateStakeGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Granter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgActivateStakeGrantResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewMinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewMinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewMinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateSpotMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateSpotMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateSpotMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewMinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewMinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewMinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewInitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewInitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewMaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDerivativeMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDerivativeMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDerivativeMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotLimitOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateSpotLimitOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, SpotOrder{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHashes = append(m.OrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedOrdersCids = append(m.CreatedOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedOrdersCids = append(m.FailedOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantSpotMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantSpotMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantPerpetualMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantPerpetualMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantBinaryOptionsMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantExpiryFuturesMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNotional", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinNotional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotMarketOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotMarketOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &SpotMarketOrderResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotMarketOrderResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarketOrderResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarketOrderResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeLimitOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateDerivativeLimitOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, DerivativeOrder{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHashes = append(m.OrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedOrdersCids = append(m.CreatedOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedOrdersCids = append(m.FailedOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelSpotOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelSpotOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelSpotOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelSpotOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, OrderData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelSpotOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Success = append(m.Success, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Success) == 0 {
					m.Success = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Success = append(m.Success, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelBinaryOptionsOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, OrderData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Success = append(m.Success, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Success) == 0 {
					m.Success = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Success = append(m.Success, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchUpdateOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchUpdateOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchUpdateOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotMarketIdsToCancelAll", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotMarketIdsToCancelAll = append(m.SpotMarketIdsToCancelAll, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeMarketIdsToCancelAll", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeMarketIdsToCancelAll = append(m.DerivativeMarketIdsToCancelAll, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrdersToCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrdersToCancel = append(m.SpotOrdersToCancel, &OrderData{})
			if err := m.SpotOrdersToCancel[len(m.SpotOrdersToCancel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrdersToCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrdersToCancel = append(m.DerivativeOrdersToCancel, &OrderData{})
			if err := m.DerivativeOrdersToCancel[len(m.DerivativeOrdersToCancel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrdersToCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrdersToCreate = append(m.SpotOrdersToCreate, &SpotOrder{})
			if err := m.SpotOrdersToCreate[len(m.SpotOrdersToCreate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrdersToCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrdersToCreate = append(m.DerivativeOrdersToCreate, &DerivativeOrder{})
			if err := m.DerivativeOrdersToCreate[len(m.DerivativeOrdersToCreate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsOrdersToCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsOrdersToCancel = append(m.BinaryOptionsOrdersToCancel, &OrderData{})
			if err := m.BinaryOptionsOrdersToCancel[len(m.BinaryOptionsOrdersToCancel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsMarketIdsToCancelAll", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsMarketIdsToCancelAll = append(m.BinaryOptionsMarketIdsToCancelAll, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsOrdersToCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsOrdersToCreate = append(m.BinaryOptionsOrdersToCreate, &DerivativeOrder{})
			if err := m.BinaryOptionsOrdersToCreate[len(m.BinaryOptionsOrdersToCreate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchUpdateOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchUpdateOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchUpdateOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpotCancelSuccess = append(m.SpotCancelSuccess, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.SpotCancelSuccess) == 0 {
					m.SpotCancelSuccess = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpotCancelSuccess = append(m.SpotCancelSuccess, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotCancelSuccess", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DerivativeCancelSuccess = append(m.DerivativeCancelSuccess, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.DerivativeCancelSuccess) == 0 {
					m.DerivativeCancelSuccess = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DerivativeCancelSuccess = append(m.DerivativeCancelSuccess, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeCancelSuccess", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrderHashes = append(m.SpotOrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrderHashes = append(m.DerivativeOrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BinaryOptionsCancelSuccess = append(m.BinaryOptionsCancelSuccess, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.BinaryOptionsCancelSuccess) == 0 {
					m.BinaryOptionsCancelSuccess = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BinaryOptionsCancelSuccess = append(m.BinaryOptionsCancelSuccess, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsCancelSuccess", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsOrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsOrderHashes = append(m.BinaryOptionsOrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedSpotOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedSpotOrdersCids = append(m.CreatedSpotOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSpotOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedSpotOrdersCids = append(m.FailedSpotOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedDerivativeOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedDerivativeOrdersCids = append(m.CreatedDerivativeOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedDerivativeOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedDerivativeOrdersCids = append(m.FailedDerivativeOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBinaryOptionsOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBinaryOptionsOrdersCids = append(m.CreatedBinaryOptionsOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedBinaryOptionsOrdersCids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedBinaryOptionsOrdersCids = append(m.FailedBinaryOptionsOrdersCids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeMarketOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeMarketOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &DerivativeMarketOrderResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeMarketOrderResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarketOrderResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarketOrderResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Payout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsMarketOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &DerivativeMarketOrderResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderMask", wireType)
			}
			m.OrderMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelDerivativeOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelBinaryOptionsOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderMask", wireType)
			}
			m.OrderMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelBinaryOptionsOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderMask", wireType)
			}
			m.OrderMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelDerivativeOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, OrderData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelDerivativeOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Success = append(m.Success, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Success) == 0 {
					m.Success = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Success = append(m.Success, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubaccountTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubaccountTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubaccountTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubaccountTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubaccountTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubaccountTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExternalTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExternalTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExternalTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExternalTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExternalTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExternalTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidatePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidatePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidatePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &DerivativeOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidatePositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidatePositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidatePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmergencySettleMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmergencySettleMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmergencySettleMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmergencySettleMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmergencySettleMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmergencySettleMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIncreasePositionMargin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIncreasePositionMargin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIncreasePositionMargin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIncreasePositionMarginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIncreasePositionMarginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIncreasePositionMarginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDecreasePositionMargin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDecreasePositionMargin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDecreasePositionMargin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDecreasePositionMarginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDecreasePositionMarginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDecreasePositionMarginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPrivilegedExecuteContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPrivilegedExecuteContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPrivilegedExecuteContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Funds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPrivilegedExecuteContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPrivilegedExecuteContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPrivilegedExecuteContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundsDiff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundsDiff = append(m.FundsDiff, types.Coin{})
			if err := m.FundsDiff[len(m.FundsDiff)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRewardsOptOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRewardsOptOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRewardsOptOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRewardsOptOutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRewardsOptOutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRewardsOptOutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReclaimLockedFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReclaimLockedFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReclaimLockedFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedAccountPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockedAccountPubKey = append(m.LockedAccountPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.LockedAccountPubKey == nil {
				m.LockedAccountPubKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReclaimLockedFundsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReclaimLockedFundsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReclaimLockedFundsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSignData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSignData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSignData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = append(m.Signer[:0], dAtA[iNdEx:postIndex]...)
			if m.Signer == nil {
				m.Signer = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSignDoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSignDoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSignDoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAdminUpdateBinaryOptionsMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.SettlementPrice = &v
			if err := m.SettlementPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAuthorizeStakeGrants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAuthorizeStakeGrants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAuthorizeStakeGrants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grants = append(m.Grants, &GrantAuthorization{})
			if err := m.Grants[len(m.Grants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAuthorizeStakeGrantsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAuthorizeStakeGrantsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAuthorizeStakeGrantsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateStakeGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateStakeGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateStakeGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Granter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateStakeGrantResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateStakeGrantResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateStakeGrantResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
