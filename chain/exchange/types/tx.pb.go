// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/exchange/v1beta1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	types1 "github.com/InjectiveLabs/sdk-go/chain/oracle/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	types2 "github.com/cosmos/cosmos-sdk/x/distribution/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ExchangeType int32

const (
	ExchangeType_EXCHANGE_UNSPECIFIED ExchangeType = 0
	ExchangeType_SPOT                 ExchangeType = 1
	ExchangeType_DERIVATIVES          ExchangeType = 2
)

var ExchangeType_name = map[int32]string{
	0: "EXCHANGE_UNSPECIFIED",
	1: "SPOT",
	2: "DERIVATIVES",
}

var ExchangeType_value = map[string]int32{
	"EXCHANGE_UNSPECIFIED": 0,
	"SPOT":                 1,
	"DERIVATIVES":          2,
}

func (x ExchangeType) String() string {
	return proto.EnumName(ExchangeType_name, int32(x))
}

func (ExchangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{0}
}

// MsgDeposit defines a SDK message for transferring coins from the sender's bank balance into the subaccount's exchange deposits
type MsgDeposit struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin will be deposited to the sender's default
	// subaccount address.
	SubaccountId string     `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Amount       types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgDeposit) Reset()         { *m = MsgDeposit{} }
func (m *MsgDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgDeposit) ProtoMessage()    {}
func (*MsgDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{0}
}
func (m *MsgDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeposit.Merge(m, src)
}
func (m *MsgDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeposit proto.InternalMessageInfo

// MsgDepositResponse defines the Msg/Deposit response type.
type MsgDepositResponse struct {
}

func (m *MsgDepositResponse) Reset()         { *m = MsgDepositResponse{} }
func (m *MsgDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositResponse) ProtoMessage()    {}
func (*MsgDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{1}
}
func (m *MsgDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositResponse.Merge(m, src)
}
func (m *MsgDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositResponse proto.InternalMessageInfo

// MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's deposits to the user's bank balance
type MsgWithdraw struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// bytes32 subaccount ID to withdraw funds from
	SubaccountId string     `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Amount       types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgWithdraw) Reset()         { *m = MsgWithdraw{} }
func (m *MsgWithdraw) String() string { return proto.CompactTextString(m) }
func (*MsgWithdraw) ProtoMessage()    {}
func (*MsgWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{2}
}
func (m *MsgWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdraw.Merge(m, src)
}
func (m *MsgWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdraw proto.InternalMessageInfo

// MsgWithdraw defines the Msg/Withdraw response type.
type MsgWithdrawResponse struct {
}

func (m *MsgWithdrawResponse) Reset()         { *m = MsgWithdrawResponse{} }
func (m *MsgWithdrawResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawResponse) ProtoMessage()    {}
func (*MsgWithdrawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{3}
}
func (m *MsgWithdrawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawResponse.Merge(m, src)
}
func (m *MsgWithdrawResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawResponse proto.InternalMessageInfo

// MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit order.
type MsgCreateSpotLimitOrder struct {
	Sender string    `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  SpotOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateSpotLimitOrder) Reset()         { *m = MsgCreateSpotLimitOrder{} }
func (m *MsgCreateSpotLimitOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotLimitOrder) ProtoMessage()    {}
func (*MsgCreateSpotLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{4}
}
func (m *MsgCreateSpotLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotLimitOrder.Merge(m, src)
}
func (m *MsgCreateSpotLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotLimitOrder proto.InternalMessageInfo

// MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response type.
type MsgCreateSpotLimitOrderResponse struct {
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
}

func (m *MsgCreateSpotLimitOrderResponse) Reset()         { *m = MsgCreateSpotLimitOrderResponse{} }
func (m *MsgCreateSpotLimitOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotLimitOrderResponse) ProtoMessage()    {}
func (*MsgCreateSpotLimitOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{5}
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotLimitOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotLimitOrderResponse.Merge(m, src)
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotLimitOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotLimitOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotLimitOrderResponse proto.InternalMessageInfo

// MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new batch of spot limit orders.
type MsgBatchCreateSpotLimitOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Orders []SpotOrder `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders"`
}

func (m *MsgBatchCreateSpotLimitOrders) Reset()         { *m = MsgBatchCreateSpotLimitOrders{} }
func (m *MsgBatchCreateSpotLimitOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCreateSpotLimitOrders) ProtoMessage()    {}
func (*MsgBatchCreateSpotLimitOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{6}
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateSpotLimitOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrders.Merge(m, src)
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateSpotLimitOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateSpotLimitOrders proto.InternalMessageInfo

// MsgBatchCreateSpotLimitOrdersResponse defines the Msg/BatchCreateSpotLimitOrders response type.
type MsgBatchCreateSpotLimitOrdersResponse struct {
	OrderHashes []string `protobuf:"bytes,1,rep,name=order_hashes,json=orderHashes,proto3" json:"order_hashes,omitempty"`
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) Reset()         { *m = MsgBatchCreateSpotLimitOrdersResponse{} }
func (m *MsgBatchCreateSpotLimitOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCreateSpotLimitOrdersResponse) ProtoMessage()    {}
func (*MsgBatchCreateSpotLimitOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{7}
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateSpotLimitOrdersResponse proto.InternalMessageInfo

// MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot market by paying listing fee without governance
type MsgInstantSpotMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the spot market.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	BaseDenom string `protobuf:"bytes,3,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,4,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
}

func (m *MsgInstantSpotMarketLaunch) Reset()         { *m = MsgInstantSpotMarketLaunch{} }
func (m *MsgInstantSpotMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantSpotMarketLaunch) ProtoMessage()    {}
func (*MsgInstantSpotMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{8}
}
func (m *MsgInstantSpotMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantSpotMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantSpotMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantSpotMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantSpotMarketLaunch.Merge(m, src)
}
func (m *MsgInstantSpotMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantSpotMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantSpotMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantSpotMarketLaunch proto.InternalMessageInfo

// MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch response type.
type MsgInstantSpotMarketLaunchResponse struct {
}

func (m *MsgInstantSpotMarketLaunchResponse) Reset()         { *m = MsgInstantSpotMarketLaunchResponse{} }
func (m *MsgInstantSpotMarketLaunchResponse) String() string { return proto.CompactTextString(m) }
func (*MsgInstantSpotMarketLaunchResponse) ProtoMessage()    {}
func (*MsgInstantSpotMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{9}
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantSpotMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantSpotMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantSpotMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantSpotMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantSpotMarketLaunchResponse proto.InternalMessageInfo

// MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new perpetual futures market by paying listing fee without governance
type MsgInstantPerpetualMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,4,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,5,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,6,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,7,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the perpetual market
	MakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate"`
	// taker_fee_rate defines the trade fee rate for takers on the perpetual market
	TakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate"`
	// initial_margin_ratio defines the initial margin ratio for the perpetual market
	InitialMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the perpetual market
	MaintenanceMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maintenance_margin_ratio"`
	// min_price_tick_size defines the minimum tick size of the order's price and margin
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
}

func (m *MsgInstantPerpetualMarketLaunch) Reset()         { *m = MsgInstantPerpetualMarketLaunch{} }
func (m *MsgInstantPerpetualMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantPerpetualMarketLaunch) ProtoMessage()    {}
func (*MsgInstantPerpetualMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{10}
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantPerpetualMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunch.Merge(m, src)
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantPerpetualMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantPerpetualMarketLaunch proto.InternalMessageInfo

// MsgInstantPerpetualMarketLaunchResponse defines the Msg/InstantPerpetualMarketLaunchResponse response type.
type MsgInstantPerpetualMarketLaunchResponse struct {
}

func (m *MsgInstantPerpetualMarketLaunchResponse) Reset() {
	*m = MsgInstantPerpetualMarketLaunchResponse{}
}
func (m *MsgInstantPerpetualMarketLaunchResponse) String() string { return proto.CompactTextString(m) }
func (*MsgInstantPerpetualMarketLaunchResponse) ProtoMessage()    {}
func (*MsgInstantPerpetualMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{11}
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantPerpetualMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantPerpetualMarketLaunchResponse proto.InternalMessageInfo

// MsgInstantBinaryOptionsMarketLaunch defines a SDK message for creating a new perpetual futures market by paying listing fee without governance
type MsgInstantBinaryOptionsMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle symbol
	OracleSymbol string `protobuf:"bytes,3,opt,name=oracle_symbol,json=oracleSymbol,proto3" json:"oracle_symbol,omitempty"`
	// Oracle Provider
	OracleProvider string `protobuf:"bytes,4,opt,name=oracle_provider,json=oracleProvider,proto3" json:"oracle_provider,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,5,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,6,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the perpetual market
	MakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate"`
	// taker_fee_rate defines the trade fee rate for takers on the perpetual market
	TakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,9,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,10,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// admin of the market
	Admin string `protobuf:"bytes,11,opt,name=admin,proto3" json:"admin,omitempty"`
	// Address of the quote currency denomination for the binary options contract
	QuoteDenom string `protobuf:"bytes,12,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price and margin required for orders in the market
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
}

func (m *MsgInstantBinaryOptionsMarketLaunch) Reset()         { *m = MsgInstantBinaryOptionsMarketLaunch{} }
func (m *MsgInstantBinaryOptionsMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantBinaryOptionsMarketLaunch) ProtoMessage()    {}
func (*MsgInstantBinaryOptionsMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{12}
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch.Merge(m, src)
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantBinaryOptionsMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunch proto.InternalMessageInfo

// MsgInstantBinaryOptionsMarketLaunchResponse defines the Msg/InstantBinaryOptionsMarketLaunchResponse response type.
type MsgInstantBinaryOptionsMarketLaunchResponse struct {
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Reset() {
	*m = MsgInstantBinaryOptionsMarketLaunchResponse{}
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgInstantBinaryOptionsMarketLaunchResponse) ProtoMessage() {}
func (*MsgInstantBinaryOptionsMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{13}
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantBinaryOptionsMarketLaunchResponse proto.InternalMessageInfo

// MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a new expiry futures market by paying listing fee without governance
type MsgInstantExpiryFuturesMarketLaunch struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,4,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,5,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,6,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Expiration time of the market
	Expiry int64 `protobuf:"varint,8,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the expiry futures market
	MakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate"`
	// taker_fee_rate defines the trade fee rate for takers on the expiry futures market
	TakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate"`
	// initial_margin_ratio defines the initial margin ratio for the derivative market
	InitialMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
	MaintenanceMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maintenance_margin_ratio"`
	// min_price_tick_size defines the minimum tick size of the order's price and margin
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
}

func (m *MsgInstantExpiryFuturesMarketLaunch) Reset()         { *m = MsgInstantExpiryFuturesMarketLaunch{} }
func (m *MsgInstantExpiryFuturesMarketLaunch) String() string { return proto.CompactTextString(m) }
func (*MsgInstantExpiryFuturesMarketLaunch) ProtoMessage()    {}
func (*MsgInstantExpiryFuturesMarketLaunch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{14}
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch.Merge(m, src)
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantExpiryFuturesMarketLaunch) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunch proto.InternalMessageInfo

// MsgInstantExpiryFuturesMarketLaunchResponse defines the Msg/InstantExpiryFuturesMarketLaunch response type.
type MsgInstantExpiryFuturesMarketLaunchResponse struct {
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Reset() {
	*m = MsgInstantExpiryFuturesMarketLaunchResponse{}
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgInstantExpiryFuturesMarketLaunchResponse) ProtoMessage() {}
func (*MsgInstantExpiryFuturesMarketLaunchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{15}
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse.Merge(m, src)
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInstantExpiryFuturesMarketLaunchResponse proto.InternalMessageInfo

// MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market order.
type MsgCreateSpotMarketOrder struct {
	Sender string    `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  SpotOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateSpotMarketOrder) Reset()         { *m = MsgCreateSpotMarketOrder{} }
func (m *MsgCreateSpotMarketOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotMarketOrder) ProtoMessage()    {}
func (*MsgCreateSpotMarketOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{16}
}
func (m *MsgCreateSpotMarketOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotMarketOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotMarketOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotMarketOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotMarketOrder.Merge(m, src)
}
func (m *MsgCreateSpotMarketOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotMarketOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotMarketOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotMarketOrder proto.InternalMessageInfo

// MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder response type.
type MsgCreateSpotMarketOrderResponse struct {
	OrderHash string                  `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Results   *SpotMarketOrderResults `protobuf:"bytes,2,opt,name=results,proto3" json:"results,omitempty"`
}

func (m *MsgCreateSpotMarketOrderResponse) Reset()         { *m = MsgCreateSpotMarketOrderResponse{} }
func (m *MsgCreateSpotMarketOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotMarketOrderResponse) ProtoMessage()    {}
func (*MsgCreateSpotMarketOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{17}
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotMarketOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotMarketOrderResponse.Merge(m, src)
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotMarketOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotMarketOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotMarketOrderResponse proto.InternalMessageInfo

type SpotMarketOrderResults struct {
	Quantity github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=quantity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"quantity"`
	Price    github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=price,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"price"`
	Fee      github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=fee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"fee"`
}

func (m *SpotMarketOrderResults) Reset()         { *m = SpotMarketOrderResults{} }
func (m *SpotMarketOrderResults) String() string { return proto.CompactTextString(m) }
func (*SpotMarketOrderResults) ProtoMessage()    {}
func (*SpotMarketOrderResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{18}
}
func (m *SpotMarketOrderResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarketOrderResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarketOrderResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarketOrderResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarketOrderResults.Merge(m, src)
}
func (m *SpotMarketOrderResults) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarketOrderResults) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarketOrderResults.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarketOrderResults proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateDerivativeLimitOrder
type MsgCreateDerivativeLimitOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateDerivativeLimitOrder) Reset()         { *m = MsgCreateDerivativeLimitOrder{} }
func (m *MsgCreateDerivativeLimitOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeLimitOrder) ProtoMessage()    {}
func (*MsgCreateDerivativeLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{19}
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeLimitOrder.Merge(m, src)
}
func (m *MsgCreateDerivativeLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeLimitOrder proto.InternalMessageInfo

// MsgCreateDerivativeLimitOrderResponse defines the Msg/CreateDerivativeMarketOrder response type.
type MsgCreateDerivativeLimitOrderResponse struct {
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
}

func (m *MsgCreateDerivativeLimitOrderResponse) Reset()         { *m = MsgCreateDerivativeLimitOrderResponse{} }
func (m *MsgCreateDerivativeLimitOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeLimitOrderResponse) ProtoMessage()    {}
func (*MsgCreateDerivativeLimitOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{20}
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse.Merge(m, src)
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeLimitOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeLimitOrderResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateBinaryOptionsLimitOrder
type MsgCreateBinaryOptionsLimitOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateBinaryOptionsLimitOrder) Reset()         { *m = MsgCreateBinaryOptionsLimitOrder{} }
func (m *MsgCreateBinaryOptionsLimitOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBinaryOptionsLimitOrder) ProtoMessage()    {}
func (*MsgCreateBinaryOptionsLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{21}
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsLimitOrder proto.InternalMessageInfo

// MsgCreateBinaryOptionsLimitOrderResponse defines the Msg/CreateBinaryOptionsLimitOrder response type.
type MsgCreateBinaryOptionsLimitOrderResponse struct {
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) Reset() {
	*m = MsgCreateBinaryOptionsLimitOrderResponse{}
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBinaryOptionsLimitOrderResponse) ProtoMessage()    {}
func (*MsgCreateBinaryOptionsLimitOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{22}
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsLimitOrderResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders
type MsgBatchCreateDerivativeLimitOrders struct {
	Sender string            `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Orders []DerivativeOrder `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders"`
}

func (m *MsgBatchCreateDerivativeLimitOrders) Reset()         { *m = MsgBatchCreateDerivativeLimitOrders{} }
func (m *MsgBatchCreateDerivativeLimitOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCreateDerivativeLimitOrders) ProtoMessage()    {}
func (*MsgBatchCreateDerivativeLimitOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{23}
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders.Merge(m, src)
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateDerivativeLimitOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateDerivativeLimitOrders proto.InternalMessageInfo

// MsgBatchCreateDerivativeLimitOrdersResponse defines the Msg/BatchCreateDerivativeLimitOrders response type.
type MsgBatchCreateDerivativeLimitOrdersResponse struct {
	OrderHashes []string `protobuf:"bytes,1,rep,name=order_hashes,json=orderHashes,proto3" json:"order_hashes,omitempty"`
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Reset() {
	*m = MsgBatchCreateDerivativeLimitOrdersResponse{}
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgBatchCreateDerivativeLimitOrdersResponse) ProtoMessage() {}
func (*MsgBatchCreateDerivativeLimitOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{24}
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCreateDerivativeLimitOrdersResponse proto.InternalMessageInfo

// MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type.
type MsgCancelSpotOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId     string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
}

func (m *MsgCancelSpotOrder) Reset()         { *m = MsgCancelSpotOrder{} }
func (m *MsgCancelSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelSpotOrder) ProtoMessage()    {}
func (*MsgCancelSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{25}
}
func (m *MsgCancelSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelSpotOrder.Merge(m, src)
}
func (m *MsgCancelSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelSpotOrder proto.InternalMessageInfo

// MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type.
type MsgCancelSpotOrderResponse struct {
}

func (m *MsgCancelSpotOrderResponse) Reset()         { *m = MsgCancelSpotOrderResponse{} }
func (m *MsgCancelSpotOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelSpotOrderResponse) ProtoMessage()    {}
func (*MsgCancelSpotOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{26}
}
func (m *MsgCancelSpotOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelSpotOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelSpotOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelSpotOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelSpotOrderResponse.Merge(m, src)
}
func (m *MsgCancelSpotOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelSpotOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelSpotOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelSpotOrderResponse proto.InternalMessageInfo

// MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type.
type MsgBatchCancelSpotOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Data   []OrderData `protobuf:"bytes,2,rep,name=data,proto3" json:"data"`
}

func (m *MsgBatchCancelSpotOrders) Reset()         { *m = MsgBatchCancelSpotOrders{} }
func (m *MsgBatchCancelSpotOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelSpotOrders) ProtoMessage()    {}
func (*MsgBatchCancelSpotOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{27}
}
func (m *MsgBatchCancelSpotOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelSpotOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelSpotOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelSpotOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelSpotOrders.Merge(m, src)
}
func (m *MsgBatchCancelSpotOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelSpotOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelSpotOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelSpotOrders proto.InternalMessageInfo

// MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders response type.
type MsgBatchCancelSpotOrdersResponse struct {
	Success []bool `protobuf:"varint,1,rep,packed,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgBatchCancelSpotOrdersResponse) Reset()         { *m = MsgBatchCancelSpotOrdersResponse{} }
func (m *MsgBatchCancelSpotOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelSpotOrdersResponse) ProtoMessage()    {}
func (*MsgBatchCancelSpotOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{28}
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelSpotOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelSpotOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelSpotOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelSpotOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelSpotOrdersResponse proto.InternalMessageInfo

// MsgBatchCancelBinaryOptionsOrders defines the Msg/BatchCancelBinaryOptionsOrders response type.
type MsgBatchCancelBinaryOptionsOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Data   []OrderData `protobuf:"bytes,2,rep,name=data,proto3" json:"data"`
}

func (m *MsgBatchCancelBinaryOptionsOrders) Reset()         { *m = MsgBatchCancelBinaryOptionsOrders{} }
func (m *MsgBatchCancelBinaryOptionsOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelBinaryOptionsOrders) ProtoMessage()    {}
func (*MsgBatchCancelBinaryOptionsOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{29}
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders.Merge(m, src)
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelBinaryOptionsOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelBinaryOptionsOrders proto.InternalMessageInfo

// BatchCancelBinaryOptionsOrdersResponse defines the Msg/BatchCancelBinaryOptionsOrders response type.
type MsgBatchCancelBinaryOptionsOrdersResponse struct {
	Success []bool `protobuf:"varint,1,rep,packed,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Reset() {
	*m = MsgBatchCancelBinaryOptionsOrdersResponse{}
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgBatchCancelBinaryOptionsOrdersResponse) ProtoMessage() {}
func (*MsgBatchCancelBinaryOptionsOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{30}
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelBinaryOptionsOrdersResponse proto.InternalMessageInfo

// MsgBatchUpdateOrders defines the Msg/BatchUpdateOrders response type.
type MsgBatchUpdateOrders struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// subaccount_id only used for the spot_market_ids_to_cancel_all and derivative_market_ids_to_cancel_all.
	SubaccountId                      string             `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	SpotMarketIdsToCancelAll          []string           `protobuf:"bytes,3,rep,name=spot_market_ids_to_cancel_all,json=spotMarketIdsToCancelAll,proto3" json:"spot_market_ids_to_cancel_all,omitempty"`
	DerivativeMarketIdsToCancelAll    []string           `protobuf:"bytes,4,rep,name=derivative_market_ids_to_cancel_all,json=derivativeMarketIdsToCancelAll,proto3" json:"derivative_market_ids_to_cancel_all,omitempty"`
	SpotOrdersToCancel                []*OrderData       `protobuf:"bytes,5,rep,name=spot_orders_to_cancel,json=spotOrdersToCancel,proto3" json:"spot_orders_to_cancel,omitempty"`
	DerivativeOrdersToCancel          []*OrderData       `protobuf:"bytes,6,rep,name=derivative_orders_to_cancel,json=derivativeOrdersToCancel,proto3" json:"derivative_orders_to_cancel,omitempty"`
	SpotOrdersToCreate                []*SpotOrder       `protobuf:"bytes,7,rep,name=spot_orders_to_create,json=spotOrdersToCreate,proto3" json:"spot_orders_to_create,omitempty"`
	DerivativeOrdersToCreate          []*DerivativeOrder `protobuf:"bytes,8,rep,name=derivative_orders_to_create,json=derivativeOrdersToCreate,proto3" json:"derivative_orders_to_create,omitempty"`
	BinaryOptionsOrdersToCancel       []*OrderData       `protobuf:"bytes,9,rep,name=binary_options_orders_to_cancel,json=binaryOptionsOrdersToCancel,proto3" json:"binary_options_orders_to_cancel,omitempty"`
	BinaryOptionsMarketIdsToCancelAll []string           `protobuf:"bytes,10,rep,name=binary_options_market_ids_to_cancel_all,json=binaryOptionsMarketIdsToCancelAll,proto3" json:"binary_options_market_ids_to_cancel_all,omitempty"`
	BinaryOptionsOrdersToCreate       []*DerivativeOrder `protobuf:"bytes,11,rep,name=binary_options_orders_to_create,json=binaryOptionsOrdersToCreate,proto3" json:"binary_options_orders_to_create,omitempty"`
}

func (m *MsgBatchUpdateOrders) Reset()         { *m = MsgBatchUpdateOrders{} }
func (m *MsgBatchUpdateOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchUpdateOrders) ProtoMessage()    {}
func (*MsgBatchUpdateOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{31}
}
func (m *MsgBatchUpdateOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchUpdateOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchUpdateOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchUpdateOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchUpdateOrders.Merge(m, src)
}
func (m *MsgBatchUpdateOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchUpdateOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchUpdateOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchUpdateOrders proto.InternalMessageInfo

// MsgBatchUpdateOrdersResponse defines the Msg/BatchUpdateOrders response type.
type MsgBatchUpdateOrdersResponse struct {
	SpotCancelSuccess          []bool   `protobuf:"varint,1,rep,packed,name=spot_cancel_success,json=spotCancelSuccess,proto3" json:"spot_cancel_success,omitempty"`
	DerivativeCancelSuccess    []bool   `protobuf:"varint,2,rep,packed,name=derivative_cancel_success,json=derivativeCancelSuccess,proto3" json:"derivative_cancel_success,omitempty"`
	SpotOrderHashes            []string `protobuf:"bytes,3,rep,name=spot_order_hashes,json=spotOrderHashes,proto3" json:"spot_order_hashes,omitempty"`
	DerivativeOrderHashes      []string `protobuf:"bytes,4,rep,name=derivative_order_hashes,json=derivativeOrderHashes,proto3" json:"derivative_order_hashes,omitempty"`
	BinaryOptionsCancelSuccess []bool   `protobuf:"varint,5,rep,packed,name=binary_options_cancel_success,json=binaryOptionsCancelSuccess,proto3" json:"binary_options_cancel_success,omitempty"`
	BinaryOptionsOrderHashes   []string `protobuf:"bytes,6,rep,name=binary_options_order_hashes,json=binaryOptionsOrderHashes,proto3" json:"binary_options_order_hashes,omitempty"`
}

func (m *MsgBatchUpdateOrdersResponse) Reset()         { *m = MsgBatchUpdateOrdersResponse{} }
func (m *MsgBatchUpdateOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchUpdateOrdersResponse) ProtoMessage()    {}
func (*MsgBatchUpdateOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{32}
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchUpdateOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchUpdateOrdersResponse.Merge(m, src)
}
func (m *MsgBatchUpdateOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchUpdateOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchUpdateOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchUpdateOrdersResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateDerivativeMarketOrder
type MsgCreateDerivativeMarketOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateDerivativeMarketOrder) Reset()         { *m = MsgCreateDerivativeMarketOrder{} }
func (m *MsgCreateDerivativeMarketOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeMarketOrder) ProtoMessage()    {}
func (*MsgCreateDerivativeMarketOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{33}
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeMarketOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeMarketOrder.Merge(m, src)
}
func (m *MsgCreateDerivativeMarketOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeMarketOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeMarketOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeMarketOrder proto.InternalMessageInfo

// MsgCreateDerivativeMarketOrderResponse defines the Msg/CreateDerivativeMarketOrder response type.
type MsgCreateDerivativeMarketOrderResponse struct {
	OrderHash string                        `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Results   *DerivativeMarketOrderResults `protobuf:"bytes,2,opt,name=results,proto3" json:"results,omitempty"`
}

func (m *MsgCreateDerivativeMarketOrderResponse) Reset() {
	*m = MsgCreateDerivativeMarketOrderResponse{}
}
func (m *MsgCreateDerivativeMarketOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeMarketOrderResponse) ProtoMessage()    {}
func (*MsgCreateDerivativeMarketOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{34}
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse.Merge(m, src)
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeMarketOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeMarketOrderResponse proto.InternalMessageInfo

type DerivativeMarketOrderResults struct {
	Quantity      github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=quantity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"quantity"`
	Price         github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=price,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"price"`
	Fee           github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=fee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"fee"`
	PositionDelta PositionDelta                          `protobuf:"bytes,4,opt,name=position_delta,json=positionDelta,proto3" json:"position_delta"`
	Payout        github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=payout,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"payout"`
}

func (m *DerivativeMarketOrderResults) Reset()         { *m = DerivativeMarketOrderResults{} }
func (m *DerivativeMarketOrderResults) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarketOrderResults) ProtoMessage()    {}
func (*DerivativeMarketOrderResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{35}
}
func (m *DerivativeMarketOrderResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarketOrderResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarketOrderResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarketOrderResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarketOrderResults.Merge(m, src)
}
func (m *DerivativeMarketOrderResults) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarketOrderResults) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarketOrderResults.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarketOrderResults proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateBinaryOptionsMarketOrder
type MsgCreateBinaryOptionsMarketOrder struct {
	Sender string          `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  DerivativeOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *MsgCreateBinaryOptionsMarketOrder) Reset()         { *m = MsgCreateBinaryOptionsMarketOrder{} }
func (m *MsgCreateBinaryOptionsMarketOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateBinaryOptionsMarketOrder) ProtoMessage()    {}
func (*MsgCreateBinaryOptionsMarketOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{36}
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsMarketOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsMarketOrder proto.InternalMessageInfo

// MsgCreateBinaryOptionsMarketOrderResponse defines the Msg/CreateBinaryOptionsMarketOrder response type.
type MsgCreateBinaryOptionsMarketOrderResponse struct {
	OrderHash string                        `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Results   *DerivativeMarketOrderResults `protobuf:"bytes,2,opt,name=results,proto3" json:"results,omitempty"`
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) Reset() {
	*m = MsgCreateBinaryOptionsMarketOrderResponse{}
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgCreateBinaryOptionsMarketOrderResponse) ProtoMessage() {}
func (*MsgCreateBinaryOptionsMarketOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{37}
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse.Merge(m, src)
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateBinaryOptionsMarketOrderResponse proto.InternalMessageInfo

// MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type.
type MsgCancelDerivativeOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId     string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	OrderMask    int32  `protobuf:"varint,5,opt,name=order_mask,json=orderMask,proto3" json:"order_mask,omitempty"`
}

func (m *MsgCancelDerivativeOrder) Reset()         { *m = MsgCancelDerivativeOrder{} }
func (m *MsgCancelDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelDerivativeOrder) ProtoMessage()    {}
func (*MsgCancelDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{38}
}
func (m *MsgCancelDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelDerivativeOrder.Merge(m, src)
}
func (m *MsgCancelDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelDerivativeOrder proto.InternalMessageInfo

// MsgCancelDerivativeOrderResponse defines the Msg/CancelDerivativeOrderResponse response type.
type MsgCancelDerivativeOrderResponse struct {
}

func (m *MsgCancelDerivativeOrderResponse) Reset()         { *m = MsgCancelDerivativeOrderResponse{} }
func (m *MsgCancelDerivativeOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelDerivativeOrderResponse) ProtoMessage()    {}
func (*MsgCancelDerivativeOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{39}
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelDerivativeOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelDerivativeOrderResponse.Merge(m, src)
}
func (m *MsgCancelDerivativeOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelDerivativeOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelDerivativeOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelDerivativeOrderResponse proto.InternalMessageInfo

// MsgCancelBinaryOptionsOrder defines the Msg/CancelBinaryOptionsOrder response type.
type MsgCancelBinaryOptionsOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId     string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	OrderMask    int32  `protobuf:"varint,5,opt,name=order_mask,json=orderMask,proto3" json:"order_mask,omitempty"`
}

func (m *MsgCancelBinaryOptionsOrder) Reset()         { *m = MsgCancelBinaryOptionsOrder{} }
func (m *MsgCancelBinaryOptionsOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelBinaryOptionsOrder) ProtoMessage()    {}
func (*MsgCancelBinaryOptionsOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{40}
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelBinaryOptionsOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelBinaryOptionsOrder.Merge(m, src)
}
func (m *MsgCancelBinaryOptionsOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelBinaryOptionsOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelBinaryOptionsOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelBinaryOptionsOrder proto.InternalMessageInfo

// MsgCancelBinaryOptionsOrderResponse defines the Msg/CancelBinaryOptionsOrderResponse response type.
type MsgCancelBinaryOptionsOrderResponse struct {
}

func (m *MsgCancelBinaryOptionsOrderResponse) Reset()         { *m = MsgCancelBinaryOptionsOrderResponse{} }
func (m *MsgCancelBinaryOptionsOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelBinaryOptionsOrderResponse) ProtoMessage()    {}
func (*MsgCancelBinaryOptionsOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{41}
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse.Merge(m, src)
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelBinaryOptionsOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelBinaryOptionsOrderResponse proto.InternalMessageInfo

type OrderData struct {
	MarketId     string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId string `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	OrderHash    string `protobuf:"bytes,3,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	OrderMask    int32  `protobuf:"varint,4,opt,name=order_mask,json=orderMask,proto3" json:"order_mask,omitempty"`
}

func (m *OrderData) Reset()         { *m = OrderData{} }
func (m *OrderData) String() string { return proto.CompactTextString(m) }
func (*OrderData) ProtoMessage()    {}
func (*OrderData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{42}
}
func (m *OrderData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderData.Merge(m, src)
}
func (m *OrderData) XXX_Size() int {
	return m.Size()
}
func (m *OrderData) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderData.DiscardUnknown(m)
}

var xxx_messageInfo_OrderData proto.InternalMessageInfo

func (m *OrderData) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *OrderData) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *OrderData) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *OrderData) GetOrderMask() int32 {
	if m != nil {
		return m.OrderMask
	}
	return 0
}

// MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders response type.
type MsgBatchCancelDerivativeOrders struct {
	Sender string      `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Data   []OrderData `protobuf:"bytes,2,rep,name=data,proto3" json:"data"`
}

func (m *MsgBatchCancelDerivativeOrders) Reset()         { *m = MsgBatchCancelDerivativeOrders{} }
func (m *MsgBatchCancelDerivativeOrders) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelDerivativeOrders) ProtoMessage()    {}
func (*MsgBatchCancelDerivativeOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{43}
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelDerivativeOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelDerivativeOrders.Merge(m, src)
}
func (m *MsgBatchCancelDerivativeOrders) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelDerivativeOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelDerivativeOrders.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelDerivativeOrders proto.InternalMessageInfo

// MsgBatchCancelDerivativeOrdersResponse defines the Msg/CancelDerivativeOrderResponse response type.
type MsgBatchCancelDerivativeOrdersResponse struct {
	Success []bool `protobuf:"varint,1,rep,packed,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgBatchCancelDerivativeOrdersResponse) Reset() {
	*m = MsgBatchCancelDerivativeOrdersResponse{}
}
func (m *MsgBatchCancelDerivativeOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchCancelDerivativeOrdersResponse) ProtoMessage()    {}
func (*MsgBatchCancelDerivativeOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{44}
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse.Merge(m, src)
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchCancelDerivativeOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchCancelDerivativeOrdersResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgSubaccountTransfer
type MsgSubaccountTransfer struct {
	Sender                  string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SourceSubaccountId      string     `protobuf:"bytes,2,opt,name=source_subaccount_id,json=sourceSubaccountId,proto3" json:"source_subaccount_id,omitempty"`
	DestinationSubaccountId string     `protobuf:"bytes,3,opt,name=destination_subaccount_id,json=destinationSubaccountId,proto3" json:"destination_subaccount_id,omitempty"`
	Amount                  types.Coin `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgSubaccountTransfer) Reset()         { *m = MsgSubaccountTransfer{} }
func (m *MsgSubaccountTransfer) String() string { return proto.CompactTextString(m) }
func (*MsgSubaccountTransfer) ProtoMessage()    {}
func (*MsgSubaccountTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{45}
}
func (m *MsgSubaccountTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubaccountTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubaccountTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubaccountTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubaccountTransfer.Merge(m, src)
}
func (m *MsgSubaccountTransfer) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubaccountTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubaccountTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubaccountTransfer proto.InternalMessageInfo

func (m *MsgSubaccountTransfer) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSubaccountTransfer) GetSourceSubaccountId() string {
	if m != nil {
		return m.SourceSubaccountId
	}
	return ""
}

func (m *MsgSubaccountTransfer) GetDestinationSubaccountId() string {
	if m != nil {
		return m.DestinationSubaccountId
	}
	return ""
}

func (m *MsgSubaccountTransfer) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response type.
type MsgSubaccountTransferResponse struct {
}

func (m *MsgSubaccountTransferResponse) Reset()         { *m = MsgSubaccountTransferResponse{} }
func (m *MsgSubaccountTransferResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubaccountTransferResponse) ProtoMessage()    {}
func (*MsgSubaccountTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{46}
}
func (m *MsgSubaccountTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubaccountTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubaccountTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubaccountTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubaccountTransferResponse.Merge(m, src)
}
func (m *MsgSubaccountTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubaccountTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubaccountTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubaccountTransferResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgExternalTransfer
type MsgExternalTransfer struct {
	Sender                  string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SourceSubaccountId      string     `protobuf:"bytes,2,opt,name=source_subaccount_id,json=sourceSubaccountId,proto3" json:"source_subaccount_id,omitempty"`
	DestinationSubaccountId string     `protobuf:"bytes,3,opt,name=destination_subaccount_id,json=destinationSubaccountId,proto3" json:"destination_subaccount_id,omitempty"`
	Amount                  types.Coin `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgExternalTransfer) Reset()         { *m = MsgExternalTransfer{} }
func (m *MsgExternalTransfer) String() string { return proto.CompactTextString(m) }
func (*MsgExternalTransfer) ProtoMessage()    {}
func (*MsgExternalTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{47}
}
func (m *MsgExternalTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExternalTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExternalTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExternalTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExternalTransfer.Merge(m, src)
}
func (m *MsgExternalTransfer) XXX_Size() int {
	return m.Size()
}
func (m *MsgExternalTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExternalTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExternalTransfer proto.InternalMessageInfo

func (m *MsgExternalTransfer) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgExternalTransfer) GetSourceSubaccountId() string {
	if m != nil {
		return m.SourceSubaccountId
	}
	return ""
}

func (m *MsgExternalTransfer) GetDestinationSubaccountId() string {
	if m != nil {
		return m.DestinationSubaccountId
	}
	return ""
}

func (m *MsgExternalTransfer) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgExternalTransferResponse defines the Msg/ExternalTransfer response type.
type MsgExternalTransferResponse struct {
}

func (m *MsgExternalTransferResponse) Reset()         { *m = MsgExternalTransferResponse{} }
func (m *MsgExternalTransferResponse) String() string { return proto.CompactTextString(m) }
func (*MsgExternalTransferResponse) ProtoMessage()    {}
func (*MsgExternalTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{48}
}
func (m *MsgExternalTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExternalTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExternalTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExternalTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExternalTransferResponse.Merge(m, src)
}
func (m *MsgExternalTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgExternalTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExternalTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExternalTransferResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgLiquidatePosition
type MsgLiquidatePosition struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SubaccountId string `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	MarketId     string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// optional order to provide for liquidation
	Order *DerivativeOrder `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *MsgLiquidatePosition) Reset()         { *m = MsgLiquidatePosition{} }
func (m *MsgLiquidatePosition) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidatePosition) ProtoMessage()    {}
func (*MsgLiquidatePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{49}
}
func (m *MsgLiquidatePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidatePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidatePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidatePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidatePosition.Merge(m, src)
}
func (m *MsgLiquidatePosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidatePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidatePosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidatePosition proto.InternalMessageInfo

func (m *MsgLiquidatePosition) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgLiquidatePosition) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *MsgLiquidatePosition) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgLiquidatePosition) GetOrder() *DerivativeOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

// MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response type.
type MsgLiquidatePositionResponse struct {
}

func (m *MsgLiquidatePositionResponse) Reset()         { *m = MsgLiquidatePositionResponse{} }
func (m *MsgLiquidatePositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgLiquidatePositionResponse) ProtoMessage()    {}
func (*MsgLiquidatePositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{50}
}
func (m *MsgLiquidatePositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLiquidatePositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLiquidatePositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLiquidatePositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLiquidatePositionResponse.Merge(m, src)
}
func (m *MsgLiquidatePositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgLiquidatePositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLiquidatePositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLiquidatePositionResponse proto.InternalMessageInfo

// A Cosmos-SDK MsgIncreasePositionMargin
type MsgIncreasePositionMargin struct {
	Sender                  string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SourceSubaccountId      string `protobuf:"bytes,2,opt,name=source_subaccount_id,json=sourceSubaccountId,proto3" json:"source_subaccount_id,omitempty"`
	DestinationSubaccountId string `protobuf:"bytes,3,opt,name=destination_subaccount_id,json=destinationSubaccountId,proto3" json:"destination_subaccount_id,omitempty"`
	MarketId                string `protobuf:"bytes,4,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// amount defines the amount of margin to add to the position
	Amount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *MsgIncreasePositionMargin) Reset()         { *m = MsgIncreasePositionMargin{} }
func (m *MsgIncreasePositionMargin) String() string { return proto.CompactTextString(m) }
func (*MsgIncreasePositionMargin) ProtoMessage()    {}
func (*MsgIncreasePositionMargin) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{51}
}
func (m *MsgIncreasePositionMargin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIncreasePositionMargin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIncreasePositionMargin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIncreasePositionMargin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIncreasePositionMargin.Merge(m, src)
}
func (m *MsgIncreasePositionMargin) XXX_Size() int {
	return m.Size()
}
func (m *MsgIncreasePositionMargin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIncreasePositionMargin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIncreasePositionMargin proto.InternalMessageInfo

func (m *MsgIncreasePositionMargin) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgIncreasePositionMargin) GetSourceSubaccountId() string {
	if m != nil {
		return m.SourceSubaccountId
	}
	return ""
}

func (m *MsgIncreasePositionMargin) GetDestinationSubaccountId() string {
	if m != nil {
		return m.DestinationSubaccountId
	}
	return ""
}

func (m *MsgIncreasePositionMargin) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

// MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin response type.
type MsgIncreasePositionMarginResponse struct {
}

func (m *MsgIncreasePositionMarginResponse) Reset()         { *m = MsgIncreasePositionMarginResponse{} }
func (m *MsgIncreasePositionMarginResponse) String() string { return proto.CompactTextString(m) }
func (*MsgIncreasePositionMarginResponse) ProtoMessage()    {}
func (*MsgIncreasePositionMarginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{52}
}
func (m *MsgIncreasePositionMarginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIncreasePositionMarginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIncreasePositionMarginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIncreasePositionMarginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIncreasePositionMarginResponse.Merge(m, src)
}
func (m *MsgIncreasePositionMarginResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgIncreasePositionMarginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIncreasePositionMarginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIncreasePositionMarginResponse proto.InternalMessageInfo

// MsgExec defines the Msg/Exec message type
type MsgExec struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// bank_funds defines the user's coins used to fund the execution
	BankFunds github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=bank_funds,json=bankFunds,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"bank_funds"`
	// deposits_subaccount_id defines the user's subaccountID to fund the execution
	DepositsSubaccountId string `protobuf:"bytes,3,opt,name=deposits_subaccount_id,json=depositsSubaccountId,proto3" json:"deposits_subaccount_id,omitempty"`
	// deposit_funds defines the fund amounts to fund the execution
	DepositFunds github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,4,rep,name=deposit_funds,json=depositFunds,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"deposit_funds"`
	// contract_address defines the contract address to execute
	ContractAddress string `protobuf:"bytes,5,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	// data defines the call data used when executing the contract
	Data string `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgExec) Reset()         { *m = MsgExec{} }
func (m *MsgExec) String() string { return proto.CompactTextString(m) }
func (*MsgExec) ProtoMessage()    {}
func (*MsgExec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{53}
}
func (m *MsgExec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExec.Merge(m, src)
}
func (m *MsgExec) XXX_Size() int {
	return m.Size()
}
func (m *MsgExec) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExec.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExec proto.InternalMessageInfo

// MsgExecResponse defines the Msg/Exec response type.
type MsgExecResponse struct {
}

func (m *MsgExecResponse) Reset()         { *m = MsgExecResponse{} }
func (m *MsgExecResponse) String() string { return proto.CompactTextString(m) }
func (*MsgExecResponse) ProtoMessage()    {}
func (*MsgExecResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{54}
}
func (m *MsgExecResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExecResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExecResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExecResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExecResponse.Merge(m, src)
}
func (m *MsgExecResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgExecResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExecResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExecResponse proto.InternalMessageInfo

type SpotMarketParamUpdateProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId    string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// maker_fee_rate defines the trade fee rate for makers on the spot market
	MakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the trade fee rate for takers on the spot market
	TakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the relayer fee share rate for the spot market
	RelayerFeeShareRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"relayer_fee_share_rate,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price and margin
	MinPriceTickSize *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size,omitempty"`
	Status              MarketStatus                            `protobuf:"varint,9,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
}

func (m *SpotMarketParamUpdateProposal) Reset()         { *m = SpotMarketParamUpdateProposal{} }
func (m *SpotMarketParamUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*SpotMarketParamUpdateProposal) ProtoMessage()    {}
func (*SpotMarketParamUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{55}
}
func (m *SpotMarketParamUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarketParamUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarketParamUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarketParamUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarketParamUpdateProposal.Merge(m, src)
}
func (m *SpotMarketParamUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarketParamUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarketParamUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarketParamUpdateProposal proto.InternalMessageInfo

type ExchangeEnableProposal struct {
	Title        string       `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description  string       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ExchangeType ExchangeType `protobuf:"varint,3,opt,name=exchangeType,proto3,enum=injective.exchange.v1beta1.ExchangeType" json:"exchangeType,omitempty"`
}

func (m *ExchangeEnableProposal) Reset()         { *m = ExchangeEnableProposal{} }
func (m *ExchangeEnableProposal) String() string { return proto.CompactTextString(m) }
func (*ExchangeEnableProposal) ProtoMessage()    {}
func (*ExchangeEnableProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{56}
}
func (m *ExchangeEnableProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeEnableProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeEnableProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeEnableProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeEnableProposal.Merge(m, src)
}
func (m *ExchangeEnableProposal) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeEnableProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeEnableProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeEnableProposal proto.InternalMessageInfo

type BatchExchangeModificationProposal struct {
	Title                                string                                    `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description                          string                                    `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	SpotMarketParamUpdateProposals       []*SpotMarketParamUpdateProposal          `protobuf:"bytes,3,rep,name=spot_market_param_update_proposals,json=spotMarketParamUpdateProposals,proto3" json:"spot_market_param_update_proposals,omitempty"`
	DerivativeMarketParamUpdateProposals []*DerivativeMarketParamUpdateProposal    `protobuf:"bytes,4,rep,name=derivative_market_param_update_proposals,json=derivativeMarketParamUpdateProposals,proto3" json:"derivative_market_param_update_proposals,omitempty"`
	SpotMarketLaunchProposals            []*SpotMarketLaunchProposal               `protobuf:"bytes,5,rep,name=spot_market_launch_proposals,json=spotMarketLaunchProposals,proto3" json:"spot_market_launch_proposals,omitempty"`
	PerpetualMarketLaunchProposals       []*PerpetualMarketLaunchProposal          `protobuf:"bytes,6,rep,name=perpetual_market_launch_proposals,json=perpetualMarketLaunchProposals,proto3" json:"perpetual_market_launch_proposals,omitempty"`
	ExpiryFuturesMarketLaunchProposals   []*ExpiryFuturesMarketLaunchProposal      `protobuf:"bytes,7,rep,name=expiry_futures_market_launch_proposals,json=expiryFuturesMarketLaunchProposals,proto3" json:"expiry_futures_market_launch_proposals,omitempty"`
	TradingRewardCampaignUpdateProposal  *TradingRewardCampaignUpdateProposal      `protobuf:"bytes,8,opt,name=trading_reward_campaign_update_proposal,json=tradingRewardCampaignUpdateProposal,proto3" json:"trading_reward_campaign_update_proposal,omitempty"`
	BinaryOptionsMarketLaunchProposals   []*BinaryOptionsMarketLaunchProposal      `protobuf:"bytes,9,rep,name=binary_options_market_launch_proposals,json=binaryOptionsMarketLaunchProposals,proto3" json:"binary_options_market_launch_proposals,omitempty"`
	BinaryOptionsParamUpdateProposals    []*BinaryOptionsMarketParamUpdateProposal `protobuf:"bytes,10,rep,name=binary_options_param_update_proposals,json=binaryOptionsParamUpdateProposals,proto3" json:"binary_options_param_update_proposals,omitempty"`
	DenomDecimalsUpdateProposal          *UpdateDenomDecimalsProposal              `protobuf:"bytes,11,opt,name=denom_decimals_update_proposal,json=denomDecimalsUpdateProposal,proto3" json:"denom_decimals_update_proposal,omitempty"`
}

func (m *BatchExchangeModificationProposal) Reset()         { *m = BatchExchangeModificationProposal{} }
func (m *BatchExchangeModificationProposal) String() string { return proto.CompactTextString(m) }
func (*BatchExchangeModificationProposal) ProtoMessage()    {}
func (*BatchExchangeModificationProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{57}
}
func (m *BatchExchangeModificationProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchExchangeModificationProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchExchangeModificationProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchExchangeModificationProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchExchangeModificationProposal.Merge(m, src)
}
func (m *BatchExchangeModificationProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchExchangeModificationProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchExchangeModificationProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchExchangeModificationProposal proto.InternalMessageInfo

// SpotMarketLaunchProposal defines a SDK message for proposing a new spot market through governance
type SpotMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the spot market.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	BaseDenom string `protobuf:"bytes,4,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,5,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
	// maker_fee_rate defines the fee percentage makers pay when trading
	MakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the fee percentage takers pay when trading
	TakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate,omitempty"`
}

func (m *SpotMarketLaunchProposal) Reset()         { *m = SpotMarketLaunchProposal{} }
func (m *SpotMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*SpotMarketLaunchProposal) ProtoMessage()    {}
func (*SpotMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{58}
}
func (m *SpotMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotMarketLaunchProposal.Merge(m, src)
}
func (m *SpotMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *SpotMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SpotMarketLaunchProposal proto.InternalMessageInfo

// PerpetualMarketLaunchProposal defines a SDK message for proposing a new perpetual futures market through governance
type PerpetualMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the base currency
	QuoteDenom string `protobuf:"bytes,4,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,5,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,6,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,8,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// initial_margin_ratio defines the initial margin ratio for the derivative market
	InitialMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
	MaintenanceMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maintenance_margin_ratio"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative market
	MakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative market
	TakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate"`
	// min_price_tick_size defines the minimum tick size of the order's price and margin
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
}

func (m *PerpetualMarketLaunchProposal) Reset()         { *m = PerpetualMarketLaunchProposal{} }
func (m *PerpetualMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*PerpetualMarketLaunchProposal) ProtoMessage()    {}
func (*PerpetualMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{59}
}
func (m *PerpetualMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerpetualMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerpetualMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerpetualMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerpetualMarketLaunchProposal.Merge(m, src)
}
func (m *PerpetualMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *PerpetualMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_PerpetualMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_PerpetualMarketLaunchProposal proto.InternalMessageInfo

type BinaryOptionsMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle symbol
	OracleSymbol string `protobuf:"bytes,4,opt,name=oracle_symbol,json=oracleSymbol,proto3" json:"oracle_symbol,omitempty"`
	// Oracle Provider
	OracleProvider string `protobuf:"bytes,5,opt,name=oracle_provider,json=oracleProvider,proto3" json:"oracle_provider,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,6,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,8,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,9,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// admin of the market
	Admin string `protobuf:"bytes,10,opt,name=admin,proto3" json:"admin,omitempty"`
	// Address of the quote currency denomination for the binary options contract
	QuoteDenom string `protobuf:"bytes,11,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// maker_fee_rate defines the maker fee rate of a binary options market
	MakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate"`
	// taker_fee_rate defines the taker fee rate of a derivative market
	TakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate"`
	// min_price_tick_size defines the minimum tick size that the price and margin required for orders in the market
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,15,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
}

func (m *BinaryOptionsMarketLaunchProposal) Reset()         { *m = BinaryOptionsMarketLaunchProposal{} }
func (m *BinaryOptionsMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*BinaryOptionsMarketLaunchProposal) ProtoMessage()    {}
func (*BinaryOptionsMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{60}
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOptionsMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOptionsMarketLaunchProposal.Merge(m, src)
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOptionsMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOptionsMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOptionsMarketLaunchProposal proto.InternalMessageInfo

// ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new expiry futures market through governance
type ExpiryFuturesMarketLaunchProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ticker for the derivative market.
	Ticker string `protobuf:"bytes,3,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// type of coin to use as the quote currency
	QuoteDenom string `protobuf:"bytes,4,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,5,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,6,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,7,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,8,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Expiration time of the market
	Expiry int64 `protobuf:"varint,9,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// initial_margin_ratio defines the initial margin ratio for the derivative market
	InitialMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"initial_margin_ratio"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
	MaintenanceMarginRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maintenance_margin_ratio"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative market
	MakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative market
	TakerFeeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,13,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate"`
	// min_price_tick_size defines the minimum tick size of the order's price and margin
	MinPriceTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,14,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,15,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size"`
}

func (m *ExpiryFuturesMarketLaunchProposal) Reset()         { *m = ExpiryFuturesMarketLaunchProposal{} }
func (m *ExpiryFuturesMarketLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*ExpiryFuturesMarketLaunchProposal) ProtoMessage()    {}
func (*ExpiryFuturesMarketLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{61}
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpiryFuturesMarketLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpiryFuturesMarketLaunchProposal.Merge(m, src)
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *ExpiryFuturesMarketLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpiryFuturesMarketLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ExpiryFuturesMarketLaunchProposal proto.InternalMessageInfo

type DerivativeMarketParamUpdateProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId    string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// initial_margin_ratio defines the initial margin ratio for the derivative market
	InitialMarginRatio *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"initial_margin_ratio,omitempty"`
	// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
	MaintenanceMarginRatio *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maintenance_margin_ratio,omitempty"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative market
	MakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative market
	TakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the relayer fee share rate for the derivative market
	RelayerFeeShareRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"relayer_fee_share_rate,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price and margin
	MinPriceTickSize *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size,omitempty"`
	// hourly_interest_rate defines the hourly interest rate
	HourlyInterestRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=HourlyInterestRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"HourlyInterestRate,omitempty"`
	// hourly_funding_rate_cap defines the maximum absolute value of the hourly funding rate
	HourlyFundingRateCap *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=HourlyFundingRateCap,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"HourlyFundingRateCap,omitempty"`
	Status               MarketStatus                            `protobuf:"varint,13,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	OracleParams         *OracleParams                           `protobuf:"bytes,14,opt,name=oracle_params,json=oracleParams,proto3" json:"oracle_params,omitempty"`
}

func (m *DerivativeMarketParamUpdateProposal) Reset()         { *m = DerivativeMarketParamUpdateProposal{} }
func (m *DerivativeMarketParamUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarketParamUpdateProposal) ProtoMessage()    {}
func (*DerivativeMarketParamUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{62}
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarketParamUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarketParamUpdateProposal.Merge(m, src)
}
func (m *DerivativeMarketParamUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarketParamUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarketParamUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarketParamUpdateProposal proto.InternalMessageInfo

type MarketForcedSettlementProposal struct {
	Title           string                                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description     string                                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId        string                                  `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SettlementPrice *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=settlement_price,json=settlementPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"settlement_price,omitempty"`
}

func (m *MarketForcedSettlementProposal) Reset()         { *m = MarketForcedSettlementProposal{} }
func (m *MarketForcedSettlementProposal) String() string { return proto.CompactTextString(m) }
func (*MarketForcedSettlementProposal) ProtoMessage()    {}
func (*MarketForcedSettlementProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{63}
}
func (m *MarketForcedSettlementProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketForcedSettlementProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketForcedSettlementProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketForcedSettlementProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketForcedSettlementProposal.Merge(m, src)
}
func (m *MarketForcedSettlementProposal) XXX_Size() int {
	return m.Size()
}
func (m *MarketForcedSettlementProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketForcedSettlementProposal.DiscardUnknown(m)
}

var xxx_messageInfo_MarketForcedSettlementProposal proto.InternalMessageInfo

type UpdateDenomDecimalsProposal struct {
	Title         string           `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description   string           `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	DenomDecimals []*DenomDecimals `protobuf:"bytes,3,rep,name=denom_decimals,json=denomDecimals,proto3" json:"denom_decimals,omitempty"`
}

func (m *UpdateDenomDecimalsProposal) Reset()         { *m = UpdateDenomDecimalsProposal{} }
func (m *UpdateDenomDecimalsProposal) String() string { return proto.CompactTextString(m) }
func (*UpdateDenomDecimalsProposal) ProtoMessage()    {}
func (*UpdateDenomDecimalsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{64}
}
func (m *UpdateDenomDecimalsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDenomDecimalsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDenomDecimalsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDenomDecimalsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDenomDecimalsProposal.Merge(m, src)
}
func (m *UpdateDenomDecimalsProposal) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDenomDecimalsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDenomDecimalsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDenomDecimalsProposal proto.InternalMessageInfo

type DenomDecimals struct {
	Denom    string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Decimals uint64 `protobuf:"varint,2,opt,name=decimals,proto3" json:"decimals,omitempty"`
}

func (m *DenomDecimals) Reset()         { *m = DenomDecimals{} }
func (m *DenomDecimals) String() string { return proto.CompactTextString(m) }
func (*DenomDecimals) ProtoMessage()    {}
func (*DenomDecimals) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{65}
}
func (m *DenomDecimals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomDecimals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomDecimals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomDecimals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomDecimals.Merge(m, src)
}
func (m *DenomDecimals) XXX_Size() int {
	return m.Size()
}
func (m *DenomDecimals) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomDecimals.DiscardUnknown(m)
}

var xxx_messageInfo_DenomDecimals proto.InternalMessageInfo

func (m *DenomDecimals) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *DenomDecimals) GetDecimals() uint64 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

type BinaryOptionsMarketParamUpdateProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketId    string `protobuf:"bytes,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// maker_fee_rate defines the exchange trade fee for makers for the derivative market
	MakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=maker_fee_rate,json=makerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the exchange trade fee for takers for the derivative market
	TakerFeeRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=taker_fee_rate,json=takerFeeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the relayer fee share rate for the derivative market
	RelayerFeeShareRate *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"relayer_fee_share_rate,omitempty"`
	// min_price_tick_size defines the minimum tick size of the order's price and margin
	MinPriceTickSize *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=min_price_tick_size,json=minPriceTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the order's quantity
	MinQuantityTickSize *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_quantity_tick_size,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,9,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,10,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// new price at which market will be settled
	SettlementPrice *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=settlement_price,json=settlementPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"settlement_price,omitempty"`
	// admin of the market
	Admin        string                `protobuf:"bytes,12,opt,name=admin,proto3" json:"admin,omitempty"`
	Status       MarketStatus          `protobuf:"varint,13,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	OracleParams *ProviderOracleParams `protobuf:"bytes,14,opt,name=oracle_params,json=oracleParams,proto3" json:"oracle_params,omitempty"`
}

func (m *BinaryOptionsMarketParamUpdateProposal) Reset() {
	*m = BinaryOptionsMarketParamUpdateProposal{}
}
func (m *BinaryOptionsMarketParamUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*BinaryOptionsMarketParamUpdateProposal) ProtoMessage()    {}
func (*BinaryOptionsMarketParamUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{66}
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal.Merge(m, src)
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *BinaryOptionsMarketParamUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryOptionsMarketParamUpdateProposal proto.InternalMessageInfo

type ProviderOracleParams struct {
	// Oracle base currency
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Oracle quote currency
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,3,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
}

func (m *ProviderOracleParams) Reset()         { *m = ProviderOracleParams{} }
func (m *ProviderOracleParams) String() string { return proto.CompactTextString(m) }
func (*ProviderOracleParams) ProtoMessage()    {}
func (*ProviderOracleParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{67}
}
func (m *ProviderOracleParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderOracleParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderOracleParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderOracleParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderOracleParams.Merge(m, src)
}
func (m *ProviderOracleParams) XXX_Size() int {
	return m.Size()
}
func (m *ProviderOracleParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderOracleParams.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderOracleParams proto.InternalMessageInfo

func (m *ProviderOracleParams) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *ProviderOracleParams) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ProviderOracleParams) GetOracleScaleFactor() uint32 {
	if m != nil {
		return m.OracleScaleFactor
	}
	return 0
}

func (m *ProviderOracleParams) GetOracleType() types1.OracleType {
	if m != nil {
		return m.OracleType
	}
	return types1.OracleType_Unspecified
}

type OracleParams struct {
	// Oracle base currency
	OracleBase string `protobuf:"bytes,1,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,2,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,3,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
}

func (m *OracleParams) Reset()         { *m = OracleParams{} }
func (m *OracleParams) String() string { return proto.CompactTextString(m) }
func (*OracleParams) ProtoMessage()    {}
func (*OracleParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{68}
}
func (m *OracleParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleParams.Merge(m, src)
}
func (m *OracleParams) XXX_Size() int {
	return m.Size()
}
func (m *OracleParams) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleParams.DiscardUnknown(m)
}

var xxx_messageInfo_OracleParams proto.InternalMessageInfo

func (m *OracleParams) GetOracleBase() string {
	if m != nil {
		return m.OracleBase
	}
	return ""
}

func (m *OracleParams) GetOracleQuote() string {
	if m != nil {
		return m.OracleQuote
	}
	return ""
}

func (m *OracleParams) GetOracleScaleFactor() uint32 {
	if m != nil {
		return m.OracleScaleFactor
	}
	return 0
}

func (m *OracleParams) GetOracleType() types1.OracleType {
	if m != nil {
		return m.OracleType
	}
	return types1.OracleType_Unspecified
}

type TradingRewardCampaignLaunchProposal struct {
	Title               string                     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description         string                     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	CampaignInfo        *TradingRewardCampaignInfo `protobuf:"bytes,3,opt,name=campaign_info,json=campaignInfo,proto3" json:"campaign_info,omitempty"`
	CampaignRewardPools []*CampaignRewardPool      `protobuf:"bytes,4,rep,name=campaign_reward_pools,json=campaignRewardPools,proto3" json:"campaign_reward_pools,omitempty"`
}

func (m *TradingRewardCampaignLaunchProposal) Reset()         { *m = TradingRewardCampaignLaunchProposal{} }
func (m *TradingRewardCampaignLaunchProposal) String() string { return proto.CompactTextString(m) }
func (*TradingRewardCampaignLaunchProposal) ProtoMessage()    {}
func (*TradingRewardCampaignLaunchProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{69}
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingRewardCampaignLaunchProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingRewardCampaignLaunchProposal.Merge(m, src)
}
func (m *TradingRewardCampaignLaunchProposal) XXX_Size() int {
	return m.Size()
}
func (m *TradingRewardCampaignLaunchProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingRewardCampaignLaunchProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TradingRewardCampaignLaunchProposal proto.InternalMessageInfo

type TradingRewardCampaignUpdateProposal struct {
	Title                        string                     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description                  string                     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	CampaignInfo                 *TradingRewardCampaignInfo `protobuf:"bytes,3,opt,name=campaign_info,json=campaignInfo,proto3" json:"campaign_info,omitempty"`
	CampaignRewardPoolsAdditions []*CampaignRewardPool      `protobuf:"bytes,4,rep,name=campaign_reward_pools_additions,json=campaignRewardPoolsAdditions,proto3" json:"campaign_reward_pools_additions,omitempty"`
	CampaignRewardPoolsUpdates   []*CampaignRewardPool      `protobuf:"bytes,5,rep,name=campaign_reward_pools_updates,json=campaignRewardPoolsUpdates,proto3" json:"campaign_reward_pools_updates,omitempty"`
}

func (m *TradingRewardCampaignUpdateProposal) Reset()         { *m = TradingRewardCampaignUpdateProposal{} }
func (m *TradingRewardCampaignUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*TradingRewardCampaignUpdateProposal) ProtoMessage()    {}
func (*TradingRewardCampaignUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{70}
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingRewardCampaignUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingRewardCampaignUpdateProposal.Merge(m, src)
}
func (m *TradingRewardCampaignUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *TradingRewardCampaignUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingRewardCampaignUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TradingRewardCampaignUpdateProposal proto.InternalMessageInfo

type RewardPointUpdate struct {
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address,omitempty"`
	// new_points overwrites the current trading reward points for the account
	NewPoints github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,12,opt,name=new_points,json=newPoints,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"new_points"`
}

func (m *RewardPointUpdate) Reset()         { *m = RewardPointUpdate{} }
func (m *RewardPointUpdate) String() string { return proto.CompactTextString(m) }
func (*RewardPointUpdate) ProtoMessage()    {}
func (*RewardPointUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{71}
}
func (m *RewardPointUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardPointUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardPointUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardPointUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardPointUpdate.Merge(m, src)
}
func (m *RewardPointUpdate) XXX_Size() int {
	return m.Size()
}
func (m *RewardPointUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardPointUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_RewardPointUpdate proto.InternalMessageInfo

func (m *RewardPointUpdate) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

type TradingRewardPendingPointsUpdateProposal struct {
	Title                string               `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description          string               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	PendingPoolTimestamp int64                `protobuf:"varint,3,opt,name=pending_pool_timestamp,json=pendingPoolTimestamp,proto3" json:"pending_pool_timestamp,omitempty"`
	RewardPointUpdates   []*RewardPointUpdate `protobuf:"bytes,4,rep,name=reward_point_updates,json=rewardPointUpdates,proto3" json:"reward_point_updates,omitempty"`
}

func (m *TradingRewardPendingPointsUpdateProposal) Reset() {
	*m = TradingRewardPendingPointsUpdateProposal{}
}
func (m *TradingRewardPendingPointsUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*TradingRewardPendingPointsUpdateProposal) ProtoMessage()    {}
func (*TradingRewardPendingPointsUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{72}
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradingRewardPendingPointsUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradingRewardPendingPointsUpdateProposal.Merge(m, src)
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *TradingRewardPendingPointsUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_TradingRewardPendingPointsUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_TradingRewardPendingPointsUpdateProposal proto.InternalMessageInfo

type FeeDiscountProposal struct {
	Title       string               `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Schedule    *FeeDiscountSchedule `protobuf:"bytes,3,opt,name=schedule,proto3" json:"schedule,omitempty"`
}

func (m *FeeDiscountProposal) Reset()         { *m = FeeDiscountProposal{} }
func (m *FeeDiscountProposal) String() string { return proto.CompactTextString(m) }
func (*FeeDiscountProposal) ProtoMessage()    {}
func (*FeeDiscountProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{73}
}
func (m *FeeDiscountProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeDiscountProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeDiscountProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeDiscountProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeDiscountProposal.Merge(m, src)
}
func (m *FeeDiscountProposal) XXX_Size() int {
	return m.Size()
}
func (m *FeeDiscountProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeDiscountProposal.DiscardUnknown(m)
}

var xxx_messageInfo_FeeDiscountProposal proto.InternalMessageInfo

type BatchCommunityPoolSpendProposal struct {
	Title       string                               `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string                               `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Proposals   []*types2.CommunityPoolSpendProposal `protobuf:"bytes,3,rep,name=proposals,proto3" json:"proposals,omitempty"`
}

func (m *BatchCommunityPoolSpendProposal) Reset()         { *m = BatchCommunityPoolSpendProposal{} }
func (m *BatchCommunityPoolSpendProposal) String() string { return proto.CompactTextString(m) }
func (*BatchCommunityPoolSpendProposal) ProtoMessage()    {}
func (*BatchCommunityPoolSpendProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{74}
}
func (m *BatchCommunityPoolSpendProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchCommunityPoolSpendProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchCommunityPoolSpendProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchCommunityPoolSpendProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCommunityPoolSpendProposal.Merge(m, src)
}
func (m *BatchCommunityPoolSpendProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchCommunityPoolSpendProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCommunityPoolSpendProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCommunityPoolSpendProposal proto.InternalMessageInfo

// A Cosmos-SDK MsgRewardsOptOut
type MsgRewardsOptOut struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *MsgRewardsOptOut) Reset()         { *m = MsgRewardsOptOut{} }
func (m *MsgRewardsOptOut) String() string { return proto.CompactTextString(m) }
func (*MsgRewardsOptOut) ProtoMessage()    {}
func (*MsgRewardsOptOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{75}
}
func (m *MsgRewardsOptOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRewardsOptOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRewardsOptOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRewardsOptOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRewardsOptOut.Merge(m, src)
}
func (m *MsgRewardsOptOut) XXX_Size() int {
	return m.Size()
}
func (m *MsgRewardsOptOut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRewardsOptOut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRewardsOptOut proto.InternalMessageInfo

func (m *MsgRewardsOptOut) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// MsgRewardsOptOutResponse defines the Msg/RewardsOptOut response type.
type MsgRewardsOptOutResponse struct {
}

func (m *MsgRewardsOptOutResponse) Reset()         { *m = MsgRewardsOptOutResponse{} }
func (m *MsgRewardsOptOutResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRewardsOptOutResponse) ProtoMessage()    {}
func (*MsgRewardsOptOutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{76}
}
func (m *MsgRewardsOptOutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRewardsOptOutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRewardsOptOutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRewardsOptOutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRewardsOptOutResponse.Merge(m, src)
}
func (m *MsgRewardsOptOutResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRewardsOptOutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRewardsOptOutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRewardsOptOutResponse proto.InternalMessageInfo

// MsgAdminUpdateBinaryOptionsMarket is used by the market Admin to operate the market
type MsgAdminUpdateBinaryOptionsMarket struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// new price at which market will be settled
	SettlementPrice *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=settlement_price,json=settlementPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"settlement_price,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,4,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,5,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,6,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
}

func (m *MsgAdminUpdateBinaryOptionsMarket) Reset()         { *m = MsgAdminUpdateBinaryOptionsMarket{} }
func (m *MsgAdminUpdateBinaryOptionsMarket) String() string { return proto.CompactTextString(m) }
func (*MsgAdminUpdateBinaryOptionsMarket) ProtoMessage()    {}
func (*MsgAdminUpdateBinaryOptionsMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{77}
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket.Merge(m, src)
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgAdminUpdateBinaryOptionsMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarket proto.InternalMessageInfo

func (m *MsgAdminUpdateBinaryOptionsMarket) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetExpirationTimestamp() int64 {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return 0
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetSettlementTimestamp() int64 {
	if m != nil {
		return m.SettlementTimestamp
	}
	return 0
}

func (m *MsgAdminUpdateBinaryOptionsMarket) GetStatus() MarketStatus {
	if m != nil {
		return m.Status
	}
	return MarketStatus_Unspecified
}

// MsgAdminUpdateBinaryOptionsMarketResponse is the response for AdminUpdateBinaryOptionsMarket rpc method
type MsgAdminUpdateBinaryOptionsMarketResponse struct {
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Reset() {
	*m = MsgAdminUpdateBinaryOptionsMarketResponse{}
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgAdminUpdateBinaryOptionsMarketResponse) ProtoMessage() {}
func (*MsgAdminUpdateBinaryOptionsMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{78}
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse.Merge(m, src)
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAdminUpdateBinaryOptionsMarketResponse proto.InternalMessageInfo

// AtomicMarketOrderFeeMultiplierScheduleProposal defines a SDK message for proposing new atomic take fee multipliers for specified markets
type AtomicMarketOrderFeeMultiplierScheduleProposal struct {
	Title                string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description          string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	MarketFeeMultipliers []*MarketFeeMultiplier `protobuf:"bytes,3,rep,name=market_fee_multipliers,json=marketFeeMultipliers,proto3" json:"market_fee_multipliers,omitempty"`
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Reset() {
	*m = AtomicMarketOrderFeeMultiplierScheduleProposal{}
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) String() string {
	return proto.CompactTextString(m)
}
func (*AtomicMarketOrderFeeMultiplierScheduleProposal) ProtoMessage() {}
func (*AtomicMarketOrderFeeMultiplierScheduleProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd45b74cb6d81462, []int{79}
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal.Merge(m, src)
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_Size() int {
	return m.Size()
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicMarketOrderFeeMultiplierScheduleProposal proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("injective.exchange.v1beta1.ExchangeType", ExchangeType_name, ExchangeType_value)
	proto.RegisterType((*MsgDeposit)(nil), "injective.exchange.v1beta1.MsgDeposit")
	proto.RegisterType((*MsgDepositResponse)(nil), "injective.exchange.v1beta1.MsgDepositResponse")
	proto.RegisterType((*MsgWithdraw)(nil), "injective.exchange.v1beta1.MsgWithdraw")
	proto.RegisterType((*MsgWithdrawResponse)(nil), "injective.exchange.v1beta1.MsgWithdrawResponse")
	proto.RegisterType((*MsgCreateSpotLimitOrder)(nil), "injective.exchange.v1beta1.MsgCreateSpotLimitOrder")
	proto.RegisterType((*MsgCreateSpotLimitOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateSpotLimitOrderResponse")
	proto.RegisterType((*MsgBatchCreateSpotLimitOrders)(nil), "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrders")
	proto.RegisterType((*MsgBatchCreateSpotLimitOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCreateSpotLimitOrdersResponse")
	proto.RegisterType((*MsgInstantSpotMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantSpotMarketLaunch")
	proto.RegisterType((*MsgInstantSpotMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantSpotMarketLaunchResponse")
	proto.RegisterType((*MsgInstantPerpetualMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunch")
	proto.RegisterType((*MsgInstantPerpetualMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantPerpetualMarketLaunchResponse")
	proto.RegisterType((*MsgInstantBinaryOptionsMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunch")
	proto.RegisterType((*MsgInstantBinaryOptionsMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantBinaryOptionsMarketLaunchResponse")
	proto.RegisterType((*MsgInstantExpiryFuturesMarketLaunch)(nil), "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunch")
	proto.RegisterType((*MsgInstantExpiryFuturesMarketLaunchResponse)(nil), "injective.exchange.v1beta1.MsgInstantExpiryFuturesMarketLaunchResponse")
	proto.RegisterType((*MsgCreateSpotMarketOrder)(nil), "injective.exchange.v1beta1.MsgCreateSpotMarketOrder")
	proto.RegisterType((*MsgCreateSpotMarketOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateSpotMarketOrderResponse")
	proto.RegisterType((*SpotMarketOrderResults)(nil), "injective.exchange.v1beta1.SpotMarketOrderResults")
	proto.RegisterType((*MsgCreateDerivativeLimitOrder)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrder")
	proto.RegisterType((*MsgCreateDerivativeLimitOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeLimitOrderResponse")
	proto.RegisterType((*MsgCreateBinaryOptionsLimitOrder)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrder")
	proto.RegisterType((*MsgCreateBinaryOptionsLimitOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsLimitOrderResponse")
	proto.RegisterType((*MsgBatchCreateDerivativeLimitOrders)(nil), "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrders")
	proto.RegisterType((*MsgBatchCreateDerivativeLimitOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCreateDerivativeLimitOrdersResponse")
	proto.RegisterType((*MsgCancelSpotOrder)(nil), "injective.exchange.v1beta1.MsgCancelSpotOrder")
	proto.RegisterType((*MsgCancelSpotOrderResponse)(nil), "injective.exchange.v1beta1.MsgCancelSpotOrderResponse")
	proto.RegisterType((*MsgBatchCancelSpotOrders)(nil), "injective.exchange.v1beta1.MsgBatchCancelSpotOrders")
	proto.RegisterType((*MsgBatchCancelSpotOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCancelSpotOrdersResponse")
	proto.RegisterType((*MsgBatchCancelBinaryOptionsOrders)(nil), "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrders")
	proto.RegisterType((*MsgBatchCancelBinaryOptionsOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCancelBinaryOptionsOrdersResponse")
	proto.RegisterType((*MsgBatchUpdateOrders)(nil), "injective.exchange.v1beta1.MsgBatchUpdateOrders")
	proto.RegisterType((*MsgBatchUpdateOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchUpdateOrdersResponse")
	proto.RegisterType((*MsgCreateDerivativeMarketOrder)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrder")
	proto.RegisterType((*MsgCreateDerivativeMarketOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateDerivativeMarketOrderResponse")
	proto.RegisterType((*DerivativeMarketOrderResults)(nil), "injective.exchange.v1beta1.DerivativeMarketOrderResults")
	proto.RegisterType((*MsgCreateBinaryOptionsMarketOrder)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrder")
	proto.RegisterType((*MsgCreateBinaryOptionsMarketOrderResponse)(nil), "injective.exchange.v1beta1.MsgCreateBinaryOptionsMarketOrderResponse")
	proto.RegisterType((*MsgCancelDerivativeOrder)(nil), "injective.exchange.v1beta1.MsgCancelDerivativeOrder")
	proto.RegisterType((*MsgCancelDerivativeOrderResponse)(nil), "injective.exchange.v1beta1.MsgCancelDerivativeOrderResponse")
	proto.RegisterType((*MsgCancelBinaryOptionsOrder)(nil), "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrder")
	proto.RegisterType((*MsgCancelBinaryOptionsOrderResponse)(nil), "injective.exchange.v1beta1.MsgCancelBinaryOptionsOrderResponse")
	proto.RegisterType((*OrderData)(nil), "injective.exchange.v1beta1.OrderData")
	proto.RegisterType((*MsgBatchCancelDerivativeOrders)(nil), "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrders")
	proto.RegisterType((*MsgBatchCancelDerivativeOrdersResponse)(nil), "injective.exchange.v1beta1.MsgBatchCancelDerivativeOrdersResponse")
	proto.RegisterType((*MsgSubaccountTransfer)(nil), "injective.exchange.v1beta1.MsgSubaccountTransfer")
	proto.RegisterType((*MsgSubaccountTransferResponse)(nil), "injective.exchange.v1beta1.MsgSubaccountTransferResponse")
	proto.RegisterType((*MsgExternalTransfer)(nil), "injective.exchange.v1beta1.MsgExternalTransfer")
	proto.RegisterType((*MsgExternalTransferResponse)(nil), "injective.exchange.v1beta1.MsgExternalTransferResponse")
	proto.RegisterType((*MsgLiquidatePosition)(nil), "injective.exchange.v1beta1.MsgLiquidatePosition")
	proto.RegisterType((*MsgLiquidatePositionResponse)(nil), "injective.exchange.v1beta1.MsgLiquidatePositionResponse")
	proto.RegisterType((*MsgIncreasePositionMargin)(nil), "injective.exchange.v1beta1.MsgIncreasePositionMargin")
	proto.RegisterType((*MsgIncreasePositionMarginResponse)(nil), "injective.exchange.v1beta1.MsgIncreasePositionMarginResponse")
	proto.RegisterType((*MsgExec)(nil), "injective.exchange.v1beta1.MsgExec")
	proto.RegisterType((*MsgExecResponse)(nil), "injective.exchange.v1beta1.MsgExecResponse")
	proto.RegisterType((*SpotMarketParamUpdateProposal)(nil), "injective.exchange.v1beta1.SpotMarketParamUpdateProposal")
	proto.RegisterType((*ExchangeEnableProposal)(nil), "injective.exchange.v1beta1.ExchangeEnableProposal")
	proto.RegisterType((*BatchExchangeModificationProposal)(nil), "injective.exchange.v1beta1.BatchExchangeModificationProposal")
	proto.RegisterType((*SpotMarketLaunchProposal)(nil), "injective.exchange.v1beta1.SpotMarketLaunchProposal")
	proto.RegisterType((*PerpetualMarketLaunchProposal)(nil), "injective.exchange.v1beta1.PerpetualMarketLaunchProposal")
	proto.RegisterType((*BinaryOptionsMarketLaunchProposal)(nil), "injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal")
	proto.RegisterType((*ExpiryFuturesMarketLaunchProposal)(nil), "injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal")
	proto.RegisterType((*DerivativeMarketParamUpdateProposal)(nil), "injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal")
	proto.RegisterType((*MarketForcedSettlementProposal)(nil), "injective.exchange.v1beta1.MarketForcedSettlementProposal")
	proto.RegisterType((*UpdateDenomDecimalsProposal)(nil), "injective.exchange.v1beta1.UpdateDenomDecimalsProposal")
	proto.RegisterType((*DenomDecimals)(nil), "injective.exchange.v1beta1.DenomDecimals")
	proto.RegisterType((*BinaryOptionsMarketParamUpdateProposal)(nil), "injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal")
	proto.RegisterType((*ProviderOracleParams)(nil), "injective.exchange.v1beta1.ProviderOracleParams")
	proto.RegisterType((*OracleParams)(nil), "injective.exchange.v1beta1.OracleParams")
	proto.RegisterType((*TradingRewardCampaignLaunchProposal)(nil), "injective.exchange.v1beta1.TradingRewardCampaignLaunchProposal")
	proto.RegisterType((*TradingRewardCampaignUpdateProposal)(nil), "injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal")
	proto.RegisterType((*RewardPointUpdate)(nil), "injective.exchange.v1beta1.RewardPointUpdate")
	proto.RegisterType((*TradingRewardPendingPointsUpdateProposal)(nil), "injective.exchange.v1beta1.TradingRewardPendingPointsUpdateProposal")
	proto.RegisterType((*FeeDiscountProposal)(nil), "injective.exchange.v1beta1.FeeDiscountProposal")
	proto.RegisterType((*BatchCommunityPoolSpendProposal)(nil), "injective.exchange.v1beta1.BatchCommunityPoolSpendProposal")
	proto.RegisterType((*MsgRewardsOptOut)(nil), "injective.exchange.v1beta1.MsgRewardsOptOut")
	proto.RegisterType((*MsgRewardsOptOutResponse)(nil), "injective.exchange.v1beta1.MsgRewardsOptOutResponse")
	proto.RegisterType((*MsgAdminUpdateBinaryOptionsMarket)(nil), "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarket")
	proto.RegisterType((*MsgAdminUpdateBinaryOptionsMarketResponse)(nil), "injective.exchange.v1beta1.MsgAdminUpdateBinaryOptionsMarketResponse")
	proto.RegisterType((*AtomicMarketOrderFeeMultiplierScheduleProposal)(nil), "injective.exchange.v1beta1.AtomicMarketOrderFeeMultiplierScheduleProposal")
}

func init() {
	proto.RegisterFile("injective/exchange/v1beta1/tx.proto", fileDescriptor_bd45b74cb6d81462)
}

var fileDescriptor_bd45b74cb6d81462 = []byte{
	// 4182 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5d, 0x5d, 0x6c, 0x1d, 0xc7,
	0x75, 0xd6, 0xf2, 0x5e, 0xde, 0x9f, 0x73, 0xf9, 0x23, 0xad, 0x28, 0xea, 0xfa, 0x4a, 0xfc, 0x11,
	0x69, 0x49, 0x94, 0x5d, 0x93, 0x36, 0xa3, 0x58, 0xb1, 0x53, 0x55, 0xa1, 0xf8, 0x63, 0x33, 0x11,
	0x2d, 0x66, 0x49, 0xbb, 0xae, 0x81, 0xe6, 0x76, 0xb9, 0x77, 0x48, 0xae, 0x75, 0xef, 0xee, 0x6a,
	0x67, 0xaf, 0x25, 0x06, 0x41, 0x0d, 0xa4, 0x6d, 0x9a, 0xda, 0x6d, 0x5a, 0xa3, 0x09, 0x0a, 0x14,
	0x35, 0x6a, 0xa0, 0x41, 0x5b, 0xb4, 0x4d, 0x81, 0xbc, 0xf5, 0xe7, 0xa9, 0x0f, 0x05, 0x52, 0xa0,
	0x40, 0xf3, 0x50, 0x14, 0x4d, 0x0a, 0xa4, 0x85, 0xfd, 0xd2, 0xf7, 0x02, 0x7d, 0xf0, 0x43, 0x51,
	0xec, 0xcc, 0xec, 0xdc, 0xd9, 0xbd, 0xfb, 0x4f, 0x5e, 0xd9, 0x10, 0xfc, 0x24, 0xde, 0x99, 0x39,
	0x67, 0xbe, 0x39, 0x73, 0xce, 0x99, 0x99, 0x33, 0x67, 0x47, 0x30, 0xaf, 0x1b, 0x6f, 0x22, 0xcd,
	0xd1, 0xdf, 0x42, 0x4b, 0xe8, 0xa1, 0x76, 0xa8, 0x1a, 0x07, 0x68, 0xe9, 0xad, 0xe7, 0xf6, 0x90,
	0xa3, 0x3e, 0xb7, 0xe4, 0x3c, 0x5c, 0xb4, 0x6c, 0xd3, 0x31, 0xe5, 0x06, 0x6f, 0xb4, 0xe8, 0x35,
	0x5a, 0x64, 0x8d, 0x1a, 0x13, 0x07, 0xe6, 0x81, 0x49, 0x9a, 0x2d, 0xb9, 0x7f, 0x51, 0x8a, 0xc6,
	0xe5, 0x1e, 0x5b, 0xd3, 0x56, 0xb5, 0x76, 0x8f, 0x29, 0xfd, 0xc9, 0x9a, 0x5d, 0x8b, 0xe9, 0x9d,
	0xf7, 0x44, 0x9b, 0x4e, 0x6b, 0x26, 0xee, 0x98, 0x78, 0x69, 0x4f, 0xc5, 0xbd, 0x36, 0x9a, 0xa9,
	0x1b, 0xac, 0x7e, 0x91, 0xd5, 0xb7, 0x74, 0xec, 0xd8, 0xfa, 0x5e, 0xd7, 0xd1, 0x4d, 0x83, 0xb7,
	0x13, 0x0b, 0x69, 0xfb, 0xb9, 0xdf, 0x96, 0x00, 0xb6, 0xf0, 0xc1, 0x1a, 0xb2, 0x4c, 0xac, 0x3b,
	0xf2, 0x24, 0x94, 0x30, 0x32, 0x5a, 0xc8, 0xae, 0x4b, 0xb3, 0xd2, 0x42, 0x55, 0x61, 0xbf, 0xe4,
	0x79, 0x18, 0xc5, 0xdd, 0x3d, 0x55, 0xd3, 0xcc, 0xae, 0xe1, 0x34, 0xf5, 0x56, 0x7d, 0x88, 0x54,
	0x8f, 0xf4, 0x0a, 0x37, 0x5b, 0xf2, 0x0d, 0x28, 0xa9, 0x1d, 0xf7, 0xef, 0x7a, 0x61, 0x56, 0x5a,
	0xa8, 0x2d, 0x3f, 0xc1, 0xc0, 0x2c, 0xba, 0x60, 0x3d, 0x49, 0x2d, 0xae, 0x9a, 0xba, 0x71, 0xbb,
	0xf8, 0xa3, 0x9f, 0xcd, 0x9c, 0x52, 0x58, 0xf3, 0x17, 0x2b, 0xdf, 0xfe, 0x60, 0xe6, 0xd4, 0x7f,
	0x7f, 0x30, 0x73, 0x6a, 0x6e, 0x02, 0xe4, 0x1e, 0x1a, 0x05, 0x61, 0xcb, 0x34, 0x30, 0x9a, 0xfb,
	0x1d, 0x09, 0x6a, 0x5b, 0xf8, 0xe0, 0x17, 0x75, 0xe7, 0xb0, 0x65, 0xab, 0x0f, 0x3e, 0x71, 0x94,
	0xe7, 0xe0, 0xac, 0x00, 0x87, 0xc3, 0xfc, 0x55, 0x38, 0xbf, 0x85, 0x0f, 0x56, 0x6d, 0xa4, 0x3a,
	0x68, 0xc7, 0x32, 0x9d, 0x3b, 0x7a, 0x47, 0x77, 0xee, 0xda, 0x2e, 0xb2, 0x28, 0xc4, 0x2b, 0x30,
	0x6c, 0xba, 0x0d, 0x08, 0xd2, 0xda, 0xf2, 0xe5, 0xc5, 0x68, 0x15, 0x5b, 0x74, 0x59, 0x12, 0x6e,
	0x0c, 0x17, 0xa5, 0x14, 0x60, 0x7d, 0x19, 0x66, 0x22, 0xfa, 0xf7, 0x20, 0xca, 0x53, 0x00, 0x84,
	0xaa, 0x79, 0xa8, 0xe2, 0x43, 0x86, 0xa5, 0x4a, 0x4a, 0x5e, 0x56, 0xf1, 0xa1, 0xc0, 0xeb, 0x5b,
	0x12, 0x4c, 0x6d, 0xe1, 0x83, 0xdb, 0xaa, 0xa3, 0x1d, 0x86, 0x71, 0xc4, 0x91, 0x43, 0x5a, 0x85,
	0x12, 0x61, 0x88, 0xeb, 0x43, 0xb3, 0x85, 0xac, 0x63, 0x62, 0xa4, 0x02, 0x90, 0x5d, 0xb8, 0x1c,
	0x8b, 0x83, 0x0f, 0xed, 0x12, 0x8c, 0xf4, 0x86, 0x86, 0x70, 0x5d, 0x9a, 0x2d, 0x2c, 0x54, 0x95,
	0x1a, 0x1f, 0x1c, 0x12, 0xb9, 0xfe, 0x74, 0x08, 0x1a, 0x5b, 0xf8, 0x60, 0xd3, 0xc0, 0x8e, 0x6a,
	0x38, 0x2e, 0xcb, 0x2d, 0xd5, 0xbe, 0x87, 0x9c, 0x3b, 0x6a, 0xd7, 0xd0, 0x0e, 0x23, 0xc7, 0x36,
	0x09, 0x25, 0x47, 0xd7, 0xee, 0xb1, 0xf9, 0xaa, 0x2a, 0xec, 0x97, 0x2b, 0x56, 0x57, 0x7b, 0x9a,
	0x2d, 0x64, 0x98, 0x1d, 0xa2, 0x57, 0x55, 0xa5, 0xea, 0x96, 0xac, 0xb9, 0x05, 0xf2, 0x0c, 0xd4,
	0xee, 0x77, 0x4d, 0xc7, 0xab, 0x2f, 0x92, 0x7a, 0x20, 0x45, 0xb4, 0xc1, 0x2f, 0xc3, 0xd9, 0x8e,
	0x6e, 0x34, 0x2d, 0x5b, 0xd7, 0x50, 0xd3, 0xe5, 0xd9, 0xc4, 0xfa, 0xd7, 0x51, 0x7d, 0xd8, 0x6d,
	0x78, 0x7b, 0xd1, 0x95, 0xcc, 0x4f, 0x7f, 0x36, 0x73, 0xe5, 0x40, 0x77, 0x0e, 0xbb, 0x7b, 0x8b,
	0x9a, 0xd9, 0x59, 0x62, 0x56, 0x4e, 0xff, 0x79, 0x06, 0xb7, 0xee, 0x2d, 0x39, 0x47, 0x16, 0xc2,
	0x8b, 0x6b, 0x48, 0x53, 0x4e, 0x77, 0x74, 0x63, 0xdb, 0xe5, 0xb4, 0xab, 0x6b, 0xf7, 0x76, 0xf4,
	0xaf, 0x23, 0x59, 0x83, 0x49, 0x97, 0xfd, 0xfd, 0xae, 0x6a, 0x38, 0xba, 0x73, 0x24, 0xf4, 0x50,
	0xca, 0xd5, 0x83, 0x0b, 0xf6, 0xab, 0x8c, 0x99, 0xd7, 0x89, 0x20, 0xdc, 0x27, 0x61, 0x2e, 0x5a,
	0xb6, 0xdc, 0x5a, 0xfe, 0xa7, 0x44, 0xd4, 0x95, 0x35, 0xdb, 0x46, 0xb6, 0x85, 0x9c, 0xae, 0xda,
	0x3e, 0xd6, 0x3c, 0x04, 0x04, 0x5d, 0xe8, 0x13, 0xf4, 0x0c, 0xd4, 0xa8, 0xe7, 0x6d, 0xba, 0xb3,
	0xe3, 0xcd, 0x04, 0x2d, 0xba, 0xad, 0x7a, 0x5a, 0x44, 0x1a, 0x10, 0x2a, 0x3a, 0x05, 0x0a, 0x23,
	0xfa, 0xaa, 0x5b, 0x24, 0x2f, 0xc2, 0x59, 0xd6, 0x04, 0x6b, 0x6a, 0x1b, 0x35, 0xf7, 0x55, 0xcd,
	0x31, 0x6d, 0x22, 0xca, 0x51, 0xe5, 0x0c, 0xad, 0xda, 0x71, 0x6b, 0x36, 0x48, 0x85, 0xbc, 0xce,
	0xfb, 0x74, 0x25, 0x58, 0x2f, 0xcf, 0x4a, 0x0b, 0x63, 0xcb, 0x4f, 0x0a, 0x56, 0xc1, 0xd6, 0x02,
	0xcf, 0x26, 0xee, 0x92, 0x9f, 0xbb, 0x47, 0x16, 0xf2, 0x90, 0xb9, 0x7f, 0xcb, 0xbb, 0x30, 0xd6,
	0x51, 0xef, 0x21, 0xbb, 0xb9, 0x8f, 0x50, 0xd3, 0x56, 0x1d, 0x54, 0xaf, 0xe4, 0x9a, 0xbc, 0x11,
	0xc2, 0x65, 0x03, 0x21, 0x45, 0x75, 0x08, 0x57, 0xc7, 0xcf, 0xb5, 0x9a, 0x8f, 0xab, 0x23, 0x72,
	0xfd, 0x15, 0x98, 0xd0, 0x0d, 0xdd, 0xd1, 0xd5, 0x76, 0xb3, 0xa3, 0xda, 0x07, 0xba, 0xe1, 0xb2,
	0xd6, 0xcd, 0x3a, 0xe4, 0xe2, 0x2d, 0x33, 0x5e, 0x5b, 0x84, 0x95, 0xe2, 0x72, 0x92, 0x0f, 0xa1,
	0xde, 0x51, 0x75, 0xc3, 0x41, 0x86, 0x6a, 0x68, 0xc8, 0xdf, 0x4b, 0x2d, 0x57, 0x2f, 0x93, 0x02,
	0x3f, 0xb1, 0xa7, 0x08, 0xdb, 0x1c, 0x19, 0xb8, 0x6d, 0x8e, 0x0e, 0xc2, 0x36, 0xaf, 0xc1, 0xd5,
	0x04, 0xa3, 0xe3, 0x06, 0xfa, 0xc3, 0x12, 0xcc, 0xf7, 0xda, 0xde, 0xd6, 0x0d, 0xd5, 0x3e, 0xba,
	0x6b, 0xb9, 0x7b, 0x07, 0x7c, 0x2c, 0x23, 0x9d, 0x87, 0x51, 0xcf, 0x7e, 0x8e, 0x3a, 0x7b, 0x66,
	0x9b, 0x99, 0x29, 0xb3, 0xbb, 0x1d, 0x52, 0x26, 0x5f, 0x85, 0x71, 0xd6, 0xc8, 0xb2, 0xcd, 0xb7,
	0x74, 0x97, 0x3b, 0x35, 0xd6, 0x31, 0x5a, 0xbc, 0xcd, 0x4a, 0x83, 0xd6, 0x35, 0x9c, 0xd3, 0xba,
	0xb2, 0x1a, 0x75, 0xbf, 0x35, 0x96, 0x07, 0x62, 0x8d, 0x95, 0x13, 0xb0, 0xc6, 0xe7, 0x60, 0x02,
	0x3d, 0xb4, 0x74, 0x62, 0x1c, 0x46, 0xd3, 0xd1, 0x3b, 0x08, 0x3b, 0x6a, 0xc7, 0x22, 0x96, 0x5e,
	0x50, 0xce, 0xf6, 0xea, 0x76, 0xbd, 0x2a, 0x97, 0x04, 0x23, 0xc7, 0x69, 0xa3, 0x0e, 0x32, 0x1c,
	0x81, 0x04, 0x28, 0x49, 0xaf, 0xae, 0x47, 0x32, 0x01, 0xc3, 0x6a, 0xab, 0xa3, 0x1b, 0xd4, 0xfc,
	0x14, 0xfa, 0x23, 0xe8, 0x91, 0x47, 0xd2, 0x2e, 0x7d, 0xa3, 0x03, 0x37, 0xaf, 0xb1, 0x41, 0x98,
	0xd7, 0x33, 0xf0, 0x74, 0x0a, 0x93, 0xe1, 0x26, 0xf6, 0xbb, 0x65, 0xd1, 0xc4, 0xd6, 0xdd, 0x89,
	0x38, 0xda, 0xe8, 0x3a, 0x5d, 0x1b, 0xe1, 0x4f, 0xff, 0x3a, 0x18, 0xb0, 0xbc, 0xd2, 0xc9, 0x5a,
	0x5e, 0x39, 0xca, 0xf2, 0x26, 0xa1, 0x44, 0x34, 0xf6, 0x88, 0xd8, 0x46, 0x41, 0x61, 0xbf, 0x42,
	0x2c, 0xb2, 0x3a, 0x10, 0x8b, 0x84, 0x01, 0xae, 0x8f, 0xb5, 0x47, 0xb2, 0x3e, 0x8e, 0x3c, 0x8a,
	0xf5, 0xf1, 0x71, 0x30, 0xe0, 0x48, 0x83, 0xe4, 0x06, 0xfc, 0x36, 0xd4, 0x7d, 0x47, 0x2e, 0xda,
	0xe8, 0x11, 0x9e, 0xf9, 0xfe, 0x58, 0x82, 0xd9, 0x28, 0x04, 0x29, 0x4f, 0x7d, 0xb2, 0x02, 0x65,
	0x1b, 0xe1, 0x6e, 0xdb, 0xc1, 0x0c, 0xd2, 0x72, 0x12, 0x24, 0x7f, 0x27, 0x2e, 0x25, 0xc1, 0x27,
	0x29, 0x1e, 0x23, 0x01, 0xe1, 0xff, 0x4a, 0x30, 0x19, 0x4e, 0x23, 0x7f, 0x19, 0x2a, 0xde, 0xbc,
	0x52, 0x54, 0x99, 0x67, 0x93, 0xd3, 0xcb, 0x6b, 0x30, 0x4c, 0x54, 0x90, 0x7a, 0xc2, 0xcc, 0x8c,
	0x28, 0xb1, 0xfc, 0x25, 0x28, 0xec, 0x23, 0x44, 0x1d, 0x66, 0x66, 0x1e, 0x2e, 0x69, 0xff, 0x11,
	0x9a, 0x4e, 0xcd, 0x1a, 0xb2, 0xf5, 0xb7, 0x54, 0x57, 0xa2, 0x29, 0xa2, 0x02, 0x2f, 0xf9, 0x35,
	0xe4, 0xe9, 0xb8, 0xe9, 0xe8, 0x31, 0x0e, 0xd1, 0x93, 0xa2, 0x0b, 0x66, 0x6e, 0x9b, 0x1c, 0xa1,
	0xa3, 0x71, 0x64, 0x8f, 0x0e, 0xfc, 0x96, 0xa8, 0x75, 0xbe, 0x65, 0xee, 0xd1, 0x8f, 0x6e, 0x07,
	0x16, 0x92, 0xa0, 0x64, 0x1f, 0xe0, 0x77, 0x24, 0xb2, 0x30, 0x0b, 0x61, 0x87, 0x30, 0xc1, 0x45,
	0x07, 0x41, 0x36, 0x03, 0x41, 0x90, 0x1c, 0x83, 0xf4, 0x42, 0x21, 0x74, 0x94, 0x6f, 0x10, 0xbf,
	0x94, 0x84, 0x27, 0x5f, 0x30, 0xe4, 0xf7, 0x25, 0x12, 0x75, 0x5b, 0x75, 0x3d, 0x7b, 0x9b, 0x7b,
	0x9c, 0xc8, 0xb1, 0x5d, 0x80, 0x6a, 0x87, 0xd8, 0x72, 0x2f, 0xc2, 0x56, 0xa1, 0x05, 0x9b, 0xad,
	0xfe, 0x10, 0x5c, 0x21, 0x24, 0x04, 0xe7, 0x9f, 0x86, 0x62, 0x70, 0x1a, 0xe8, 0x88, 0x2f, 0x92,
	0x08, 0x4d, 0x00, 0x14, 0x77, 0xbc, 0x47, 0xc4, 0xf1, 0x52, 0x79, 0xf8, 0x9b, 0x44, 0x4f, 0xca,
	0x2d, 0x28, 0xb6, 0x54, 0x47, 0x4d, 0x13, 0x97, 0x22, 0x9c, 0xd6, 0x54, 0x47, 0x65, 0x93, 0x41,
	0x08, 0x19, 0xb0, 0x0d, 0xa2, 0xfb, 0xa1, 0x5d, 0x73, 0xf9, 0xd7, 0xa1, 0x8c, 0xbb, 0x9a, 0x86,
	0x30, 0x15, 0x7d, 0x45, 0xf1, 0x7e, 0x0a, 0x62, 0xff, 0xa6, 0x04, 0x97, 0xfc, 0x8c, 0x7c, 0xea,
	0xfb, 0x68, 0x06, 0x73, 0x17, 0xae, 0x25, 0x62, 0xc8, 0x34, 0xaa, 0x7f, 0x2c, 0xc3, 0x84, 0xc7,
	0xf1, 0x55, 0xab, 0xa5, 0x3a, 0x28, 0x61, 0x20, 0xa9, 0x82, 0xb6, 0xb7, 0x60, 0x0a, 0x5b, 0xa6,
	0xd3, 0xe4, 0x8a, 0x87, 0x9b, 0x8e, 0xd9, 0xd4, 0x08, 0xe2, 0xa6, 0xda, 0x76, 0xcf, 0x90, 0xae,
	0x82, 0xd7, 0x31, 0x5f, 0x68, 0x36, 0x5b, 0x78, 0xd7, 0xa4, 0x43, 0x5a, 0x69, 0xb7, 0xe5, 0xaf,
	0xc0, 0x7c, 0x8b, 0x5b, 0x4c, 0x34, 0x9b, 0x22, 0x61, 0x33, 0xdd, 0x6b, 0x1a, 0xca, 0xec, 0x6b,
	0x70, 0x8e, 0xa0, 0xa1, 0x16, 0xda, 0x63, 0x51, 0x1f, 0xce, 0x3a, 0x19, 0x92, 0x22, 0x63, 0xae,
	0x3d, 0x5e, 0x17, 0xf2, 0x9b, 0x70, 0x41, 0x00, 0xdb, 0xd7, 0x4b, 0x29, 0x7b, 0x2f, 0xf5, 0x96,
	0xdf, 0xc7, 0xf4, 0xfa, 0x0a, 0x19, 0x0b, 0xf1, 0x2f, 0xf5, 0x72, 0xd6, 0xe8, 0x6d, 0x70, 0x2c,
	0x84, 0x8d, 0x6c, 0x45, 0x8d, 0x85, 0xf6, 0x52, 0xc9, 0xe7, 0x1e, 0xc3, 0x47, 0x44, 0x7b, 0xbc,
	0x0f, 0x33, 0x7b, 0x44, 0x89, 0x9b, 0x26, 0xd5, 0xe2, 0x7e, 0x09, 0x56, 0xb3, 0x4b, 0xf0, 0xc2,
	0x5e, 0xbf, 0x61, 0x70, 0x21, 0x2a, 0x70, 0x35, 0xd0, 0x65, 0xa4, 0x86, 0x01, 0xd1, 0xb0, 0x4b,
	0x7b, 0xfd, 0x67, 0xc3, 0x80, 0x92, 0x3d, 0x88, 0x1b, 0x06, 0x15, 0x5e, 0x2d, 0xaf, 0xf0, 0x22,
	0x06, 0x43, 0xb8, 0x32, 0xc7, 0xf0, 0xf1, 0x10, 0x5c, 0x0c, 0xb3, 0x63, 0xee, 0x0c, 0x16, 0xe1,
	0x2c, 0x51, 0x1c, 0x36, 0x36, 0xbf, 0x63, 0x38, 0xe3, 0x56, 0x31, 0xef, 0x48, 0x2b, 0xe4, 0x17,
	0xe1, 0x09, 0x41, 0x11, 0x02, 0x54, 0x43, 0x84, 0xea, 0x7c, 0xaf, 0x81, 0x9f, 0xf6, 0x29, 0x38,
	0xd3, 0x53, 0x52, 0x6f, 0x4d, 0xa3, 0x26, 0x3f, 0xce, 0x75, 0x8e, 0xae, 0x6b, 0xf2, 0xf3, 0x70,
	0x3e, 0xa8, 0x70, 0x1e, 0x05, 0xb5, 0xee, 0x73, 0x01, 0xcd, 0x61, 0x74, 0x2b, 0x30, 0x15, 0x90,
	0x77, 0x00, 0xe3, 0x30, 0xc1, 0xd8, 0xf0, 0x89, 0xce, 0x0f, 0xf3, 0x26, 0x5c, 0x08, 0x9b, 0x32,
	0xaf, 0xfb, 0x12, 0xf5, 0x51, 0xfd, 0xb2, 0xef, 0x5b, 0x91, 0x7f, 0x53, 0x82, 0xe9, 0x90, 0x2d,
	0x5b, 0x9a, 0xd3, 0xc5, 0x09, 0xef, 0xae, 0xfe, 0x52, 0x82, 0x2b, 0xf1, 0x48, 0xd2, 0x9e, 0x32,
	0x5e, 0x0f, 0x9e, 0x32, 0xbe, 0x90, 0x0e, 0x5a, 0x96, 0xb3, 0xc6, 0x1f, 0x15, 0xe0, 0x62, 0x1c,
	0xe5, 0xe3, 0x78, 0xe2, 0x90, 0x5f, 0x83, 0x31, 0x72, 0x5d, 0xaa, 0x9b, 0x46, 0xb3, 0x85, 0xda,
	0x8e, 0x4a, 0x76, 0x54, 0xb5, 0xe5, 0x6b, 0x71, 0xf2, 0xdd, 0x66, 0x14, 0x6b, 0x2e, 0x01, 0x9b,
	0xf8, 0x51, 0x4b, 0x2c, 0x94, 0x37, 0xa0, 0x64, 0xa9, 0x47, 0x66, 0xd7, 0xc9, 0x79, 0x0f, 0xc5,
	0xa8, 0x85, 0xe9, 0x79, 0x87, 0xee, 0x78, 0x42, 0xf6, 0xea, 0x9f, 0x80, 0x66, 0xff, 0xb5, 0x44,
	0xb6, 0x3e, 0xf1, 0x60, 0x3e, 0x4d, 0xca, 0xfd, 0x37, 0x12, 0x0d, 0x36, 0x10, 0x97, 0x13, 0x18,
	0xe0, 0x27, 0xb6, 0x59, 0xef, 0x55, 0x77, 0x54, 0x7c, 0x8f, 0x68, 0xca, 0x30, 0xab, 0xde, 0x52,
	0xf1, 0x3d, 0x26, 0xeb, 0x39, 0x7a, 0x5c, 0x0c, 0x43, 0xce, 0x77, 0xf4, 0x7f, 0x2f, 0xc1, 0x05,
	0xde, 0xa8, 0x7f, 0x17, 0xfa, 0x29, 0x1f, 0xe1, 0x65, 0x72, 0x5e, 0x8c, 0x02, 0xcf, 0x07, 0xf9,
	0xae, 0x04, 0x55, 0xbe, 0xb3, 0xf0, 0x43, 0x97, 0x92, 0xa0, 0x0f, 0x25, 0x42, 0x2f, 0xc4, 0x43,
	0x2f, 0x06, 0xa0, 0xcf, 0xbd, 0x4d, 0x56, 0x19, 0x61, 0xf3, 0x1f, 0x98, 0x9b, 0x81, 0x9f, 0x3e,
	0xee, 0x90, 0xc5, 0x25, 0x06, 0x40, 0xa6, 0xa3, 0xc7, 0xbf, 0x49, 0x70, 0x6e, 0x0b, 0x1f, 0xec,
	0x70, 0x01, 0xed, 0xda, 0xaa, 0x81, 0xf7, 0x63, 0x74, 0xe7, 0x59, 0x98, 0xc0, 0x66, 0xd7, 0xd6,
	0x50, 0x33, 0x4c, 0xd4, 0x32, 0xad, 0xdb, 0x11, 0x05, 0x4e, 0x76, 0x31, 0xd8, 0xd1, 0x0d, 0x7a,
	0x99, 0x12, 0xa6, 0x5c, 0xe7, 0x85, 0x06, 0x3b, 0xe1, 0x99, 0x27, 0xc5, 0x4c, 0x99, 0x27, 0x73,
	0x33, 0x24, 0x90, 0xd4, 0x3f, 0x2e, 0xae, 0x56, 0xff, 0x2a, 0x91, 0x8c, 0x94, 0xf5, 0x87, 0x0e,
	0xb2, 0x0d, 0xb5, 0xfd, 0xb8, 0x8c, 0x7b, 0x8a, 0x78, 0x84, 0xe0, 0xa8, 0xf8, 0xa8, 0xff, 0x56,
	0x22, 0x47, 0xcd, 0x3b, 0xfa, 0xfd, 0xae, 0xee, 0x6e, 0x50, 0xbd, 0x35, 0xed, 0x78, 0x47, 0x4d,
	0x9f, 0x51, 0x16, 0x02, 0x46, 0xc9, 0xd7, 0xa0, 0x62, 0xbe, 0x35, 0x48, 0x62, 0x6b, 0xd0, 0xdc,
	0x34, 0xd9, 0x5d, 0xf7, 0x41, 0xe7, 0x63, 0xfb, 0xd6, 0x10, 0x3c, 0x41, 0x02, 0xd1, 0xee, 0x56,
	0x1f, 0xf3, 0x7a, 0x1a, 0x78, 0xff, 0x94, 0xcc, 0xab, 0x4f, 0x52, 0xc5, 0x80, 0xa4, 0x36, 0xf8,
	0xa4, 0xe7, 0xdc, 0x3d, 0x30, 0x1d, 0x98, 0x27, 0x5b, 0x86, 0x70, 0x39, 0x70, 0x69, 0xfd, 0xdf,
	0x10, 0x94, 0x89, 0xa6, 0x20, 0x2d, 0x52, 0x36, 0x6f, 0x02, 0xec, 0xa9, 0xc6, 0xbd, 0xe6, 0x7e,
	0xd7, 0x68, 0x79, 0x61, 0xb9, 0x18, 0x4d, 0x7c, 0xd6, 0xc5, 0xfb, 0x17, 0xff, 0x39, 0xb3, 0x90,
	0x02, 0xaf, 0x4b, 0x80, 0x95, 0xaa, 0xcb, 0x7e, 0xc3, 0xe5, 0x2e, 0x5f, 0x87, 0xc9, 0x16, 0xcd,
	0x61, 0xc3, 0xa1, 0x22, 0x9d, 0xf0, 0x6a, 0x7d, 0xf2, 0xb4, 0x60, 0x94, 0x95, 0x33, 0x90, 0xc5,
	0x93, 0x07, 0x39, 0xc2, 0x7a, 0xa0, 0x38, 0xaf, 0xc1, 0x69, 0xcd, 0x34, 0x1c, 0x5b, 0xd5, 0x9c,
	0xa6, 0xda, 0x6a, 0xd9, 0xf4, 0x98, 0xe3, 0x22, 0x1c, 0xf7, 0xca, 0x57, 0x68, 0xb1, 0x2c, 0x33,
	0x8f, 0x4f, 0x32, 0x86, 0x98, 0x13, 0xef, 0xb9, 0xde, 0x33, 0x30, 0xce, 0xe4, 0xcf, 0xe7, 0xe4,
	0x7b, 0xc3, 0x30, 0xd5, 0x8b, 0xfb, 0x6f, 0xab, 0xb6, 0xda, 0xa1, 0xe7, 0xc8, 0x6d, 0xdb, 0xb4,
	0x4c, 0xac, 0xb6, 0xe5, 0x09, 0x18, 0x76, 0x74, 0xa7, 0x8d, 0xd8, 0x44, 0xd1, 0x1f, 0xf2, 0x2c,
	0xd4, 0x5a, 0x08, 0x6b, 0xb6, 0x4e, 0xd6, 0x4f, 0xa6, 0xba, 0x62, 0x51, 0xbc, 0x85, 0xf6, 0x5f,
	0x03, 0x16, 0xb9, 0xfe, 0x49, 0x27, 0x78, 0x0d, 0x38, 0x9c, 0x8f, 0xab, 0xef, 0x1a, 0x50, 0x83,
	0x49, 0x1b, 0xb5, 0xd5, 0x23, 0xc6, 0x17, 0x1f, 0xaa, 0x36, 0xe3, 0x5e, 0xca, 0xc5, 0xfd, 0x2c,
	0xe3, 0xb6, 0x81, 0xd0, 0x8e, 0xcb, 0x8b, 0x74, 0x12, 0x71, 0x3f, 0x57, 0xce, 0xd5, 0x43, 0x96,
	0xfb, 0xb9, 0x4a, 0xbe, 0x31, 0x84, 0xdc, 0xcf, 0xc9, 0x5f, 0x82, 0x12, 0x76, 0x54, 0xa7, 0x8b,
	0xc9, 0x9d, 0xee, 0xd8, 0xf2, 0x42, 0x9c, 0xdf, 0xa5, 0x0a, 0xb7, 0x43, 0xda, 0x2b, 0x8c, 0x4e,
	0x50, 0xd5, 0x3f, 0x97, 0x60, 0x72, 0x9d, 0xd1, 0xac, 0x1b, 0xea, 0x5e, 0xfb, 0xf8, 0x0a, 0x79,
	0x07, 0x46, 0x3c, 0x14, 0xbb, 0x47, 0x16, 0x3d, 0xcc, 0x25, 0x80, 0x5c, 0x17, 0xda, 0x2b, 0x3e,
	0x6a, 0x31, 0x4b, 0x11, 0xe0, 0x12, 0xd9, 0x1c, 0x79, 0xad, 0xb7, 0xcc, 0x96, 0xbe, 0xaf, 0x6b,
	0xc4, 0x15, 0x1f, 0x1b, 0xf5, 0x6f, 0x48, 0x30, 0x27, 0x06, 0x55, 0x2d, 0xd7, 0x44, 0x9b, 0x5d,
	0x62, 0xa3, 0x4d, 0x8b, 0x71, 0xa7, 0x61, 0x96, 0xda, 0xf2, 0x0b, 0xe9, 0xae, 0x04, 0x43, 0xcc,
	0x5c, 0x99, 0xc6, 0x71, 0xd5, 0x58, 0xfe, 0x03, 0x09, 0x16, 0xfa, 0x63, 0xb3, 0x11, 0x68, 0xa8,
	0x4b, 0xbc, 0x95, 0xe5, 0x74, 0x15, 0x86, 0xe9, 0xc9, 0x56, 0x72, 0x23, 0x2c, 0x77, 0xe1, 0xa2,
	0x28, 0xa0, 0x36, 0xb9, 0xfb, 0x15, 0xc0, 0xd0, 0x70, 0xef, 0xf5, 0x74, 0xa2, 0xa1, 0x37, 0xc7,
	0x1c, 0xc1, 0x13, 0x38, 0xa2, 0x06, 0xcb, 0xbf, 0x2e, 0xc1, 0x25, 0xcb, 0x4b, 0xcd, 0x8a, 0xec,
	0xbc, 0x94, 0x3c, 0x2f, 0xa1, 0xf9, 0x5d, 0xbd, 0x79, 0xb1, 0xe2, 0xaa, 0xb1, 0xfc, 0x9e, 0x04,
	0x57, 0x68, 0x6e, 0x45, 0x73, 0x9f, 0x5e, 0x81, 0x47, 0x62, 0xa1, 0xb1, 0xe2, 0x9b, 0xf1, 0x0a,
	0x1f, 0x71, 0x97, 0xce, 0xf1, 0xcc, 0xa1, 0xa4, 0x26, 0x58, 0xfe, 0x9e, 0x04, 0x57, 0x1d, 0x5b,
	0x6d, 0xe9, 0xc6, 0x41, 0xd3, 0x46, 0x0f, 0x54, 0xbb, 0xd5, 0xd4, 0xd4, 0x8e, 0xa5, 0xea, 0x07,
	0x46, 0x50, 0x57, 0x88, 0xff, 0x49, 0x50, 0x95, 0x5d, 0xca, 0x4a, 0x21, 0x9c, 0x56, 0x19, 0xa3,
	0x80, 0xaa, 0xcc, 0x3b, 0xc9, 0x8d, 0x88, 0xac, 0xc2, 0x23, 0xc0, 0x7d, 0xb2, 0xaa, 0x26, 0xcb,
	0x2a, 0x32, 0x71, 0xa8, 0x27, 0xab, 0xbd, 0xa4, 0x26, 0x58, 0xfe, 0xae, 0x04, 0x97, 0x03, 0x98,
	0x22, 0x8c, 0x0a, 0x08, 0xa4, 0xdb, 0x19, 0x21, 0x85, 0xd9, 0x95, 0x3f, 0xae, 0x1d, 0x6a, 0x54,
	0xdf, 0x80, 0x69, 0x92, 0x95, 0xd4, 0x6c, 0x21, 0x4d, 0xef, 0xa8, 0x6d, 0xdc, 0x37, 0x71, 0x35,
	0x32, 0x71, 0x37, 0xe2, 0xe0, 0x50, 0xa6, 0x24, 0x97, 0x69, 0x8d, 0xb1, 0xe1, 0x18, 0x2e, 0xb4,
	0xc4, 0x62, 0x7f, 0xf7, 0x82, 0x73, 0xfd, 0x7e, 0x11, 0xea, 0x51, 0xd6, 0x99, 0xdb, 0xa7, 0xf6,
	0x12, 0xb2, 0x0a, 0x31, 0x09, 0xe2, 0xc5, 0x84, 0x04, 0xf1, 0xe1, 0xb4, 0x59, 0x72, 0xa5, 0x81,
	0x27, 0xd9, 0x94, 0x4f, 0x2c, 0xc9, 0x26, 0x36, 0x81, 0x59, 0x1a, 0x48, 0x02, 0x73, 0xee, 0x9d,
	0x99, 0xa0, 0x26, 0xef, 0x95, 0x61, 0x2a, 0xd6, 0x8f, 0x9e, 0xb8, 0xae, 0x24, 0x7e, 0x2d, 0x10,
	0x48, 0xde, 0x1b, 0x4e, 0x4c, 0xde, 0x2b, 0xa5, 0x4e, 0x62, 0x2f, 0xa7, 0x4c, 0x62, 0xaf, 0xe4,
	0x4c, 0xf6, 0x8b, 0x4a, 0x7c, 0xab, 0x3e, 0x92, 0xc4, 0x37, 0x38, 0xd1, 0xc4, 0xb7, 0x7e, 0x7d,
	0xae, 0x0d, 0x24, 0xe1, 0x70, 0xe4, 0x04, 0x12, 0x0e, 0x1f, 0xaf, 0x24, 0xbd, 0x7f, 0x29, 0xc1,
	0xa5, 0xc4, 0x35, 0xf2, 0xc4, 0xed, 0xb2, 0x2f, 0x6f, 0xbd, 0x98, 0x2e, 0x6f, 0x7d, 0x38, 0x4d,
	0xde, 0xfa, 0xa3, 0xca, 0x9e, 0x8d, 0xca, 0x05, 0xaf, 0x64, 0xcf, 0x05, 0xaf, 0xa6, 0xc8, 0x05,
	0x87, 0x98, 0x5c, 0xf0, 0x5a, 0x9f, 0x63, 0xeb, 0xb7, 0xa8, 0x91, 0x81, 0x58, 0xd4, 0xe8, 0xe0,
	0x2c, 0x6a, 0x6c, 0xe0, 0x16, 0x35, 0x3e, 0x08, 0x8b, 0xfa, 0x41, 0x19, 0x2e, 0x25, 0xee, 0xd0,
	0x3f, 0x5b, 0xe9, 0x32, 0x18, 0x66, 0x2f, 0x4d, 0xbd, 0xea, 0x4b, 0x53, 0x7f, 0x9c, 0x3e, 0x8d,
	0xfa, 0xcc, 0x5e, 0x3f, 0x29, 0x7b, 0xfd, 0xb8, 0x02, 0xf3, 0x29, 0xe2, 0x1c, 0x83, 0x09, 0xb1,
	0x46, 0xa9, 0x70, 0xbe, 0x40, 0x6b, 0x56, 0x15, 0xce, 0x17, 0x78, 0x4d, 0xaf, 0xc2, 0xa5, 0x81,
	0x1c, 0x4a, 0xca, 0x03, 0x0d, 0x17, 0x57, 0x06, 0x1e, 0x2e, 0xae, 0x0e, 0x3c, 0x5c, 0x0c, 0x27,
	0x17, 0x2e, 0xfe, 0x1a, 0xc8, 0x2f, 0x9b, 0x5d, 0xbb, 0x7d, 0xb4, 0x69, 0x38, 0xc8, 0x46, 0xd8,
	0x51, 0xfc, 0xbb, 0xf3, 0x4c, 0xea, 0xd9, 0xcf, 0x49, 0xde, 0x83, 0x09, 0x5a, 0xba, 0xd1, 0x35,
	0x48, 0x68, 0x48, 0x75, 0xd0, 0xaa, 0x6a, 0x09, 0xde, 0x2f, 0x4b, 0x0f, 0xa1, 0xbc, 0x84, 0x90,
	0xf7, 0x68, 0xbe, 0x90, 0xb7, 0xbc, 0xc5, 0xf7, 0xab, 0x24, 0xec, 0x83, 0x89, 0xaf, 0xab, 0xc5,
	0x33, 0xa2, 0x8b, 0x19, 0xf1, 0x24, 0xd8, 0xdb, 0xd9, 0xd2, 0x5f, 0x62, 0x58, 0x5a, 0x82, 0x69,
	0xda, 0xe3, 0x86, 0x69, 0x6b, 0xa8, 0xb5, 0xc3, 0x77, 0x80, 0x83, 0xf5, 0x3b, 0xbf, 0x04, 0xa7,
	0x85, 0x8d, 0x28, 0xcd, 0xbd, 0xca, 0xe7, 0x73, 0xc6, 0xb1, 0x00, 0x59, 0xd7, 0x44, 0xcf, 0xfa,
	0x43, 0x09, 0x2e, 0xc4, 0x44, 0x97, 0x72, 0x8f, 0x6c, 0x1b, 0xc6, 0xfc, 0x61, 0x2f, 0x16, 0x58,
	0xbf, 0x16, 0x1f, 0xca, 0x16, 0x20, 0x28, 0xa3, 0xbe, 0xc0, 0x96, 0x80, 0x79, 0x05, 0x46, 0x7d,
	0x2d, 0x5d, 0x90, 0x74, 0x4b, 0xc5, 0x40, 0x92, 0x1f, 0x72, 0x03, 0x2a, 0xbc, 0x73, 0x17, 0x61,
	0x51, 0xe1, 0xbf, 0xe7, 0xfe, 0xb9, 0x0c, 0x57, 0xd2, 0xc5, 0xf8, 0x3e, 0xbb, 0xb6, 0xfb, 0xec,
	0xda, 0x2e, 0xa5, 0x1f, 0x7e, 0x34, 0x1f, 0x1e, 0x87, 0xb9, 0x85, 0xda, 0x89, 0xb8, 0x85, 0xde,
	0x39, 0x76, 0x44, 0x3c, 0xc7, 0x1e, 0xdf, 0x35, 0xbf, 0x1a, 0xee, 0x9a, 0x9f, 0x8d, 0xbd, 0xcc,
	0x61, 0x91, 0x83, 0x54, 0x2e, 0xfa, 0x1f, 0x24, 0x98, 0x08, 0x23, 0x20, 0xd9, 0x11, 0x34, 0x7a,
	0xe1, 0x65, 0x47, 0xd0, 0xb8, 0x45, 0x03, 0x2a, 0x3c, 0x60, 0xc1, 0x92, 0xe8, 0xbc, 0xdf, 0x51,
	0x27, 0xa8, 0x42, 0xca, 0x13, 0x54, 0x31, 0xdf, 0x09, 0x6a, 0xee, 0x9f, 0x24, 0x18, 0xf1, 0x61,
	0x0f, 0x9c, 0x06, 0xa5, 0xc4, 0xd3, 0xe0, 0x50, 0xea, 0xd3, 0xe0, 0xa0, 0xc7, 0xf2, 0x67, 0x43,
	0x30, 0x1f, 0x7a, 0xd9, 0x74, 0x42, 0x27, 0xec, 0x37, 0x60, 0x94, 0xdf, 0x83, 0xe9, 0xc6, 0xbe,
	0xc9, 0xde, 0x36, 0xfa, 0x7c, 0xe6, 0xcb, 0xaf, 0x4d, 0x63, 0xdf, 0x54, 0x46, 0x34, 0xe1, 0x97,
	0xbc, 0x07, 0xe7, 0x38, 0x6f, 0x76, 0xe7, 0x66, 0x99, 0x26, 0xbf, 0x8b, 0x5d, 0x8c, 0xeb, 0xc3,
	0x63, 0x4b, 0x3b, 0xd9, 0x36, 0xcd, 0xb6, 0x72, 0x56, 0xeb, 0x2b, 0x13, 0x35, 0xf7, 0x07, 0x85,
	0x08, 0x49, 0x9d, 0xd0, 0x2a, 0x34, 0x48, 0x49, 0x75, 0x61, 0x26, 0x54, 0x52, 0x4d, 0xb5, 0xd5,
	0x22, 0x69, 0x4b, 0x79, 0x65, 0x76, 0x31, 0x44, 0x66, 0x2b, 0x1e, 0x4f, 0xf9, 0x3e, 0x4c, 0x85,
	0x77, 0x4b, 0x2f, 0xd6, 0xbc, 0x7b, 0xea, 0xac, 0x9d, 0x36, 0x42, 0x3a, 0xa5, 0x93, 0x20, 0xce,
	0xd7, 0xbb, 0x12, 0x9c, 0xf1, 0x1a, 0xe8, 0x86, 0x43, 0x1b, 0xc8, 0x57, 0x61, 0xdc, 0x4b, 0x7a,
	0xf2, 0xf2, 0x8a, 0xe8, 0x3c, 0x8d, 0xb1, 0x62, 0x2f, 0xad, 0x68, 0x0b, 0xc0, 0x40, 0x0f, 0x9a,
	0x96, 0x4b, 0x8b, 0x73, 0x86, 0x0f, 0xaa, 0x06, 0x7a, 0x40, 0x3a, 0xc7, 0x73, 0xbf, 0x36, 0x04,
	0x0b, 0xbe, 0xd9, 0xda, 0x46, 0x64, 0x57, 0x4d, 0xab, 0x4f, 0x48, 0x85, 0xae, 0xc3, 0xa4, 0x45,
	0xd9, 0x12, 0x39, 0x0b, 0xab, 0x54, 0x81, 0xac, 0x52, 0x13, 0x96, 0xd7, 0xa9, 0xd9, 0xee, 0x2d,
	0x53, 0x4d, 0x98, 0xe0, 0x93, 0xa3, 0x1b, 0x0e, 0x9f, 0x1c, 0xaa, 0x11, 0xcf, 0xc4, 0x4d, 0x4e,
	0x9f, 0x7c, 0x15, 0xd9, 0x0e, 0x16, 0x89, 0x73, 0xf2, 0x7d, 0x09, 0xce, 0x6e, 0x20, 0xb4, 0xa6,
	0x63, 0x22, 0xeb, 0x63, 0x0f, 0xf8, 0x2b, 0x50, 0xc1, 0xda, 0x21, 0x6a, 0x75, 0xdb, 0x88, 0x99,
	0xcb, 0x52, 0x1c, 0x5c, 0xa1, 0xeb, 0x1d, 0x46, 0xa6, 0x70, 0x06, 0x02, 0xcc, 0xbf, 0x93, 0x60,
	0x86, 0xe6, 0xfe, 0x9a, 0x9d, 0x4e, 0xd7, 0xd0, 0x9d, 0x23, 0x57, 0x62, 0x3b, 0xae, 0xf4, 0x8e,
	0x0d, 0xf9, 0x55, 0xa8, 0x06, 0x53, 0x58, 0x6e, 0x78, 0x79, 0x74, 0xbe, 0x67, 0xf0, 0x7a, 0xf9,
	0x74, 0x51, 0x18, 0x94, 0x1e, 0x27, 0x01, 0xfc, 0x53, 0x70, 0x7a, 0x0b, 0x33, 0x25, 0xc3, 0x77,
	0x2d, 0xe7, 0x6e, 0x37, 0xf2, 0xf5, 0xbc, 0xb9, 0x06, 0x49, 0xdc, 0xf7, 0xb5, 0xe5, 0x69, 0x72,
	0xff, 0x31, 0x44, 0x12, 0x1c, 0x57, 0xdc, 0x9d, 0x05, 0x9d, 0xc9, 0x90, 0x6d, 0x78, 0xbe, 0xe4,
	0xf7, 0xb0, 0x8d, 0x51, 0xe1, 0x64, 0x36, 0x46, 0x51, 0x3b, 0xbb, 0x62, 0xf6, 0x9d, 0xdd, 0x70,
	0xf4, 0xce, 0xae, 0xb7, 0xd1, 0x2a, 0xe5, 0xdb, 0x68, 0xcd, 0x3d, 0x4d, 0xbe, 0xf1, 0x88, 0x17,
	0x2e, 0x9f, 0x8a, 0x9f, 0x48, 0xb0, 0xb8, 0xe2, 0x98, 0x1d, 0x5d, 0x13, 0x3e, 0xcb, 0xd8, 0x40,
	0x68, 0xab, 0xdb, 0x76, 0x74, 0xab, 0xad, 0x23, 0xdb, 0x53, 0xe7, 0x63, 0xab, 0x27, 0x82, 0x49,
	0x36, 0x6f, 0xee, 0x09, 0xa2, 0xc3, 0x3b, 0xf0, 0x74, 0x75, 0x29, 0x79, 0xa4, 0x3e, 0x60, 0xca,
	0x44, 0xa7, 0xbf, 0x50, 0x50, 0xd7, 0xa7, 0x1e, 0xc2, 0x88, 0x98, 0x72, 0x26, 0x2f, 0xc3, 0xc4,
	0xfa, 0xeb, 0xab, 0x2f, 0xaf, 0xbc, 0xf2, 0xd2, 0x7a, 0xf3, 0xd5, 0x57, 0x76, 0xb6, 0xd7, 0x57,
	0x37, 0x37, 0x36, 0xd7, 0xd7, 0x4e, 0x9f, 0x6a, 0xd4, 0xdf, 0x79, 0x7f, 0x36, 0xb4, 0x4e, 0x96,
	0xa1, 0xb8, 0xb3, 0x7d, 0x77, 0xf7, 0xb4, 0xd4, 0xa8, 0xbc, 0xf3, 0xfe, 0x2c, 0xf9, 0xdb, 0x1d,
	0xea, 0xda, 0xba, 0xb2, 0xf9, 0xda, 0xca, 0xee, 0xe6, 0x6b, 0xeb, 0x3b, 0xa7, 0x87, 0x1a, 0xe3,
	0xef, 0xbc, 0x3f, 0x2b, 0x16, 0x2d, 0xff, 0x64, 0x06, 0x0a, 0x5b, 0xf8, 0x40, 0x56, 0xa1, 0xec,
	0xbd, 0x32, 0x79, 0x25, 0x76, 0x74, 0xfc, 0xfd, 0xc7, 0xc6, 0x62, 0xba, 0x76, 0xfc, 0x23, 0x81,
	0x16, 0x54, 0xf8, 0x1b, 0x91, 0x57, 0x13, 0x68, 0xbd, 0x86, 0x8d, 0xa5, 0x94, 0x0d, 0x79, 0x2f,
	0xef, 0x49, 0x70, 0x3e, 0xea, 0xe1, 0xc0, 0xe7, 0x13, 0x98, 0x45, 0xd0, 0x35, 0x7e, 0x21, 0x1f,
	0x1d, 0xc7, 0xf4, 0x81, 0x04, 0x17, 0x63, 0x5f, 0xd2, 0xfb, 0x62, 0xba, 0x0e, 0x42, 0x89, 0x1b,
	0xab, 0xc7, 0x20, 0xe6, 0x10, 0xff, 0x4a, 0x82, 0xd9, 0xc4, 0x87, 0x8e, 0x6e, 0xa5, 0xeb, 0x29,
	0x92, 0x41, 0xe3, 0xa5, 0x63, 0x32, 0xe0, 0x70, 0xbf, 0x2d, 0xc1, 0x44, 0xe8, 0x53, 0x9e, 0x9f,
	0x4b, 0xe8, 0x21, 0x8c, 0xa8, 0xf1, 0xc5, 0x1c, 0x44, 0x1c, 0xca, 0x1f, 0x4a, 0xd0, 0x88, 0x79,
	0x88, 0xf3, 0x85, 0x04, 0xde, 0xd1, 0xa4, 0x8d, 0x95, 0xdc, 0xa4, 0x1c, 0xdc, 0xbb, 0x12, 0x9c,
	0x0b, 0x7f, 0xff, 0xe6, 0x7a, 0xea, 0x31, 0x0b, 0x54, 0x8d, 0x9f, 0xcf, 0x43, 0xc5, 0xd1, 0x1c,
	0xc1, 0x78, 0xf0, 0x19, 0x8b, 0x24, 0x27, 0x12, 0x68, 0xdf, 0x78, 0x3e, 0x5b, 0x7b, 0x9f, 0x20,
	0xc2, 0xdf, 0xa3, 0xb8, 0x9e, 0x4a, 0xca, 0x01, 0xaa, 0x44, 0x41, 0xc4, 0x3f, 0x40, 0xf1, 0x36,
	0x9c, 0xe9, 0x7f, 0x82, 0xe1, 0xd9, 0x34, 0x2c, 0x45, 0x8a, 0xc6, 0x17, 0xb2, 0x52, 0x70, 0x00,
	0xaf, 0x43, 0x91, 0x7c, 0x8e, 0x31, 0x9f, 0xc0, 0xc1, 0x6d, 0xd4, 0x78, 0x3a, 0x45, 0x23, 0x9f,
	0x39, 0xc4, 0x3c, 0xaa, 0xf3, 0x42, 0x2a, 0x05, 0x0a, 0x23, 0x4d, 0x34, 0x87, 0x14, 0x4f, 0xe8,
	0xb8, 0x5e, 0x2e, 0xf1, 0xd5, 0x98, 0x5b, 0xe9, 0xcd, 0x2e, 0x94, 0x41, 0xa2, 0x97, 0x4b, 0xfd,
	0x4e, 0xcc, 0xfb, 0x12, 0x5c, 0x88, 0xfb, 0xca, 0xfc, 0xc5, 0x8c, 0x12, 0x11, 0x2d, 0xf9, 0x76,
	0x7e, 0x5a, 0xbf, 0x77, 0x09, 0xfd, 0xe0, 0xf5, 0x7a, 0x2a, 0x33, 0x0d, 0x50, 0x25, 0x7b, 0x97,
	0xb8, 0x4f, 0x54, 0x89, 0xb4, 0xe2, 0xbe, 0x96, 0x7c, 0x31, 0xbd, 0xc9, 0x06, 0x69, 0x13, 0xa5,
	0x95, 0xe6, 0x23, 0x49, 0x61, 0x89, 0x8d, 0x7e, 0xae, 0x33, 0xe5, 0x12, 0x1b, 0xc9, 0x20, 0xed,
	0x12, 0x9b, 0xf8, 0xfa, 0xa1, 0xfc, 0x27, 0x12, 0x4c, 0xc5, 0x3f, 0x21, 0x95, 0x6e, 0x31, 0x88,
	0xa0, 0x6e, 0xac, 0x1d, 0x87, 0x9a, 0xa3, 0xfc, 0x53, 0x09, 0xa6, 0x13, 0xbe, 0x58, 0xbf, 0x99,
	0xbd, 0x23, 0xd1, 0x50, 0xd6, 0x8f, 0x45, 0xce, 0x81, 0x7e, 0x57, 0x82, 0x7a, 0xe4, 0xd7, 0xd3,
	0x37, 0x52, 0x29, 0x7e, 0x3f, 0x61, 0xe3, 0x56, 0x4e, 0x42, 0x9f, 0xfc, 0x12, 0xde, 0x38, 0xba,
	0x99, 0x5e, 0xf7, 0x43, 0xc8, 0x13, 0xe5, 0x97, 0xf2, 0x75, 0xa3, 0x6f, 0x4a, 0x20, 0x87, 0x7c,
	0x3b, 0xfc, 0x5c, 0x02, 0xf7, 0x7e, 0x92, 0xc6, 0x0b, 0x99, 0x49, 0x38, 0x88, 0x6f, 0xc0, 0xe9,
	0xbe, 0xaf, 0x78, 0x97, 0x12, 0x57, 0x47, 0x3f, 0x41, 0xe3, 0x46, 0x46, 0x02, 0x71, 0xd7, 0xd0,
	0xff, 0x35, 0x6d, 0xd2, 0xae, 0xa1, 0x8f, 0x22, 0x71, 0xd7, 0x10, 0xf9, 0xd9, 0xab, 0xfc, 0x1d,
	0x09, 0x26, 0x23, 0xbe, 0x79, 0xfd, 0x7c, 0xa2, 0xdb, 0x09, 0x23, 0x6b, 0xdc, 0xcc, 0x45, 0xc6,
	0x01, 0x61, 0x18, 0xf5, 0xc7, 0x78, 0x7e, 0x2e, 0x81, 0x9f, 0xaf, 0x75, 0xe3, 0x7a, 0x96, 0xd6,
	0x3e, 0x93, 0x49, 0x08, 0x08, 0x25, 0x0d, 0x2b, 0x9e, 0x3c, 0xd1, 0x64, 0xd2, 0x45, 0x4c, 0x6e,
	0x1f, 0xfe, 0xe8, 0xc3, 0x69, 0xe9, 0xc7, 0x1f, 0x4e, 0x4b, 0xff, 0xf5, 0xe1, 0xb4, 0xf4, 0x7b,
	0x1f, 0x4d, 0x9f, 0xfa, 0xf1, 0x47, 0xd3, 0xa7, 0xfe, 0xfd, 0xa3, 0xe9, 0x53, 0x6f, 0xbc, 0x22,
	0x44, 0x96, 0x36, 0xbd, 0xae, 0xee, 0xa8, 0x7b, 0x78, 0x89, 0x77, 0xfc, 0x8c, 0x66, 0xda, 0x48,
	0xfc, 0x79, 0xa8, 0xea, 0xc6, 0x52, 0xc7, 0x6c, 0x75, 0xdb, 0x08, 0xf7, 0xfe, 0x23, 0x0c, 0x12,
	0x85, 0xda, 0x2b, 0x91, 0xff, 0xae, 0xe2, 0x73, 0xff, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xfc, 0xe6,
	0xd7, 0xb2, 0xa9, 0x63, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Deposit defines a method for transferring coins from the sender's bank balance into the subaccount's exchange deposits
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error)
	// Withdraw defines a method for withdrawing coins from a subaccount's deposits to the user's bank balance
	Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error)
	// InstantSpotMarketLaunch defines method for creating a spot market by paying listing fee without governance
	InstantSpotMarketLaunch(ctx context.Context, in *MsgInstantSpotMarketLaunch, opts ...grpc.CallOption) (*MsgInstantSpotMarketLaunchResponse, error)
	// InstantPerpetualMarketLaunch defines a method for creating a new perpetual futures market by paying listing fee without governance
	InstantPerpetualMarketLaunch(ctx context.Context, in *MsgInstantPerpetualMarketLaunch, opts ...grpc.CallOption) (*MsgInstantPerpetualMarketLaunchResponse, error)
	// InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry futures market by paying listing fee without governance
	InstantExpiryFuturesMarketLaunch(ctx context.Context, in *MsgInstantExpiryFuturesMarketLaunch, opts ...grpc.CallOption) (*MsgInstantExpiryFuturesMarketLaunchResponse, error)
	// CreateSpotLimitOrder defines a method for creating a new spot limit order.
	CreateSpotLimitOrder(ctx context.Context, in *MsgCreateSpotLimitOrder, opts ...grpc.CallOption) (*MsgCreateSpotLimitOrderResponse, error)
	// BatchCreateSpotLimitOrder defines a method for creating a new batch of spot limit orders.
	BatchCreateSpotLimitOrders(ctx context.Context, in *MsgBatchCreateSpotLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateSpotLimitOrdersResponse, error)
	// CreateSpotMarketOrder defines a method for creating a new spot market order.
	CreateSpotMarketOrder(ctx context.Context, in *MsgCreateSpotMarketOrder, opts ...grpc.CallOption) (*MsgCreateSpotMarketOrderResponse, error)
	// MsgCancelSpotOrder defines a method for cancelling a spot order.
	CancelSpotOrder(ctx context.Context, in *MsgCancelSpotOrder, opts ...grpc.CallOption) (*MsgCancelSpotOrderResponse, error)
	// BatchCancelSpotOrders defines a method for cancelling a batch of spot orders in a given market.
	BatchCancelSpotOrders(ctx context.Context, in *MsgBatchCancelSpotOrders, opts ...grpc.CallOption) (*MsgBatchCancelSpotOrdersResponse, error)
	// BatchUpdateOrders defines a method for updating a batch of orders.
	BatchUpdateOrders(ctx context.Context, in *MsgBatchUpdateOrders, opts ...grpc.CallOption) (*MsgBatchUpdateOrdersResponse, error)
	// Exec defines a method for executing a Cosmwasm contract from the exchange module with privileged capabilities.
	Exec(ctx context.Context, in *MsgExec, opts ...grpc.CallOption) (*MsgExecResponse, error)
	// CreateDerivativeLimitOrder defines a method for creating a new derivative limit order.
	CreateDerivativeLimitOrder(ctx context.Context, in *MsgCreateDerivativeLimitOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeLimitOrderResponse, error)
	// BatchCreateDerivativeLimitOrders defines a method for creating a new batch of derivative limit orders.
	BatchCreateDerivativeLimitOrders(ctx context.Context, in *MsgBatchCreateDerivativeLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateDerivativeLimitOrdersResponse, error)
	// MsgCreateDerivativeLimitOrder defines a method for creating a new derivative market order.
	CreateDerivativeMarketOrder(ctx context.Context, in *MsgCreateDerivativeMarketOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeMarketOrderResponse, error)
	// MsgCancelDerivativeOrder defines a method for cancelling a derivative order.
	CancelDerivativeOrder(ctx context.Context, in *MsgCancelDerivativeOrder, opts ...grpc.CallOption) (*MsgCancelDerivativeOrderResponse, error)
	// MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of derivative limit orders.
	BatchCancelDerivativeOrders(ctx context.Context, in *MsgBatchCancelDerivativeOrders, opts ...grpc.CallOption) (*MsgBatchCancelDerivativeOrdersResponse, error)
	// InstantBinaryOptionsMarketLaunch defines method for creating a binary options market by paying listing fee without governance
	InstantBinaryOptionsMarketLaunch(ctx context.Context, in *MsgInstantBinaryOptionsMarketLaunch, opts ...grpc.CallOption) (*MsgInstantBinaryOptionsMarketLaunchResponse, error)
	// CreateBinaryOptionsLimitOrder defines a method for creating a new binary options limit order.
	CreateBinaryOptionsLimitOrder(ctx context.Context, in *MsgCreateBinaryOptionsLimitOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsLimitOrderResponse, error)
	// CreateBinaryOptionsMarketOrder defines a method for creating a new binary options market order.
	CreateBinaryOptionsMarketOrder(ctx context.Context, in *MsgCreateBinaryOptionsMarketOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsMarketOrderResponse, error)
	// MsgCancelBinaryOptionsOrder defines a method for cancelling a binary options order.
	CancelBinaryOptionsOrder(ctx context.Context, in *MsgCancelBinaryOptionsOrder, opts ...grpc.CallOption) (*MsgCancelBinaryOptionsOrderResponse, error)
	// BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of binary options limit orders.
	BatchCancelBinaryOptionsOrders(ctx context.Context, in *MsgBatchCancelBinaryOptionsOrders, opts ...grpc.CallOption) (*MsgBatchCancelBinaryOptionsOrdersResponse, error)
	// SubaccountTransfer defines a method for transfer between subaccounts
	SubaccountTransfer(ctx context.Context, in *MsgSubaccountTransfer, opts ...grpc.CallOption) (*MsgSubaccountTransferResponse, error)
	// ExternalTransfer defines a method for transfer between external accounts
	ExternalTransfer(ctx context.Context, in *MsgExternalTransfer, opts ...grpc.CallOption) (*MsgExternalTransferResponse, error)
	// LiquidatePosition defines a method for liquidating a position
	LiquidatePosition(ctx context.Context, in *MsgLiquidatePosition, opts ...grpc.CallOption) (*MsgLiquidatePositionResponse, error)
	// IncreasePositionMargin defines a method for increasing margin of a position
	IncreasePositionMargin(ctx context.Context, in *MsgIncreasePositionMargin, opts ...grpc.CallOption) (*MsgIncreasePositionMarginResponse, error)
	// RewardsOptOut defines a method for opting out of rewards
	RewardsOptOut(ctx context.Context, in *MsgRewardsOptOut, opts ...grpc.CallOption) (*MsgRewardsOptOutResponse, error)
	// AdminUpdateBinaryOptionsMarket defines method for updating a binary options market by admin
	AdminUpdateBinaryOptionsMarket(ctx context.Context, in *MsgAdminUpdateBinaryOptionsMarket, opts ...grpc.CallOption) (*MsgAdminUpdateBinaryOptionsMarketResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error) {
	out := new(MsgDepositResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error) {
	out := new(MsgWithdrawResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/Withdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantSpotMarketLaunch(ctx context.Context, in *MsgInstantSpotMarketLaunch, opts ...grpc.CallOption) (*MsgInstantSpotMarketLaunchResponse, error) {
	out := new(MsgInstantSpotMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantSpotMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantPerpetualMarketLaunch(ctx context.Context, in *MsgInstantPerpetualMarketLaunch, opts ...grpc.CallOption) (*MsgInstantPerpetualMarketLaunchResponse, error) {
	out := new(MsgInstantPerpetualMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantPerpetualMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantExpiryFuturesMarketLaunch(ctx context.Context, in *MsgInstantExpiryFuturesMarketLaunch, opts ...grpc.CallOption) (*MsgInstantExpiryFuturesMarketLaunchResponse, error) {
	out := new(MsgInstantExpiryFuturesMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantExpiryFuturesMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSpotLimitOrder(ctx context.Context, in *MsgCreateSpotLimitOrder, opts ...grpc.CallOption) (*MsgCreateSpotLimitOrderResponse, error) {
	out := new(MsgCreateSpotLimitOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateSpotLimitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCreateSpotLimitOrders(ctx context.Context, in *MsgBatchCreateSpotLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateSpotLimitOrdersResponse, error) {
	out := new(MsgBatchCreateSpotLimitOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCreateSpotLimitOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSpotMarketOrder(ctx context.Context, in *MsgCreateSpotMarketOrder, opts ...grpc.CallOption) (*MsgCreateSpotMarketOrderResponse, error) {
	out := new(MsgCreateSpotMarketOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateSpotMarketOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelSpotOrder(ctx context.Context, in *MsgCancelSpotOrder, opts ...grpc.CallOption) (*MsgCancelSpotOrderResponse, error) {
	out := new(MsgCancelSpotOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CancelSpotOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelSpotOrders(ctx context.Context, in *MsgBatchCancelSpotOrders, opts ...grpc.CallOption) (*MsgBatchCancelSpotOrdersResponse, error) {
	out := new(MsgBatchCancelSpotOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCancelSpotOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchUpdateOrders(ctx context.Context, in *MsgBatchUpdateOrders, opts ...grpc.CallOption) (*MsgBatchUpdateOrdersResponse, error) {
	out := new(MsgBatchUpdateOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchUpdateOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Exec(ctx context.Context, in *MsgExec, opts ...grpc.CallOption) (*MsgExecResponse, error) {
	out := new(MsgExecResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/Exec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDerivativeLimitOrder(ctx context.Context, in *MsgCreateDerivativeLimitOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeLimitOrderResponse, error) {
	out := new(MsgCreateDerivativeLimitOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateDerivativeLimitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCreateDerivativeLimitOrders(ctx context.Context, in *MsgBatchCreateDerivativeLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateDerivativeLimitOrdersResponse, error) {
	out := new(MsgBatchCreateDerivativeLimitOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCreateDerivativeLimitOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDerivativeMarketOrder(ctx context.Context, in *MsgCreateDerivativeMarketOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeMarketOrderResponse, error) {
	out := new(MsgCreateDerivativeMarketOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateDerivativeMarketOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelDerivativeOrder(ctx context.Context, in *MsgCancelDerivativeOrder, opts ...grpc.CallOption) (*MsgCancelDerivativeOrderResponse, error) {
	out := new(MsgCancelDerivativeOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CancelDerivativeOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelDerivativeOrders(ctx context.Context, in *MsgBatchCancelDerivativeOrders, opts ...grpc.CallOption) (*MsgBatchCancelDerivativeOrdersResponse, error) {
	out := new(MsgBatchCancelDerivativeOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCancelDerivativeOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantBinaryOptionsMarketLaunch(ctx context.Context, in *MsgInstantBinaryOptionsMarketLaunch, opts ...grpc.CallOption) (*MsgInstantBinaryOptionsMarketLaunchResponse, error) {
	out := new(MsgInstantBinaryOptionsMarketLaunchResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/InstantBinaryOptionsMarketLaunch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBinaryOptionsLimitOrder(ctx context.Context, in *MsgCreateBinaryOptionsLimitOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsLimitOrderResponse, error) {
	out := new(MsgCreateBinaryOptionsLimitOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsLimitOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBinaryOptionsMarketOrder(ctx context.Context, in *MsgCreateBinaryOptionsMarketOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsMarketOrderResponse, error) {
	out := new(MsgCreateBinaryOptionsMarketOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsMarketOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelBinaryOptionsOrder(ctx context.Context, in *MsgCancelBinaryOptionsOrder, opts ...grpc.CallOption) (*MsgCancelBinaryOptionsOrderResponse, error) {
	out := new(MsgCancelBinaryOptionsOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/CancelBinaryOptionsOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelBinaryOptionsOrders(ctx context.Context, in *MsgBatchCancelBinaryOptionsOrders, opts ...grpc.CallOption) (*MsgBatchCancelBinaryOptionsOrdersResponse, error) {
	out := new(MsgBatchCancelBinaryOptionsOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/BatchCancelBinaryOptionsOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubaccountTransfer(ctx context.Context, in *MsgSubaccountTransfer, opts ...grpc.CallOption) (*MsgSubaccountTransferResponse, error) {
	out := new(MsgSubaccountTransferResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/SubaccountTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ExternalTransfer(ctx context.Context, in *MsgExternalTransfer, opts ...grpc.CallOption) (*MsgExternalTransferResponse, error) {
	out := new(MsgExternalTransferResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/ExternalTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LiquidatePosition(ctx context.Context, in *MsgLiquidatePosition, opts ...grpc.CallOption) (*MsgLiquidatePositionResponse, error) {
	out := new(MsgLiquidatePositionResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/LiquidatePosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IncreasePositionMargin(ctx context.Context, in *MsgIncreasePositionMargin, opts ...grpc.CallOption) (*MsgIncreasePositionMarginResponse, error) {
	out := new(MsgIncreasePositionMarginResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/IncreasePositionMargin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RewardsOptOut(ctx context.Context, in *MsgRewardsOptOut, opts ...grpc.CallOption) (*MsgRewardsOptOutResponse, error) {
	out := new(MsgRewardsOptOutResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/RewardsOptOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AdminUpdateBinaryOptionsMarket(ctx context.Context, in *MsgAdminUpdateBinaryOptionsMarket, opts ...grpc.CallOption) (*MsgAdminUpdateBinaryOptionsMarketResponse, error) {
	out := new(MsgAdminUpdateBinaryOptionsMarketResponse)
	err := c.cc.Invoke(ctx, "/injective.exchange.v1beta1.Msg/AdminUpdateBinaryOptionsMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Deposit defines a method for transferring coins from the sender's bank balance into the subaccount's exchange deposits
	Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error)
	// Withdraw defines a method for withdrawing coins from a subaccount's deposits to the user's bank balance
	Withdraw(context.Context, *MsgWithdraw) (*MsgWithdrawResponse, error)
	// InstantSpotMarketLaunch defines method for creating a spot market by paying listing fee without governance
	InstantSpotMarketLaunch(context.Context, *MsgInstantSpotMarketLaunch) (*MsgInstantSpotMarketLaunchResponse, error)
	// InstantPerpetualMarketLaunch defines a method for creating a new perpetual futures market by paying listing fee without governance
	InstantPerpetualMarketLaunch(context.Context, *MsgInstantPerpetualMarketLaunch) (*MsgInstantPerpetualMarketLaunchResponse, error)
	// InstantExpiryFuturesMarketLaunch defines a method for creating a new expiry futures market by paying listing fee without governance
	InstantExpiryFuturesMarketLaunch(context.Context, *MsgInstantExpiryFuturesMarketLaunch) (*MsgInstantExpiryFuturesMarketLaunchResponse, error)
	// CreateSpotLimitOrder defines a method for creating a new spot limit order.
	CreateSpotLimitOrder(context.Context, *MsgCreateSpotLimitOrder) (*MsgCreateSpotLimitOrderResponse, error)
	// BatchCreateSpotLimitOrder defines a method for creating a new batch of spot limit orders.
	BatchCreateSpotLimitOrders(context.Context, *MsgBatchCreateSpotLimitOrders) (*MsgBatchCreateSpotLimitOrdersResponse, error)
	// CreateSpotMarketOrder defines a method for creating a new spot market order.
	CreateSpotMarketOrder(context.Context, *MsgCreateSpotMarketOrder) (*MsgCreateSpotMarketOrderResponse, error)
	// MsgCancelSpotOrder defines a method for cancelling a spot order.
	CancelSpotOrder(context.Context, *MsgCancelSpotOrder) (*MsgCancelSpotOrderResponse, error)
	// BatchCancelSpotOrders defines a method for cancelling a batch of spot orders in a given market.
	BatchCancelSpotOrders(context.Context, *MsgBatchCancelSpotOrders) (*MsgBatchCancelSpotOrdersResponse, error)
	// BatchUpdateOrders defines a method for updating a batch of orders.
	BatchUpdateOrders(context.Context, *MsgBatchUpdateOrders) (*MsgBatchUpdateOrdersResponse, error)
	// Exec defines a method for executing a Cosmwasm contract from the exchange module with privileged capabilities.
	Exec(context.Context, *MsgExec) (*MsgExecResponse, error)
	// CreateDerivativeLimitOrder defines a method for creating a new derivative limit order.
	CreateDerivativeLimitOrder(context.Context, *MsgCreateDerivativeLimitOrder) (*MsgCreateDerivativeLimitOrderResponse, error)
	// BatchCreateDerivativeLimitOrders defines a method for creating a new batch of derivative limit orders.
	BatchCreateDerivativeLimitOrders(context.Context, *MsgBatchCreateDerivativeLimitOrders) (*MsgBatchCreateDerivativeLimitOrdersResponse, error)
	// MsgCreateDerivativeLimitOrder defines a method for creating a new derivative market order.
	CreateDerivativeMarketOrder(context.Context, *MsgCreateDerivativeMarketOrder) (*MsgCreateDerivativeMarketOrderResponse, error)
	// MsgCancelDerivativeOrder defines a method for cancelling a derivative order.
	CancelDerivativeOrder(context.Context, *MsgCancelDerivativeOrder) (*MsgCancelDerivativeOrderResponse, error)
	// MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of derivative limit orders.
	BatchCancelDerivativeOrders(context.Context, *MsgBatchCancelDerivativeOrders) (*MsgBatchCancelDerivativeOrdersResponse, error)
	// InstantBinaryOptionsMarketLaunch defines method for creating a binary options market by paying listing fee without governance
	InstantBinaryOptionsMarketLaunch(context.Context, *MsgInstantBinaryOptionsMarketLaunch) (*MsgInstantBinaryOptionsMarketLaunchResponse, error)
	// CreateBinaryOptionsLimitOrder defines a method for creating a new binary options limit order.
	CreateBinaryOptionsLimitOrder(context.Context, *MsgCreateBinaryOptionsLimitOrder) (*MsgCreateBinaryOptionsLimitOrderResponse, error)
	// CreateBinaryOptionsMarketOrder defines a method for creating a new binary options market order.
	CreateBinaryOptionsMarketOrder(context.Context, *MsgCreateBinaryOptionsMarketOrder) (*MsgCreateBinaryOptionsMarketOrderResponse, error)
	// MsgCancelBinaryOptionsOrder defines a method for cancelling a binary options order.
	CancelBinaryOptionsOrder(context.Context, *MsgCancelBinaryOptionsOrder) (*MsgCancelBinaryOptionsOrderResponse, error)
	// BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of binary options limit orders.
	BatchCancelBinaryOptionsOrders(context.Context, *MsgBatchCancelBinaryOptionsOrders) (*MsgBatchCancelBinaryOptionsOrdersResponse, error)
	// SubaccountTransfer defines a method for transfer between subaccounts
	SubaccountTransfer(context.Context, *MsgSubaccountTransfer) (*MsgSubaccountTransferResponse, error)
	// ExternalTransfer defines a method for transfer between external accounts
	ExternalTransfer(context.Context, *MsgExternalTransfer) (*MsgExternalTransferResponse, error)
	// LiquidatePosition defines a method for liquidating a position
	LiquidatePosition(context.Context, *MsgLiquidatePosition) (*MsgLiquidatePositionResponse, error)
	// IncreasePositionMargin defines a method for increasing margin of a position
	IncreasePositionMargin(context.Context, *MsgIncreasePositionMargin) (*MsgIncreasePositionMarginResponse, error)
	// RewardsOptOut defines a method for opting out of rewards
	RewardsOptOut(context.Context, *MsgRewardsOptOut) (*MsgRewardsOptOutResponse, error)
	// AdminUpdateBinaryOptionsMarket defines method for updating a binary options market by admin
	AdminUpdateBinaryOptionsMarket(context.Context, *MsgAdminUpdateBinaryOptionsMarket) (*MsgAdminUpdateBinaryOptionsMarketResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Deposit(ctx context.Context, req *MsgDeposit) (*MsgDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (*UnimplementedMsgServer) Withdraw(ctx context.Context, req *MsgWithdraw) (*MsgWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}
func (*UnimplementedMsgServer) InstantSpotMarketLaunch(ctx context.Context, req *MsgInstantSpotMarketLaunch) (*MsgInstantSpotMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantSpotMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) InstantPerpetualMarketLaunch(ctx context.Context, req *MsgInstantPerpetualMarketLaunch) (*MsgInstantPerpetualMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantPerpetualMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) InstantExpiryFuturesMarketLaunch(ctx context.Context, req *MsgInstantExpiryFuturesMarketLaunch) (*MsgInstantExpiryFuturesMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantExpiryFuturesMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) CreateSpotLimitOrder(ctx context.Context, req *MsgCreateSpotLimitOrder) (*MsgCreateSpotLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSpotLimitOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCreateSpotLimitOrders(ctx context.Context, req *MsgBatchCreateSpotLimitOrders) (*MsgBatchCreateSpotLimitOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateSpotLimitOrders not implemented")
}
func (*UnimplementedMsgServer) CreateSpotMarketOrder(ctx context.Context, req *MsgCreateSpotMarketOrder) (*MsgCreateSpotMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSpotMarketOrder not implemented")
}
func (*UnimplementedMsgServer) CancelSpotOrder(ctx context.Context, req *MsgCancelSpotOrder) (*MsgCancelSpotOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSpotOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCancelSpotOrders(ctx context.Context, req *MsgBatchCancelSpotOrders) (*MsgBatchCancelSpotOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelSpotOrders not implemented")
}
func (*UnimplementedMsgServer) BatchUpdateOrders(ctx context.Context, req *MsgBatchUpdateOrders) (*MsgBatchUpdateOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateOrders not implemented")
}
func (*UnimplementedMsgServer) Exec(ctx context.Context, req *MsgExec) (*MsgExecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (*UnimplementedMsgServer) CreateDerivativeLimitOrder(ctx context.Context, req *MsgCreateDerivativeLimitOrder) (*MsgCreateDerivativeLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDerivativeLimitOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCreateDerivativeLimitOrders(ctx context.Context, req *MsgBatchCreateDerivativeLimitOrders) (*MsgBatchCreateDerivativeLimitOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateDerivativeLimitOrders not implemented")
}
func (*UnimplementedMsgServer) CreateDerivativeMarketOrder(ctx context.Context, req *MsgCreateDerivativeMarketOrder) (*MsgCreateDerivativeMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDerivativeMarketOrder not implemented")
}
func (*UnimplementedMsgServer) CancelDerivativeOrder(ctx context.Context, req *MsgCancelDerivativeOrder) (*MsgCancelDerivativeOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelDerivativeOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCancelDerivativeOrders(ctx context.Context, req *MsgBatchCancelDerivativeOrders) (*MsgBatchCancelDerivativeOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelDerivativeOrders not implemented")
}
func (*UnimplementedMsgServer) InstantBinaryOptionsMarketLaunch(ctx context.Context, req *MsgInstantBinaryOptionsMarketLaunch) (*MsgInstantBinaryOptionsMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantBinaryOptionsMarketLaunch not implemented")
}
func (*UnimplementedMsgServer) CreateBinaryOptionsLimitOrder(ctx context.Context, req *MsgCreateBinaryOptionsLimitOrder) (*MsgCreateBinaryOptionsLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBinaryOptionsLimitOrder not implemented")
}
func (*UnimplementedMsgServer) CreateBinaryOptionsMarketOrder(ctx context.Context, req *MsgCreateBinaryOptionsMarketOrder) (*MsgCreateBinaryOptionsMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBinaryOptionsMarketOrder not implemented")
}
func (*UnimplementedMsgServer) CancelBinaryOptionsOrder(ctx context.Context, req *MsgCancelBinaryOptionsOrder) (*MsgCancelBinaryOptionsOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBinaryOptionsOrder not implemented")
}
func (*UnimplementedMsgServer) BatchCancelBinaryOptionsOrders(ctx context.Context, req *MsgBatchCancelBinaryOptionsOrders) (*MsgBatchCancelBinaryOptionsOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelBinaryOptionsOrders not implemented")
}
func (*UnimplementedMsgServer) SubaccountTransfer(ctx context.Context, req *MsgSubaccountTransfer) (*MsgSubaccountTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubaccountTransfer not implemented")
}
func (*UnimplementedMsgServer) ExternalTransfer(ctx context.Context, req *MsgExternalTransfer) (*MsgExternalTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExternalTransfer not implemented")
}
func (*UnimplementedMsgServer) LiquidatePosition(ctx context.Context, req *MsgLiquidatePosition) (*MsgLiquidatePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidatePosition not implemented")
}
func (*UnimplementedMsgServer) IncreasePositionMargin(ctx context.Context, req *MsgIncreasePositionMargin) (*MsgIncreasePositionMarginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncreasePositionMargin not implemented")
}
func (*UnimplementedMsgServer) RewardsOptOut(ctx context.Context, req *MsgRewardsOptOut) (*MsgRewardsOptOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardsOptOut not implemented")
}
func (*UnimplementedMsgServer) AdminUpdateBinaryOptionsMarket(ctx context.Context, req *MsgAdminUpdateBinaryOptionsMarket) (*MsgAdminUpdateBinaryOptionsMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminUpdateBinaryOptionsMarket not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/Withdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Withdraw(ctx, req.(*MsgWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantSpotMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantSpotMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantSpotMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantSpotMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantSpotMarketLaunch(ctx, req.(*MsgInstantSpotMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantPerpetualMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantPerpetualMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantPerpetualMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantPerpetualMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantPerpetualMarketLaunch(ctx, req.(*MsgInstantPerpetualMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantExpiryFuturesMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantExpiryFuturesMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantExpiryFuturesMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantExpiryFuturesMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantExpiryFuturesMarketLaunch(ctx, req.(*MsgInstantExpiryFuturesMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSpotLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSpotLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSpotLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateSpotLimitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSpotLimitOrder(ctx, req.(*MsgCreateSpotLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCreateSpotLimitOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCreateSpotLimitOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCreateSpotLimitOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCreateSpotLimitOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCreateSpotLimitOrders(ctx, req.(*MsgBatchCreateSpotLimitOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSpotMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSpotMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSpotMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateSpotMarketOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSpotMarketOrder(ctx, req.(*MsgCreateSpotMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelSpotOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelSpotOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelSpotOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CancelSpotOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelSpotOrder(ctx, req.(*MsgCancelSpotOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelSpotOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelSpotOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelSpotOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCancelSpotOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelSpotOrders(ctx, req.(*MsgBatchCancelSpotOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchUpdateOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchUpdateOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchUpdateOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchUpdateOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchUpdateOrders(ctx, req.(*MsgBatchUpdateOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Exec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgExec)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Exec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/Exec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Exec(ctx, req.(*MsgExec))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDerivativeLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDerivativeLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDerivativeLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateDerivativeLimitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDerivativeLimitOrder(ctx, req.(*MsgCreateDerivativeLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCreateDerivativeLimitOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCreateDerivativeLimitOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCreateDerivativeLimitOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCreateDerivativeLimitOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCreateDerivativeLimitOrders(ctx, req.(*MsgBatchCreateDerivativeLimitOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDerivativeMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDerivativeMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDerivativeMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateDerivativeMarketOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDerivativeMarketOrder(ctx, req.(*MsgCreateDerivativeMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelDerivativeOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelDerivativeOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelDerivativeOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CancelDerivativeOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelDerivativeOrder(ctx, req.(*MsgCancelDerivativeOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelDerivativeOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelDerivativeOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelDerivativeOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCancelDerivativeOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelDerivativeOrders(ctx, req.(*MsgBatchCancelDerivativeOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantBinaryOptionsMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantBinaryOptionsMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantBinaryOptionsMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/InstantBinaryOptionsMarketLaunch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantBinaryOptionsMarketLaunch(ctx, req.(*MsgInstantBinaryOptionsMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBinaryOptionsLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBinaryOptionsLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBinaryOptionsLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsLimitOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBinaryOptionsLimitOrder(ctx, req.(*MsgCreateBinaryOptionsLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBinaryOptionsMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBinaryOptionsMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBinaryOptionsMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsMarketOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBinaryOptionsMarketOrder(ctx, req.(*MsgCreateBinaryOptionsMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelBinaryOptionsOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelBinaryOptionsOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelBinaryOptionsOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/CancelBinaryOptionsOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelBinaryOptionsOrder(ctx, req.(*MsgCancelBinaryOptionsOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelBinaryOptionsOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelBinaryOptionsOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelBinaryOptionsOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/BatchCancelBinaryOptionsOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelBinaryOptionsOrders(ctx, req.(*MsgBatchCancelBinaryOptionsOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubaccountTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubaccountTransfer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubaccountTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/SubaccountTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubaccountTransfer(ctx, req.(*MsgSubaccountTransfer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ExternalTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgExternalTransfer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ExternalTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/ExternalTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ExternalTransfer(ctx, req.(*MsgExternalTransfer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LiquidatePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLiquidatePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LiquidatePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/LiquidatePosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LiquidatePosition(ctx, req.(*MsgLiquidatePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IncreasePositionMargin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIncreasePositionMargin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IncreasePositionMargin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/IncreasePositionMargin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IncreasePositionMargin(ctx, req.(*MsgIncreasePositionMargin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RewardsOptOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRewardsOptOut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RewardsOptOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/RewardsOptOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RewardsOptOut(ctx, req.(*MsgRewardsOptOut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AdminUpdateBinaryOptionsMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAdminUpdateBinaryOptionsMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AdminUpdateBinaryOptionsMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.exchange.v1beta1.Msg/AdminUpdateBinaryOptionsMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AdminUpdateBinaryOptionsMarket(ctx, req.(*MsgAdminUpdateBinaryOptionsMarket))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "injective.exchange.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _Msg_Withdraw_Handler,
		},
		{
			MethodName: "InstantSpotMarketLaunch",
			Handler:    _Msg_InstantSpotMarketLaunch_Handler,
		},
		{
			MethodName: "InstantPerpetualMarketLaunch",
			Handler:    _Msg_InstantPerpetualMarketLaunch_Handler,
		},
		{
			MethodName: "InstantExpiryFuturesMarketLaunch",
			Handler:    _Msg_InstantExpiryFuturesMarketLaunch_Handler,
		},
		{
			MethodName: "CreateSpotLimitOrder",
			Handler:    _Msg_CreateSpotLimitOrder_Handler,
		},
		{
			MethodName: "BatchCreateSpotLimitOrders",
			Handler:    _Msg_BatchCreateSpotLimitOrders_Handler,
		},
		{
			MethodName: "CreateSpotMarketOrder",
			Handler:    _Msg_CreateSpotMarketOrder_Handler,
		},
		{
			MethodName: "CancelSpotOrder",
			Handler:    _Msg_CancelSpotOrder_Handler,
		},
		{
			MethodName: "BatchCancelSpotOrders",
			Handler:    _Msg_BatchCancelSpotOrders_Handler,
		},
		{
			MethodName: "BatchUpdateOrders",
			Handler:    _Msg_BatchUpdateOrders_Handler,
		},
		{
			MethodName: "Exec",
			Handler:    _Msg_Exec_Handler,
		},
		{
			MethodName: "CreateDerivativeLimitOrder",
			Handler:    _Msg_CreateDerivativeLimitOrder_Handler,
		},
		{
			MethodName: "BatchCreateDerivativeLimitOrders",
			Handler:    _Msg_BatchCreateDerivativeLimitOrders_Handler,
		},
		{
			MethodName: "CreateDerivativeMarketOrder",
			Handler:    _Msg_CreateDerivativeMarketOrder_Handler,
		},
		{
			MethodName: "CancelDerivativeOrder",
			Handler:    _Msg_CancelDerivativeOrder_Handler,
		},
		{
			MethodName: "BatchCancelDerivativeOrders",
			Handler:    _Msg_BatchCancelDerivativeOrders_Handler,
		},
		{
			MethodName: "InstantBinaryOptionsMarketLaunch",
			Handler:    _Msg_InstantBinaryOptionsMarketLaunch_Handler,
		},
		{
			MethodName: "CreateBinaryOptionsLimitOrder",
			Handler:    _Msg_CreateBinaryOptionsLimitOrder_Handler,
		},
		{
			MethodName: "CreateBinaryOptionsMarketOrder",
			Handler:    _Msg_CreateBinaryOptionsMarketOrder_Handler,
		},
		{
			MethodName: "CancelBinaryOptionsOrder",
			Handler:    _Msg_CancelBinaryOptionsOrder_Handler,
		},
		{
			MethodName: "BatchCancelBinaryOptionsOrders",
			Handler:    _Msg_BatchCancelBinaryOptionsOrders_Handler,
		},
		{
			MethodName: "SubaccountTransfer",
			Handler:    _Msg_SubaccountTransfer_Handler,
		},
		{
			MethodName: "ExternalTransfer",
			Handler:    _Msg_ExternalTransfer_Handler,
		},
		{
			MethodName: "LiquidatePosition",
			Handler:    _Msg_LiquidatePosition_Handler,
		},
		{
			MethodName: "IncreasePositionMargin",
			Handler:    _Msg_IncreasePositionMargin_Handler,
		},
		{
			MethodName: "RewardsOptOut",
			Handler:    _Msg_RewardsOptOut_Handler,
		},
		{
			MethodName: "AdminUpdateBinaryOptionsMarket",
			Handler:    _Msg_AdminUpdateBinaryOptionsMarket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "injective/exchange/v1beta1/tx.proto",
}

func (m *MsgDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotLimitOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotLimitOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotLimitOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateSpotLimitOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateSpotLimitOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateSpotLimitOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderHashes) > 0 {
		for iNdEx := len(m.OrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrderHashes[iNdEx])
			copy(dAtA[i:], m.OrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHashes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantSpotMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantSpotMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantSpotMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantSpotMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantSpotMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantSpotMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInstantPerpetualMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantPerpetualMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantPerpetualMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x38
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantPerpetualMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantPerpetualMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantPerpetualMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInstantBinaryOptionsMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantBinaryOptionsMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantBinaryOptionsMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x5a
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x50
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x30
	}
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OracleProvider) > 0 {
		i -= len(m.OracleProvider)
		copy(dAtA[i:], m.OracleProvider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleProvider)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OracleSymbol) > 0 {
		i -= len(m.OracleSymbol)
		copy(dAtA[i:], m.OracleSymbol)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInstantExpiryFuturesMarketLaunch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantExpiryFuturesMarketLaunch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantExpiryFuturesMarketLaunch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Expiry != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotMarketOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotMarketOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotMarketOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotMarketOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotMarketOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotMarketOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotMarketOrderResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarketOrderResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarketOrderResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeLimitOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeLimitOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeLimitOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateDerivativeLimitOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateDerivativeLimitOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateDerivativeLimitOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderHashes) > 0 {
		for iNdEx := len(m.OrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrderHashes[iNdEx])
			copy(dAtA[i:], m.OrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHashes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelSpotOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelSpotOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelSpotOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelSpotOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelSpotOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelSpotOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelSpotOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelSpotOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelSpotOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Success) > 0 {
		for iNdEx := len(m.Success) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Success[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.Success)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelBinaryOptionsOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelBinaryOptionsOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelBinaryOptionsOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Success) > 0 {
		for iNdEx := len(m.Success) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Success[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.Success)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchUpdateOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchUpdateOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchUpdateOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BinaryOptionsOrdersToCreate) > 0 {
		for iNdEx := len(m.BinaryOptionsOrdersToCreate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsOrdersToCreate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.BinaryOptionsMarketIdsToCancelAll) > 0 {
		for iNdEx := len(m.BinaryOptionsMarketIdsToCancelAll) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BinaryOptionsMarketIdsToCancelAll[iNdEx])
			copy(dAtA[i:], m.BinaryOptionsMarketIdsToCancelAll[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.BinaryOptionsMarketIdsToCancelAll[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BinaryOptionsOrdersToCancel) > 0 {
		for iNdEx := len(m.BinaryOptionsOrdersToCancel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsOrdersToCancel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.DerivativeOrdersToCreate) > 0 {
		for iNdEx := len(m.DerivativeOrdersToCreate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrdersToCreate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SpotOrdersToCreate) > 0 {
		for iNdEx := len(m.SpotOrdersToCreate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrdersToCreate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DerivativeOrdersToCancel) > 0 {
		for iNdEx := len(m.DerivativeOrdersToCancel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrdersToCancel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SpotOrdersToCancel) > 0 {
		for iNdEx := len(m.SpotOrdersToCancel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrdersToCancel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DerivativeMarketIdsToCancelAll) > 0 {
		for iNdEx := len(m.DerivativeMarketIdsToCancelAll) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DerivativeMarketIdsToCancelAll[iNdEx])
			copy(dAtA[i:], m.DerivativeMarketIdsToCancelAll[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.DerivativeMarketIdsToCancelAll[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SpotMarketIdsToCancelAll) > 0 {
		for iNdEx := len(m.SpotMarketIdsToCancelAll) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SpotMarketIdsToCancelAll[iNdEx])
			copy(dAtA[i:], m.SpotMarketIdsToCancelAll[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.SpotMarketIdsToCancelAll[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchUpdateOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchUpdateOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchUpdateOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BinaryOptionsOrderHashes) > 0 {
		for iNdEx := len(m.BinaryOptionsOrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BinaryOptionsOrderHashes[iNdEx])
			copy(dAtA[i:], m.BinaryOptionsOrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.BinaryOptionsOrderHashes[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BinaryOptionsCancelSuccess) > 0 {
		for iNdEx := len(m.BinaryOptionsCancelSuccess) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.BinaryOptionsCancelSuccess[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.BinaryOptionsCancelSuccess)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DerivativeOrderHashes) > 0 {
		for iNdEx := len(m.DerivativeOrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DerivativeOrderHashes[iNdEx])
			copy(dAtA[i:], m.DerivativeOrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.DerivativeOrderHashes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SpotOrderHashes) > 0 {
		for iNdEx := len(m.SpotOrderHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SpotOrderHashes[iNdEx])
			copy(dAtA[i:], m.SpotOrderHashes[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.SpotOrderHashes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DerivativeCancelSuccess) > 0 {
		for iNdEx := len(m.DerivativeCancelSuccess) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.DerivativeCancelSuccess[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.DerivativeCancelSuccess)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpotCancelSuccess) > 0 {
		for iNdEx := len(m.SpotCancelSuccess) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.SpotCancelSuccess[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.SpotCancelSuccess)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeMarketOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeMarketOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeMarketOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeMarketOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeMarketOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeMarketOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeMarketOrderResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarketOrderResults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarketOrderResults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Payout.Size()
		i -= size
		if _, err := m.Payout.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.PositionDelta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsMarketOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsMarketOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsMarketOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Results != nil {
		{
			size, err := m.Results.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderMask != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OrderMask))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelDerivativeOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelDerivativeOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelDerivativeOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCancelBinaryOptionsOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelBinaryOptionsOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelBinaryOptionsOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderMask != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OrderMask))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelBinaryOptionsOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelBinaryOptionsOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelBinaryOptionsOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OrderData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderMask != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OrderMask))
		i--
		dAtA[i] = 0x20
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelDerivativeOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelDerivativeOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelDerivativeOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchCancelDerivativeOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchCancelDerivativeOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchCancelDerivativeOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Success) > 0 {
		for iNdEx := len(m.Success) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Success[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintTx(dAtA, i, uint64(len(m.Success)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubaccountTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubaccountTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubaccountTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.DestinationSubaccountId) > 0 {
		i -= len(m.DestinationSubaccountId)
		copy(dAtA[i:], m.DestinationSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceSubaccountId) > 0 {
		i -= len(m.SourceSubaccountId)
		copy(dAtA[i:], m.SourceSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubaccountTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubaccountTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubaccountTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgExternalTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExternalTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExternalTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.DestinationSubaccountId) > 0 {
		i -= len(m.DestinationSubaccountId)
		copy(dAtA[i:], m.DestinationSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceSubaccountId) > 0 {
		i -= len(m.SourceSubaccountId)
		copy(dAtA[i:], m.SourceSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExternalTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExternalTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExternalTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgLiquidatePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidatePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidatePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgLiquidatePositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLiquidatePositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLiquidatePositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgIncreasePositionMargin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIncreasePositionMargin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIncreasePositionMargin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DestinationSubaccountId) > 0 {
		i -= len(m.DestinationSubaccountId)
		copy(dAtA[i:], m.DestinationSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DestinationSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceSubaccountId) > 0 {
		i -= len(m.SourceSubaccountId)
		copy(dAtA[i:], m.SourceSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceSubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIncreasePositionMarginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIncreasePositionMarginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIncreasePositionMarginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgExec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DepositFunds) > 0 {
		for iNdEx := len(m.DepositFunds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DepositFunds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DepositsSubaccountId) > 0 {
		i -= len(m.DepositsSubaccountId)
		copy(dAtA[i:], m.DepositsSubaccountId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DepositsSubaccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BankFunds) > 0 {
		for iNdEx := len(m.BankFunds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BankFunds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExecResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExecResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExecResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SpotMarketParamUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarketParamUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarketParamUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.MinQuantityTickSize != nil {
		{
			size := m.MinQuantityTickSize.Size()
			i -= size
			if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.MinPriceTickSize != nil {
		{
			size := m.MinPriceTickSize.Size()
			i -= size
			if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RelayerFeeShareRate != nil {
		{
			size := m.RelayerFeeShareRate.Size()
			i -= size
			if _, err := m.RelayerFeeShareRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeEnableProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeEnableProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeEnableProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExchangeType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExchangeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchExchangeModificationProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchExchangeModificationProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchExchangeModificationProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DenomDecimalsUpdateProposal != nil {
		{
			size, err := m.DenomDecimalsUpdateProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.BinaryOptionsParamUpdateProposals) > 0 {
		for iNdEx := len(m.BinaryOptionsParamUpdateProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsParamUpdateProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BinaryOptionsMarketLaunchProposals) > 0 {
		for iNdEx := len(m.BinaryOptionsMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BinaryOptionsMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.TradingRewardCampaignUpdateProposal != nil {
		{
			size, err := m.TradingRewardCampaignUpdateProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExpiryFuturesMarketLaunchProposals) > 0 {
		for iNdEx := len(m.ExpiryFuturesMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExpiryFuturesMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PerpetualMarketLaunchProposals) > 0 {
		for iNdEx := len(m.PerpetualMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PerpetualMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SpotMarketLaunchProposals) > 0 {
		for iNdEx := len(m.SpotMarketLaunchProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotMarketLaunchProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.DerivativeMarketParamUpdateProposals) > 0 {
		for iNdEx := len(m.DerivativeMarketParamUpdateProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeMarketParamUpdateProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SpotMarketParamUpdateProposals) > 0 {
		for iNdEx := len(m.SpotMarketParamUpdateProposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotMarketParamUpdateProposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PerpetualMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerpetualMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerpetualMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOptionsMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOptionsMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOptionsMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x52
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x48
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OracleProvider) > 0 {
		i -= len(m.OracleProvider)
		copy(dAtA[i:], m.OracleProvider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleProvider)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleSymbol) > 0 {
		i -= len(m.OracleSymbol)
		copy(dAtA[i:], m.OracleSymbol)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleSymbol)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExpiryFuturesMarketLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpiryFuturesMarketLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExpiryFuturesMarketLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinQuantityTickSize.Size()
		i -= size
		if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size := m.MinPriceTickSize.Size()
		i -= size
		if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.TakerFeeRate.Size()
		i -= size
		if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size := m.MakerFeeRate.Size()
		i -= size
		if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.MaintenanceMarginRatio.Size()
		i -= size
		if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.InitialMarginRatio.Size()
		i -= size
		if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Expiry != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x48
	}
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x38
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeMarketParamUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarketParamUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarketParamUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OracleParams != nil {
		{
			size, err := m.OracleParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x68
	}
	if m.HourlyFundingRateCap != nil {
		{
			size := m.HourlyFundingRateCap.Size()
			i -= size
			if _, err := m.HourlyFundingRateCap.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.HourlyInterestRate != nil {
		{
			size := m.HourlyInterestRate.Size()
			i -= size
			if _, err := m.HourlyInterestRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MinQuantityTickSize != nil {
		{
			size := m.MinQuantityTickSize.Size()
			i -= size
			if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.MinPriceTickSize != nil {
		{
			size := m.MinPriceTickSize.Size()
			i -= size
			if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.RelayerFeeShareRate != nil {
		{
			size := m.RelayerFeeShareRate.Size()
			i -= size
			if _, err := m.RelayerFeeShareRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MaintenanceMarginRatio != nil {
		{
			size := m.MaintenanceMarginRatio.Size()
			i -= size
			if _, err := m.MaintenanceMarginRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.InitialMarginRatio != nil {
		{
			size := m.InitialMarginRatio.Size()
			i -= size
			if _, err := m.InitialMarginRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketForcedSettlementProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketForcedSettlementProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketForcedSettlementProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SettlementPrice != nil {
		{
			size := m.SettlementPrice.Size()
			i -= size
			if _, err := m.SettlementPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDenomDecimalsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDenomDecimalsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDenomDecimalsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DenomDecimals) > 0 {
		for iNdEx := len(m.DenomDecimals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomDecimals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomDecimals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomDecimals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomDecimals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Decimals != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryOptionsMarketParamUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryOptionsMarketParamUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryOptionsMarketParamUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OracleParams != nil {
		{
			size, err := m.OracleParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x62
	}
	if m.SettlementPrice != nil {
		{
			size := m.SettlementPrice.Size()
			i -= size
			if _, err := m.SettlementPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x50
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x48
	}
	if m.MinQuantityTickSize != nil {
		{
			size := m.MinQuantityTickSize.Size()
			i -= size
			if _, err := m.MinQuantityTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.MinPriceTickSize != nil {
		{
			size := m.MinPriceTickSize.Size()
			i -= size
			if _, err := m.MinPriceTickSize.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RelayerFeeShareRate != nil {
		{
			size := m.RelayerFeeShareRate.Size()
			i -= size
			if _, err := m.RelayerFeeShareRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TakerFeeRate != nil {
		{
			size := m.TakerFeeRate.Size()
			i -= size
			if _, err := m.TakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MakerFeeRate != nil {
		{
			size := m.MakerFeeRate.Size()
			i -= size
			if _, err := m.MakerFeeRate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderOracleParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderOracleParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderOracleParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x20
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OracleType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x20
	}
	if m.OracleScaleFactor != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OracleScaleFactor))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OracleQuote) > 0 {
		i -= len(m.OracleQuote)
		copy(dAtA[i:], m.OracleQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleQuote)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OracleBase) > 0 {
		i -= len(m.OracleBase)
		copy(dAtA[i:], m.OracleBase)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OracleBase)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingRewardCampaignLaunchProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingRewardCampaignLaunchProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingRewardCampaignLaunchProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CampaignRewardPools) > 0 {
		for iNdEx := len(m.CampaignRewardPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CampaignRewardPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CampaignInfo != nil {
		{
			size, err := m.CampaignInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingRewardCampaignUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingRewardCampaignUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingRewardCampaignUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CampaignRewardPoolsUpdates) > 0 {
		for iNdEx := len(m.CampaignRewardPoolsUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CampaignRewardPoolsUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CampaignRewardPoolsAdditions) > 0 {
		for iNdEx := len(m.CampaignRewardPoolsAdditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CampaignRewardPoolsAdditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CampaignInfo != nil {
		{
			size, err := m.CampaignInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardPointUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardPointUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardPointUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewPoints.Size()
		i -= size
		if _, err := m.NewPoints.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradingRewardPendingPointsUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingRewardPendingPointsUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradingRewardPendingPointsUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardPointUpdates) > 0 {
		for iNdEx := len(m.RewardPointUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardPointUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PendingPoolTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PendingPoolTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeeDiscountProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeDiscountProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeDiscountProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchCommunityPoolSpendProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCommunityPoolSpendProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchCommunityPoolSpendProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proposals) > 0 {
		for iNdEx := len(m.Proposals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Proposals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRewardsOptOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRewardsOptOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRewardsOptOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRewardsOptOutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRewardsOptOutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRewardsOptOutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAdminUpdateBinaryOptionsMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAdminUpdateBinaryOptionsMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAdminUpdateBinaryOptionsMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.SettlementTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SettlementTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpirationTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpirationTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.SettlementPrice != nil {
		{
			size := m.SettlementPrice.Size()
			i -= size
			if _, err := m.SettlementPrice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketFeeMultipliers) > 0 {
		for iNdEx := len(m.MarketFeeMultipliers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MarketFeeMultipliers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdrawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateSpotLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateSpotLimitOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBatchCreateSpotLimitOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCreateSpotLimitOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderHashes) > 0 {
		for _, s := range m.OrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgInstantSpotMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantSpotMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInstantPerpetualMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantPerpetualMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInstantBinaryOptionsMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleSymbol)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleProvider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovTx(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovTx(uint64(m.SettlementTimestamp))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInstantExpiryFuturesMarketLaunch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.Expiry != 0 {
		n += 1 + sovTx(uint64(m.Expiry))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateSpotMarketOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateSpotMarketOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *SpotMarketOrderResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Quantity.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Price.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDerivativeLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDerivativeLimitOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateBinaryOptionsLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateBinaryOptionsLimitOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBatchCreateDerivativeLimitOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderHashes) > 0 {
		for _, s := range m.OrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCancelSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelSpotOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBatchCancelSpotOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCancelSpotOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Success) > 0 {
		n += 1 + sovTx(uint64(len(m.Success))) + len(m.Success)*1
	}
	return n
}

func (m *MsgBatchCancelBinaryOptionsOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Success) > 0 {
		n += 1 + sovTx(uint64(len(m.Success))) + len(m.Success)*1
	}
	return n
}

func (m *MsgBatchUpdateOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.SpotMarketIdsToCancelAll) > 0 {
		for _, s := range m.SpotMarketIdsToCancelAll {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeMarketIdsToCancelAll) > 0 {
		for _, s := range m.DerivativeMarketIdsToCancelAll {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.SpotOrdersToCancel) > 0 {
		for _, e := range m.SpotOrdersToCancel {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeOrdersToCancel) > 0 {
		for _, e := range m.DerivativeOrdersToCancel {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.SpotOrdersToCreate) > 0 {
		for _, e := range m.SpotOrdersToCreate {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeOrdersToCreate) > 0 {
		for _, e := range m.DerivativeOrdersToCreate {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsOrdersToCancel) > 0 {
		for _, e := range m.BinaryOptionsOrdersToCancel {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsMarketIdsToCancelAll) > 0 {
		for _, s := range m.BinaryOptionsMarketIdsToCancelAll {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsOrdersToCreate) > 0 {
		for _, e := range m.BinaryOptionsOrdersToCreate {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchUpdateOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpotCancelSuccess) > 0 {
		n += 1 + sovTx(uint64(len(m.SpotCancelSuccess))) + len(m.SpotCancelSuccess)*1
	}
	if len(m.DerivativeCancelSuccess) > 0 {
		n += 1 + sovTx(uint64(len(m.DerivativeCancelSuccess))) + len(m.DerivativeCancelSuccess)*1
	}
	if len(m.SpotOrderHashes) > 0 {
		for _, s := range m.SpotOrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeOrderHashes) > 0 {
		for _, s := range m.DerivativeOrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsCancelSuccess) > 0 {
		n += 1 + sovTx(uint64(len(m.BinaryOptionsCancelSuccess))) + len(m.BinaryOptionsCancelSuccess)*1
	}
	if len(m.BinaryOptionsOrderHashes) > 0 {
		for _, s := range m.BinaryOptionsOrderHashes {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateDerivativeMarketOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDerivativeMarketOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *DerivativeMarketOrderResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Quantity.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Price.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.PositionDelta.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Payout.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateBinaryOptionsMarketOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateBinaryOptionsMarketOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Results != nil {
		l = m.Results.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OrderMask != 0 {
		n += 1 + sovTx(uint64(m.OrderMask))
	}
	return n
}

func (m *MsgCancelDerivativeOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCancelBinaryOptionsOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OrderMask != 0 {
		n += 1 + sovTx(uint64(m.OrderMask))
	}
	return n
}

func (m *MsgCancelBinaryOptionsOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OrderData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OrderMask != 0 {
		n += 1 + sovTx(uint64(m.OrderMask))
	}
	return n
}

func (m *MsgBatchCancelDerivativeOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBatchCancelDerivativeOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Success) > 0 {
		n += 1 + sovTx(uint64(len(m.Success))) + len(m.Success)*1
	}
	return n
}

func (m *MsgSubaccountTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSubaccountTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgExternalTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgExternalTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgLiquidatePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgLiquidatePositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgIncreasePositionMargin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DestinationSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgIncreasePositionMarginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgExec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.BankFunds) > 0 {
		for _, e := range m.BankFunds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.DepositsSubaccountId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.DepositFunds) > 0 {
		for _, e := range m.DepositFunds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgExecResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SpotMarketParamUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RelayerFeeShareRate != nil {
		l = m.RelayerFeeShareRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinPriceTickSize != nil {
		l = m.MinPriceTickSize.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinQuantityTickSize != nil {
		l = m.MinQuantityTickSize.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	return n
}

func (m *ExchangeEnableProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ExchangeType != 0 {
		n += 1 + sovTx(uint64(m.ExchangeType))
	}
	return n
}

func (m *BatchExchangeModificationProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.SpotMarketParamUpdateProposals) > 0 {
		for _, e := range m.SpotMarketParamUpdateProposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.DerivativeMarketParamUpdateProposals) > 0 {
		for _, e := range m.DerivativeMarketParamUpdateProposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.SpotMarketLaunchProposals) > 0 {
		for _, e := range m.SpotMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.PerpetualMarketLaunchProposals) > 0 {
		for _, e := range m.PerpetualMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.ExpiryFuturesMarketLaunchProposals) > 0 {
		for _, e := range m.ExpiryFuturesMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.TradingRewardCampaignUpdateProposal != nil {
		l = m.TradingRewardCampaignUpdateProposal.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.BinaryOptionsMarketLaunchProposals) > 0 {
		for _, e := range m.BinaryOptionsMarketLaunchProposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BinaryOptionsParamUpdateProposals) > 0 {
		for _, e := range m.BinaryOptionsParamUpdateProposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.DenomDecimalsUpdateProposal != nil {
		l = m.DenomDecimalsUpdateProposal.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *SpotMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *PerpetualMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *BinaryOptionsMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleSymbol)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleProvider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovTx(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovTx(uint64(m.SettlementTimestamp))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *ExpiryFuturesMarketLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	if m.Expiry != 0 {
		n += 1 + sovTx(uint64(m.Expiry))
	}
	l = m.InitialMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaintenanceMarginRatio.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TakerFeeRate.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPriceTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinQuantityTickSize.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *DerivativeMarketParamUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.InitialMarginRatio != nil {
		l = m.InitialMarginRatio.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaintenanceMarginRatio != nil {
		l = m.MaintenanceMarginRatio.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RelayerFeeShareRate != nil {
		l = m.RelayerFeeShareRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinPriceTickSize != nil {
		l = m.MinPriceTickSize.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinQuantityTickSize != nil {
		l = m.MinQuantityTickSize.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.HourlyInterestRate != nil {
		l = m.HourlyInterestRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.HourlyFundingRateCap != nil {
		l = m.HourlyFundingRateCap.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	if m.OracleParams != nil {
		l = m.OracleParams.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MarketForcedSettlementProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SettlementPrice != nil {
		l = m.SettlementPrice.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *UpdateDenomDecimalsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.DenomDecimals) > 0 {
		for _, e := range m.DenomDecimals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *DenomDecimals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovTx(uint64(m.Decimals))
	}
	return n
}

func (m *BinaryOptionsMarketParamUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MakerFeeRate != nil {
		l = m.MakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TakerFeeRate != nil {
		l = m.TakerFeeRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RelayerFeeShareRate != nil {
		l = m.RelayerFeeShareRate.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinPriceTickSize != nil {
		l = m.MinPriceTickSize.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinQuantityTickSize != nil {
		l = m.MinQuantityTickSize.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovTx(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovTx(uint64(m.SettlementTimestamp))
	}
	if m.SettlementPrice != nil {
		l = m.SettlementPrice.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	if m.OracleParams != nil {
		l = m.OracleParams.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *ProviderOracleParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	return n
}

func (m *OracleParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleBase)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OracleQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OracleScaleFactor != 0 {
		n += 1 + sovTx(uint64(m.OracleScaleFactor))
	}
	if m.OracleType != 0 {
		n += 1 + sovTx(uint64(m.OracleType))
	}
	return n
}

func (m *TradingRewardCampaignLaunchProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CampaignInfo != nil {
		l = m.CampaignInfo.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.CampaignRewardPools) > 0 {
		for _, e := range m.CampaignRewardPools {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *TradingRewardCampaignUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CampaignInfo != nil {
		l = m.CampaignInfo.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.CampaignRewardPoolsAdditions) > 0 {
		for _, e := range m.CampaignRewardPoolsAdditions {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CampaignRewardPoolsUpdates) > 0 {
		for _, e := range m.CampaignRewardPoolsUpdates {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *RewardPointUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.NewPoints.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *TradingRewardPendingPointsUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PendingPoolTimestamp != 0 {
		n += 1 + sovTx(uint64(m.PendingPoolTimestamp))
	}
	if len(m.RewardPointUpdates) > 0 {
		for _, e := range m.RewardPointUpdates {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *FeeDiscountProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *BatchCommunityPoolSpendProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Proposals) > 0 {
		for _, e := range m.Proposals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgRewardsOptOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRewardsOptOutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAdminUpdateBinaryOptionsMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SettlementPrice != nil {
		l = m.SettlementPrice.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ExpirationTimestamp != 0 {
		n += 1 + sovTx(uint64(m.ExpirationTimestamp))
	}
	if m.SettlementTimestamp != 0 {
		n += 1 + sovTx(uint64(m.SettlementTimestamp))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	return n
}

func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.MarketFeeMultipliers) > 0 {
		for _, e := range m.MarketFeeMultipliers {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotLimitOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotLimitOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateSpotLimitOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, SpotOrder{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateSpotLimitOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateSpotLimitOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHashes = append(m.OrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantSpotMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantSpotMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantSpotMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantPerpetualMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantPerpetualMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantPerpetualMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantBinaryOptionsMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantBinaryOptionsMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantBinaryOptionsMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantExpiryFuturesMarketLaunch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInstantExpiryFuturesMarketLaunchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInstantExpiryFuturesMarketLaunchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotMarketOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotMarketOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotMarketOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &SpotMarketOrderResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotMarketOrderResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarketOrderResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarketOrderResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeLimitOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeLimitOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsLimitOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsLimitOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateDerivativeLimitOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, DerivativeOrder{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCreateDerivativeLimitOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCreateDerivativeLimitOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHashes = append(m.OrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelSpotOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelSpotOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelSpotOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelSpotOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, OrderData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelSpotOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelSpotOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Success = append(m.Success, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Success) == 0 {
					m.Success = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Success = append(m.Success, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelBinaryOptionsOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, OrderData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelBinaryOptionsOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelBinaryOptionsOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Success = append(m.Success, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Success) == 0 {
					m.Success = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Success = append(m.Success, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchUpdateOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchUpdateOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchUpdateOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotMarketIdsToCancelAll", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotMarketIdsToCancelAll = append(m.SpotMarketIdsToCancelAll, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeMarketIdsToCancelAll", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeMarketIdsToCancelAll = append(m.DerivativeMarketIdsToCancelAll, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrdersToCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrdersToCancel = append(m.SpotOrdersToCancel, &OrderData{})
			if err := m.SpotOrdersToCancel[len(m.SpotOrdersToCancel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrdersToCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrdersToCancel = append(m.DerivativeOrdersToCancel, &OrderData{})
			if err := m.DerivativeOrdersToCancel[len(m.DerivativeOrdersToCancel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrdersToCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrdersToCreate = append(m.SpotOrdersToCreate, &SpotOrder{})
			if err := m.SpotOrdersToCreate[len(m.SpotOrdersToCreate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrdersToCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrdersToCreate = append(m.DerivativeOrdersToCreate, &DerivativeOrder{})
			if err := m.DerivativeOrdersToCreate[len(m.DerivativeOrdersToCreate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsOrdersToCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsOrdersToCancel = append(m.BinaryOptionsOrdersToCancel, &OrderData{})
			if err := m.BinaryOptionsOrdersToCancel[len(m.BinaryOptionsOrdersToCancel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsMarketIdsToCancelAll", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsMarketIdsToCancelAll = append(m.BinaryOptionsMarketIdsToCancelAll, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsOrdersToCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsOrdersToCreate = append(m.BinaryOptionsOrdersToCreate, &DerivativeOrder{})
			if err := m.BinaryOptionsOrdersToCreate[len(m.BinaryOptionsOrdersToCreate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchUpdateOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchUpdateOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchUpdateOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpotCancelSuccess = append(m.SpotCancelSuccess, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.SpotCancelSuccess) == 0 {
					m.SpotCancelSuccess = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpotCancelSuccess = append(m.SpotCancelSuccess, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotCancelSuccess", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DerivativeCancelSuccess = append(m.DerivativeCancelSuccess, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.DerivativeCancelSuccess) == 0 {
					m.DerivativeCancelSuccess = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DerivativeCancelSuccess = append(m.DerivativeCancelSuccess, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeCancelSuccess", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrderHashes = append(m.SpotOrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrderHashes = append(m.DerivativeOrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BinaryOptionsCancelSuccess = append(m.BinaryOptionsCancelSuccess, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.BinaryOptionsCancelSuccess) == 0 {
					m.BinaryOptionsCancelSuccess = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BinaryOptionsCancelSuccess = append(m.BinaryOptionsCancelSuccess, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsCancelSuccess", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsOrderHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsOrderHashes = append(m.BinaryOptionsOrderHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeMarketOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeMarketOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeMarketOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &DerivativeMarketOrderResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeMarketOrderResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarketOrderResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarketOrderResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Payout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsMarketOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateBinaryOptionsMarketOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateBinaryOptionsMarketOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = &DerivativeMarketOrderResults{}
			}
			if err := m.Results.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderMask", wireType)
			}
			m.OrderMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelDerivativeOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelDerivativeOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelBinaryOptionsOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderMask", wireType)
			}
			m.OrderMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelBinaryOptionsOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelBinaryOptionsOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderMask", wireType)
			}
			m.OrderMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelDerivativeOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, OrderData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchCancelDerivativeOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchCancelDerivativeOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Success = append(m.Success, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Success) == 0 {
					m.Success = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Success = append(m.Success, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubaccountTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubaccountTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubaccountTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubaccountTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubaccountTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubaccountTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExternalTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExternalTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExternalTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExternalTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExternalTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExternalTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidatePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidatePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidatePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &DerivativeOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLiquidatePositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLiquidatePositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLiquidatePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIncreasePositionMargin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIncreasePositionMargin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIncreasePositionMargin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIncreasePositionMarginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIncreasePositionMarginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIncreasePositionMarginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankFunds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankFunds = append(m.BankFunds, types.Coin{})
			if err := m.BankFunds[len(m.BankFunds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositsSubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositsSubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositFunds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositFunds = append(m.DepositFunds, types.Coin{})
			if err := m.DepositFunds[len(m.DepositFunds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExecResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExecResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExecResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotMarketParamUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarketParamUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarketParamUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerFeeShareRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RelayerFeeShareRate = &v
			if err := m.RelayerFeeShareRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MinPriceTickSize = &v
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MinQuantityTickSize = &v
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeEnableProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeEnableProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeEnableProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeType", wireType)
			}
			m.ExchangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExchangeType |= ExchangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchExchangeModificationProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchExchangeModificationProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchExchangeModificationProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotMarketParamUpdateProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotMarketParamUpdateProposals = append(m.SpotMarketParamUpdateProposals, &SpotMarketParamUpdateProposal{})
			if err := m.SpotMarketParamUpdateProposals[len(m.SpotMarketParamUpdateProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeMarketParamUpdateProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeMarketParamUpdateProposals = append(m.DerivativeMarketParamUpdateProposals, &DerivativeMarketParamUpdateProposal{})
			if err := m.DerivativeMarketParamUpdateProposals[len(m.DerivativeMarketParamUpdateProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotMarketLaunchProposals = append(m.SpotMarketLaunchProposals, &SpotMarketLaunchProposal{})
			if err := m.SpotMarketLaunchProposals[len(m.SpotMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerpetualMarketLaunchProposals = append(m.PerpetualMarketLaunchProposals, &PerpetualMarketLaunchProposal{})
			if err := m.PerpetualMarketLaunchProposals[len(m.PerpetualMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryFuturesMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpiryFuturesMarketLaunchProposals = append(m.ExpiryFuturesMarketLaunchProposals, &ExpiryFuturesMarketLaunchProposal{})
			if err := m.ExpiryFuturesMarketLaunchProposals[len(m.ExpiryFuturesMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingRewardCampaignUpdateProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TradingRewardCampaignUpdateProposal == nil {
				m.TradingRewardCampaignUpdateProposal = &TradingRewardCampaignUpdateProposal{}
			}
			if err := m.TradingRewardCampaignUpdateProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsMarketLaunchProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsMarketLaunchProposals = append(m.BinaryOptionsMarketLaunchProposals, &BinaryOptionsMarketLaunchProposal{})
			if err := m.BinaryOptionsMarketLaunchProposals[len(m.BinaryOptionsMarketLaunchProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryOptionsParamUpdateProposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinaryOptionsParamUpdateProposals = append(m.BinaryOptionsParamUpdateProposals, &BinaryOptionsMarketParamUpdateProposal{})
			if err := m.BinaryOptionsParamUpdateProposals[len(m.BinaryOptionsParamUpdateProposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomDecimalsUpdateProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomDecimalsUpdateProposal == nil {
				m.DenomDecimalsUpdateProposal = &UpdateDenomDecimalsProposal{}
			}
			if err := m.DenomDecimalsUpdateProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerpetualMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerpetualMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerpetualMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOptionsMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOptionsMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOptionsMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpiryFuturesMarketLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpiryFuturesMarketLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpiryFuturesMarketLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeMarketParamUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarketParamUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarketParamUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.InitialMarginRatio = &v
			if err := m.InitialMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MaintenanceMarginRatio = &v
			if err := m.MaintenanceMarginRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerFeeShareRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RelayerFeeShareRate = &v
			if err := m.RelayerFeeShareRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MinPriceTickSize = &v
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MinQuantityTickSize = &v
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyInterestRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.HourlyInterestRate = &v
			if err := m.HourlyInterestRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyFundingRateCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.HourlyFundingRateCap = &v
			if err := m.HourlyFundingRateCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleParams == nil {
				m.OracleParams = &OracleParams{}
			}
			if err := m.OracleParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketForcedSettlementProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketForcedSettlementProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketForcedSettlementProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.SettlementPrice = &v
			if err := m.SettlementPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDenomDecimalsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDenomDecimalsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDenomDecimalsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomDecimals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomDecimals = append(m.DenomDecimals, &DenomDecimals{})
			if err := m.DenomDecimals[len(m.DenomDecimals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomDecimals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomDecimals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomDecimals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryOptionsMarketParamUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryOptionsMarketParamUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryOptionsMarketParamUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MakerFeeRate = &v
			if err := m.MakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.TakerFeeRate = &v
			if err := m.TakerFeeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerFeeShareRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RelayerFeeShareRate = &v
			if err := m.RelayerFeeShareRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MinPriceTickSize = &v
			if err := m.MinPriceTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantityTickSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MinQuantityTickSize = &v
			if err := m.MinQuantityTickSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.SettlementPrice = &v
			if err := m.SettlementPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleParams == nil {
				m.OracleParams = &ProviderOracleParams{}
			}
			if err := m.OracleParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderOracleParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderOracleParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderOracleParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScaleFactor", wireType)
			}
			m.OracleScaleFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScaleFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= types1.OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingRewardCampaignLaunchProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingRewardCampaignLaunchProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingRewardCampaignLaunchProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CampaignInfo == nil {
				m.CampaignInfo = &TradingRewardCampaignInfo{}
			}
			if err := m.CampaignInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignRewardPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignRewardPools = append(m.CampaignRewardPools, &CampaignRewardPool{})
			if err := m.CampaignRewardPools[len(m.CampaignRewardPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingRewardCampaignUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingRewardCampaignUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingRewardCampaignUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CampaignInfo == nil {
				m.CampaignInfo = &TradingRewardCampaignInfo{}
			}
			if err := m.CampaignInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignRewardPoolsAdditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignRewardPoolsAdditions = append(m.CampaignRewardPoolsAdditions, &CampaignRewardPool{})
			if err := m.CampaignRewardPoolsAdditions[len(m.CampaignRewardPoolsAdditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignRewardPoolsUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampaignRewardPoolsUpdates = append(m.CampaignRewardPoolsUpdates, &CampaignRewardPool{})
			if err := m.CampaignRewardPoolsUpdates[len(m.CampaignRewardPoolsUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardPointUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardPointUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardPointUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewPoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingRewardPendingPointsUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingRewardPendingPointsUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingRewardPendingPointsUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPoolTimestamp", wireType)
			}
			m.PendingPoolTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingPoolTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPointUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardPointUpdates = append(m.RewardPointUpdates, &RewardPointUpdate{})
			if err := m.RewardPointUpdates[len(m.RewardPointUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeDiscountProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeDiscountProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeDiscountProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &FeeDiscountSchedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCommunityPoolSpendProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCommunityPoolSpendProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCommunityPoolSpendProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposals = append(m.Proposals, &types2.CommunityPoolSpendProposal{})
			if err := m.Proposals[len(m.Proposals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRewardsOptOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRewardsOptOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRewardsOptOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRewardsOptOutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRewardsOptOutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRewardsOptOutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAdminUpdateBinaryOptionsMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.SettlementPrice = &v
			if err := m.SettlementPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			m.ExpirationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementTimestamp", wireType)
			}
			m.SettlementTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MarketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAdminUpdateBinaryOptionsMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAdminUpdateBinaryOptionsMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicMarketOrderFeeMultiplierScheduleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicMarketOrderFeeMultiplierScheduleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicMarketOrderFeeMultiplierScheduleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketFeeMultipliers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketFeeMultipliers = append(m.MarketFeeMultipliers, &MarketFeeMultiplier{})
			if err := m.MarketFeeMultipliers[len(m.MarketFeeMultipliers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
