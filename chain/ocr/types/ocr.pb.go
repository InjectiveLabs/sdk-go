// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/ocr/v1beta1/ocr.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Params struct {
	// Native denom for LINK coin in the bank keeper
	LinkDenom string `protobuf:"bytes,1,opt,name=link_denom,json=linkDenom,proto3" json:"link_denom,omitempty"`
	// The block number interval at which payouts are made
	PayoutBlockInterval uint64 `protobuf:"varint,2,opt,name=payout_block_interval,json=payoutBlockInterval,proto3" json:"payout_block_interval,omitempty"`
	// The admin for the OCR module
	ModuleAdmin string `protobuf:"bytes,3,opt,name=module_admin,json=moduleAdmin,proto3" json:"module_admin,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetLinkDenom() string {
	if m != nil {
		return m.LinkDenom
	}
	return ""
}

func (m *Params) GetPayoutBlockInterval() uint64 {
	if m != nil {
		return m.PayoutBlockInterval
	}
	return 0
}

func (m *Params) GetModuleAdmin() string {
	if m != nil {
		return m.ModuleAdmin
	}
	return ""
}

type FeedConfig struct {
	// signers ith element is address ith oracle uses to sign a report
	Signers []string `protobuf:"bytes,1,rep,name=signers,proto3" json:"signers,omitempty"`
	// transmitters ith element is address ith oracle uses to transmit a report
	// via the transmit method
	Transmitters []string `protobuf:"bytes,2,rep,name=transmitters,proto3" json:"transmitters,omitempty"`
	// f maximum number of faulty/dishonest oracles the protocol can tolerate
	// while still working correctly
	F uint32 `protobuf:"varint,3,opt,name=f,proto3" json:"f,omitempty"`
	// onchain_config serialized data with reporting plugin params on chain.
	OnchainConfig []byte `protobuf:"bytes,4,opt,name=onchain_config,json=onchainConfig,proto3" json:"onchain_config,omitempty"`
	// offchain_config_version version of the serialization format used for
	// "offchain_config" parameter
	OffchainConfigVersion uint64 `protobuf:"varint,5,opt,name=offchain_config_version,json=offchainConfigVersion,proto3" json:"offchain_config_version,omitempty"`
	// offchain_config serialized data used by oracles to configure their offchain
	// operation
	OffchainConfig []byte `protobuf:"bytes,6,opt,name=offchain_config,json=offchainConfig,proto3" json:"offchain_config,omitempty"`
	// feed-specific params for the Cosmos module.
	ModuleParams *ModuleParams `protobuf:"bytes,7,opt,name=module_params,json=moduleParams,proto3" json:"module_params,omitempty"`
}

func (m *FeedConfig) Reset()         { *m = FeedConfig{} }
func (m *FeedConfig) String() string { return proto.CompactTextString(m) }
func (*FeedConfig) ProtoMessage()    {}
func (*FeedConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{1}
}
func (m *FeedConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedConfig.Merge(m, src)
}
func (m *FeedConfig) XXX_Size() int {
	return m.Size()
}
func (m *FeedConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FeedConfig proto.InternalMessageInfo

func (m *FeedConfig) GetSigners() []string {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *FeedConfig) GetTransmitters() []string {
	if m != nil {
		return m.Transmitters
	}
	return nil
}

func (m *FeedConfig) GetF() uint32 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *FeedConfig) GetOnchainConfig() []byte {
	if m != nil {
		return m.OnchainConfig
	}
	return nil
}

func (m *FeedConfig) GetOffchainConfigVersion() uint64 {
	if m != nil {
		return m.OffchainConfigVersion
	}
	return 0
}

func (m *FeedConfig) GetOffchainConfig() []byte {
	if m != nil {
		return m.OffchainConfig
	}
	return nil
}

func (m *FeedConfig) GetModuleParams() *ModuleParams {
	if m != nil {
		return m.ModuleParams
	}
	return nil
}

type FeedConfigInfo struct {
	LatestConfigDigest []byte `protobuf:"bytes,1,opt,name=latest_config_digest,json=latestConfigDigest,proto3" json:"latest_config_digest,omitempty"`
	F                  uint32 `protobuf:"varint,2,opt,name=f,proto3" json:"f,omitempty"`
	N                  uint32 `protobuf:"varint,3,opt,name=n,proto3" json:"n,omitempty"`
	// config_count ordinal number of this config setting among all config
	// settings
	ConfigCount             uint64 `protobuf:"varint,4,opt,name=config_count,json=configCount,proto3" json:"config_count,omitempty"`
	LatestConfigBlockNumber int64  `protobuf:"varint,5,opt,name=latest_config_block_number,json=latestConfigBlockNumber,proto3" json:"latest_config_block_number,omitempty"`
}

func (m *FeedConfigInfo) Reset()         { *m = FeedConfigInfo{} }
func (m *FeedConfigInfo) String() string { return proto.CompactTextString(m) }
func (*FeedConfigInfo) ProtoMessage()    {}
func (*FeedConfigInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{2}
}
func (m *FeedConfigInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedConfigInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedConfigInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedConfigInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedConfigInfo.Merge(m, src)
}
func (m *FeedConfigInfo) XXX_Size() int {
	return m.Size()
}
func (m *FeedConfigInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedConfigInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FeedConfigInfo proto.InternalMessageInfo

func (m *FeedConfigInfo) GetLatestConfigDigest() []byte {
	if m != nil {
		return m.LatestConfigDigest
	}
	return nil
}

func (m *FeedConfigInfo) GetF() uint32 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *FeedConfigInfo) GetN() uint32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *FeedConfigInfo) GetConfigCount() uint64 {
	if m != nil {
		return m.ConfigCount
	}
	return 0
}

func (m *FeedConfigInfo) GetLatestConfigBlockNumber() int64 {
	if m != nil {
		return m.LatestConfigBlockNumber
	}
	return 0
}

type ModuleParams struct {
	// feed_id is an unique ID for the target of this config
	FeedId string `protobuf:"bytes,1,opt,name=feed_id,json=feedId,proto3" json:"feed_id,omitempty"`
	// lowest answer the median of a report is allowed to be
	MinAnswer github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=min_answer,json=minAnswer,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_answer"`
	// highest answer the median of a report is allowed to be
	MaxAnswer github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=max_answer,json=maxAnswer,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_answer"`
	// Fixed LINK reward for each observer
	LinkPerObservation github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=link_per_observation,json=linkPerObservation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"link_per_observation"`
	// Fixed LINK reward for transmitter
	LinkPerTransmission github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,5,opt,name=link_per_transmission,json=linkPerTransmission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"link_per_transmission"`
	// Native denom for LINK coin in the bank keeper
	LinkDenom string `protobuf:"bytes,6,opt,name=link_denom,json=linkDenom,proto3" json:"link_denom,omitempty"`
	// Enables unique reports
	UniqueReports bool `protobuf:"varint,7,opt,name=unique_reports,json=uniqueReports,proto3" json:"unique_reports,omitempty"`
	// short human-readable description of observable this feed's answers pertain
	// to
	Description string `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	// feed administrator
	FeedAdmin string `protobuf:"bytes,9,opt,name=feed_admin,json=feedAdmin,proto3" json:"feed_admin,omitempty"`
	// feed billing administrator
	BillingAdmin string `protobuf:"bytes,10,opt,name=billing_admin,json=billingAdmin,proto3" json:"billing_admin,omitempty"`
}

func (m *ModuleParams) Reset()         { *m = ModuleParams{} }
func (m *ModuleParams) String() string { return proto.CompactTextString(m) }
func (*ModuleParams) ProtoMessage()    {}
func (*ModuleParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{3}
}
func (m *ModuleParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleParams.Merge(m, src)
}
func (m *ModuleParams) XXX_Size() int {
	return m.Size()
}
func (m *ModuleParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleParams.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleParams proto.InternalMessageInfo

func (m *ModuleParams) GetFeedId() string {
	if m != nil {
		return m.FeedId
	}
	return ""
}

func (m *ModuleParams) GetLinkDenom() string {
	if m != nil {
		return m.LinkDenom
	}
	return ""
}

func (m *ModuleParams) GetUniqueReports() bool {
	if m != nil {
		return m.UniqueReports
	}
	return false
}

func (m *ModuleParams) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ModuleParams) GetFeedAdmin() string {
	if m != nil {
		return m.FeedAdmin
	}
	return ""
}

func (m *ModuleParams) GetBillingAdmin() string {
	if m != nil {
		return m.BillingAdmin
	}
	return ""
}

type ContractConfig struct {
	// config_count ordinal number of this config setting among all config
	// settings
	ConfigCount uint64 `protobuf:"varint,1,opt,name=config_count,json=configCount,proto3" json:"config_count,omitempty"`
	// signers ith element is address ith oracle uses to sign a report
	Signers []string `protobuf:"bytes,2,rep,name=signers,proto3" json:"signers,omitempty"`
	// transmitters ith element is address ith oracle uses to transmit a report
	// via the transmit method
	Transmitters []string `protobuf:"bytes,3,rep,name=transmitters,proto3" json:"transmitters,omitempty"`
	// f maximum number of faulty/dishonest oracles the protocol can tolerate
	// while still working correctly
	F uint32 `protobuf:"varint,4,opt,name=f,proto3" json:"f,omitempty"`
	// onchain_config serialized data with reporting plugin params on chain.
	OnchainConfig []byte `protobuf:"bytes,5,opt,name=onchain_config,json=onchainConfig,proto3" json:"onchain_config,omitempty"`
	// offchain_config_version version of the serialization format used for
	// "offchain_config" parameter
	OffchainConfigVersion uint64 `protobuf:"varint,6,opt,name=offchain_config_version,json=offchainConfigVersion,proto3" json:"offchain_config_version,omitempty"`
	// offchain_config serialized data used by oracles to configure their offchain
	// operation
	OffchainConfig []byte `protobuf:"bytes,7,opt,name=offchain_config,json=offchainConfig,proto3" json:"offchain_config,omitempty"`
}

func (m *ContractConfig) Reset()         { *m = ContractConfig{} }
func (m *ContractConfig) String() string { return proto.CompactTextString(m) }
func (*ContractConfig) ProtoMessage()    {}
func (*ContractConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{4}
}
func (m *ContractConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractConfig.Merge(m, src)
}
func (m *ContractConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContractConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContractConfig proto.InternalMessageInfo

func (m *ContractConfig) GetConfigCount() uint64 {
	if m != nil {
		return m.ConfigCount
	}
	return 0
}

func (m *ContractConfig) GetSigners() []string {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *ContractConfig) GetTransmitters() []string {
	if m != nil {
		return m.Transmitters
	}
	return nil
}

func (m *ContractConfig) GetF() uint32 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *ContractConfig) GetOnchainConfig() []byte {
	if m != nil {
		return m.OnchainConfig
	}
	return nil
}

func (m *ContractConfig) GetOffchainConfigVersion() uint64 {
	if m != nil {
		return m.OffchainConfigVersion
	}
	return 0
}

func (m *ContractConfig) GetOffchainConfig() []byte {
	if m != nil {
		return m.OffchainConfig
	}
	return nil
}

type SetConfigProposal struct {
	Title       string      `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string      `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Config      *FeedConfig `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *SetConfigProposal) Reset()         { *m = SetConfigProposal{} }
func (m *SetConfigProposal) String() string { return proto.CompactTextString(m) }
func (*SetConfigProposal) ProtoMessage()    {}
func (*SetConfigProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{5}
}
func (m *SetConfigProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetConfigProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetConfigProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetConfigProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetConfigProposal.Merge(m, src)
}
func (m *SetConfigProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetConfigProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetConfigProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetConfigProposal proto.InternalMessageInfo

type FeedProperties struct {
	// feed_id is an unique ID for the target of this config
	FeedId string `protobuf:"bytes,1,opt,name=feed_id,json=feedId,proto3" json:"feed_id,omitempty"`
	// f maximum number of faulty/dishonest oracles the protocol can tolerate
	// while still working correctly
	F uint32 `protobuf:"varint,2,opt,name=f,proto3" json:"f,omitempty"`
	// onchain_config serialized data with reporting plugin params on chain.
	OnchainConfig []byte `protobuf:"bytes,3,opt,name=onchain_config,json=onchainConfig,proto3" json:"onchain_config,omitempty"`
	// offchain_config_version version of the serialization format used for
	// "offchain_config" parameter
	OffchainConfigVersion uint64 `protobuf:"varint,4,opt,name=offchain_config_version,json=offchainConfigVersion,proto3" json:"offchain_config_version,omitempty"`
	// offchain_config serialized data used by oracles to configure their offchain
	// operation
	OffchainConfig []byte `protobuf:"bytes,5,opt,name=offchain_config,json=offchainConfig,proto3" json:"offchain_config,omitempty"`
	// lowest answer the median of a report is allowed to be
	MinAnswer github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=min_answer,json=minAnswer,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_answer"`
	// highest answer the median of a report is allowed to be
	MaxAnswer github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=max_answer,json=maxAnswer,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_answer"`
	// Fixed LINK reward for each observer
	LinkPerObservation github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=link_per_observation,json=linkPerObservation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"link_per_observation"`
	// Fixed LINK reward for transmitter
	LinkPerTransmission github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,9,opt,name=link_per_transmission,json=linkPerTransmission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"link_per_transmission"`
	// Enables unique reports
	UniqueReports bool `protobuf:"varint,10,opt,name=unique_reports,json=uniqueReports,proto3" json:"unique_reports,omitempty"`
	// short human-readable description of observable this feed's answers pertain
	// to
	Description string `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *FeedProperties) Reset()         { *m = FeedProperties{} }
func (m *FeedProperties) String() string { return proto.CompactTextString(m) }
func (*FeedProperties) ProtoMessage()    {}
func (*FeedProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{6}
}
func (m *FeedProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedProperties.Merge(m, src)
}
func (m *FeedProperties) XXX_Size() int {
	return m.Size()
}
func (m *FeedProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedProperties.DiscardUnknown(m)
}

var xxx_messageInfo_FeedProperties proto.InternalMessageInfo

func (m *FeedProperties) GetFeedId() string {
	if m != nil {
		return m.FeedId
	}
	return ""
}

func (m *FeedProperties) GetF() uint32 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *FeedProperties) GetOnchainConfig() []byte {
	if m != nil {
		return m.OnchainConfig
	}
	return nil
}

func (m *FeedProperties) GetOffchainConfigVersion() uint64 {
	if m != nil {
		return m.OffchainConfigVersion
	}
	return 0
}

func (m *FeedProperties) GetOffchainConfig() []byte {
	if m != nil {
		return m.OffchainConfig
	}
	return nil
}

func (m *FeedProperties) GetUniqueReports() bool {
	if m != nil {
		return m.UniqueReports
	}
	return false
}

func (m *FeedProperties) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type SetBatchConfigProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// signers ith element is address ith oracle uses to sign a report
	Signers []string `protobuf:"bytes,3,rep,name=signers,proto3" json:"signers,omitempty"`
	// transmitters ith element is address ith oracle uses to transmit a report
	// via the transmit method
	Transmitters []string `protobuf:"bytes,4,rep,name=transmitters,proto3" json:"transmitters,omitempty"`
	// Native denom for LINK coin in the bank keeper
	LinkDenom string `protobuf:"bytes,5,opt,name=link_denom,json=linkDenom,proto3" json:"link_denom,omitempty"`
	// feed properties
	FeedProperties []*FeedProperties `protobuf:"bytes,6,rep,name=feed_properties,json=feedProperties,proto3" json:"feed_properties,omitempty"`
}

func (m *SetBatchConfigProposal) Reset()         { *m = SetBatchConfigProposal{} }
func (m *SetBatchConfigProposal) String() string { return proto.CompactTextString(m) }
func (*SetBatchConfigProposal) ProtoMessage()    {}
func (*SetBatchConfigProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{7}
}
func (m *SetBatchConfigProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBatchConfigProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBatchConfigProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetBatchConfigProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBatchConfigProposal.Merge(m, src)
}
func (m *SetBatchConfigProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetBatchConfigProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBatchConfigProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetBatchConfigProposal proto.InternalMessageInfo

type OracleObservationsCounts struct {
	Counts []uint32 `protobuf:"varint,1,rep,packed,name=counts,proto3" json:"counts,omitempty"`
}

func (m *OracleObservationsCounts) Reset()         { *m = OracleObservationsCounts{} }
func (m *OracleObservationsCounts) String() string { return proto.CompactTextString(m) }
func (*OracleObservationsCounts) ProtoMessage()    {}
func (*OracleObservationsCounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{8}
}
func (m *OracleObservationsCounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleObservationsCounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleObservationsCounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleObservationsCounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleObservationsCounts.Merge(m, src)
}
func (m *OracleObservationsCounts) XXX_Size() int {
	return m.Size()
}
func (m *OracleObservationsCounts) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleObservationsCounts.DiscardUnknown(m)
}

var xxx_messageInfo_OracleObservationsCounts proto.InternalMessageInfo

func (m *OracleObservationsCounts) GetCounts() []uint32 {
	if m != nil {
		return m.Counts
	}
	return nil
}

// LINK-INJ-denominated reimbursements for gas used by transmitters.
type GasReimbursements struct {
	Reimbursements []*types.Coin `protobuf:"bytes,1,rep,name=reimbursements,proto3" json:"reimbursements,omitempty"`
}

func (m *GasReimbursements) Reset()         { *m = GasReimbursements{} }
func (m *GasReimbursements) String() string { return proto.CompactTextString(m) }
func (*GasReimbursements) ProtoMessage()    {}
func (*GasReimbursements) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{9}
}
func (m *GasReimbursements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasReimbursements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasReimbursements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasReimbursements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasReimbursements.Merge(m, src)
}
func (m *GasReimbursements) XXX_Size() int {
	return m.Size()
}
func (m *GasReimbursements) XXX_DiscardUnknown() {
	xxx_messageInfo_GasReimbursements.DiscardUnknown(m)
}

var xxx_messageInfo_GasReimbursements proto.InternalMessageInfo

func (m *GasReimbursements) GetReimbursements() []*types.Coin {
	if m != nil {
		return m.Reimbursements
	}
	return nil
}

type Payee struct {
	TransmitterAddr string `protobuf:"bytes,1,opt,name=transmitter_addr,json=transmitterAddr,proto3" json:"transmitter_addr,omitempty"`
	PaymentAddr     string `protobuf:"bytes,2,opt,name=payment_addr,json=paymentAddr,proto3" json:"payment_addr,omitempty"`
}

func (m *Payee) Reset()         { *m = Payee{} }
func (m *Payee) String() string { return proto.CompactTextString(m) }
func (*Payee) ProtoMessage()    {}
func (*Payee) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{10}
}
func (m *Payee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payee.Merge(m, src)
}
func (m *Payee) XXX_Size() int {
	return m.Size()
}
func (m *Payee) XXX_DiscardUnknown() {
	xxx_messageInfo_Payee.DiscardUnknown(m)
}

var xxx_messageInfo_Payee proto.InternalMessageInfo

func (m *Payee) GetTransmitterAddr() string {
	if m != nil {
		return m.TransmitterAddr
	}
	return ""
}

func (m *Payee) GetPaymentAddr() string {
	if m != nil {
		return m.PaymentAddr
	}
	return ""
}

// Transmission records the median answer from the transmit transaction at
// time timestamp
type Transmission struct {
	Answer                github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=answer,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"answer"`
	ObservationsTimestamp int64                                  `protobuf:"varint,2,opt,name=observations_timestamp,json=observationsTimestamp,proto3" json:"observations_timestamp,omitempty"`
	TransmissionTimestamp int64                                  `protobuf:"varint,3,opt,name=transmission_timestamp,json=transmissionTimestamp,proto3" json:"transmission_timestamp,omitempty"`
}

func (m *Transmission) Reset()         { *m = Transmission{} }
func (m *Transmission) String() string { return proto.CompactTextString(m) }
func (*Transmission) ProtoMessage()    {}
func (*Transmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{11}
}
func (m *Transmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transmission.Merge(m, src)
}
func (m *Transmission) XXX_Size() int {
	return m.Size()
}
func (m *Transmission) XXX_DiscardUnknown() {
	xxx_messageInfo_Transmission.DiscardUnknown(m)
}

var xxx_messageInfo_Transmission proto.InternalMessageInfo

func (m *Transmission) GetObservationsTimestamp() int64 {
	if m != nil {
		return m.ObservationsTimestamp
	}
	return 0
}

func (m *Transmission) GetTransmissionTimestamp() int64 {
	if m != nil {
		return m.TransmissionTimestamp
	}
	return 0
}

type EpochAndRound struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Round uint64 `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *EpochAndRound) Reset()         { *m = EpochAndRound{} }
func (m *EpochAndRound) String() string { return proto.CompactTextString(m) }
func (*EpochAndRound) ProtoMessage()    {}
func (*EpochAndRound) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{12}
}
func (m *EpochAndRound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochAndRound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochAndRound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochAndRound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochAndRound.Merge(m, src)
}
func (m *EpochAndRound) XXX_Size() int {
	return m.Size()
}
func (m *EpochAndRound) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochAndRound.DiscardUnknown(m)
}

var xxx_messageInfo_EpochAndRound proto.InternalMessageInfo

func (m *EpochAndRound) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *EpochAndRound) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type Report struct {
	ObservationsTimestamp int64                                    `protobuf:"varint,1,opt,name=observations_timestamp,json=observationsTimestamp,proto3" json:"observations_timestamp,omitempty"`
	Observers             []byte                                   `protobuf:"bytes,2,opt,name=observers,proto3" json:"observers,omitempty"`
	Observations          []github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,rep,name=observations,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"observations"`
}

func (m *Report) Reset()         { *m = Report{} }
func (m *Report) String() string { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()    {}
func (*Report) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{13}
}
func (m *Report) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Report) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Report.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Report) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Report.Merge(m, src)
}
func (m *Report) XXX_Size() int {
	return m.Size()
}
func (m *Report) XXX_DiscardUnknown() {
	xxx_messageInfo_Report.DiscardUnknown(m)
}

var xxx_messageInfo_Report proto.InternalMessageInfo

func (m *Report) GetObservationsTimestamp() int64 {
	if m != nil {
		return m.ObservationsTimestamp
	}
	return 0
}

func (m *Report) GetObservers() []byte {
	if m != nil {
		return m.Observers
	}
	return nil
}

type ReportToSign struct {
	ConfigDigest []byte `protobuf:"bytes,1,opt,name=config_digest,json=configDigest,proto3" json:"config_digest,omitempty"`
	Epoch        uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Round        uint64 `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	ExtraHash    []byte `protobuf:"bytes,4,opt,name=extra_hash,json=extraHash,proto3" json:"extra_hash,omitempty"`
	// Opaque report
	Report []byte `protobuf:"bytes,5,opt,name=report,proto3" json:"report,omitempty"`
}

func (m *ReportToSign) Reset()         { *m = ReportToSign{} }
func (m *ReportToSign) String() string { return proto.CompactTextString(m) }
func (*ReportToSign) ProtoMessage()    {}
func (*ReportToSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{14}
}
func (m *ReportToSign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportToSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportToSign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportToSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportToSign.Merge(m, src)
}
func (m *ReportToSign) XXX_Size() int {
	return m.Size()
}
func (m *ReportToSign) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportToSign.DiscardUnknown(m)
}

var xxx_messageInfo_ReportToSign proto.InternalMessageInfo

func (m *ReportToSign) GetConfigDigest() []byte {
	if m != nil {
		return m.ConfigDigest
	}
	return nil
}

func (m *ReportToSign) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ReportToSign) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *ReportToSign) GetExtraHash() []byte {
	if m != nil {
		return m.ExtraHash
	}
	return nil
}

func (m *ReportToSign) GetReport() []byte {
	if m != nil {
		return m.Report
	}
	return nil
}

type EventOraclePaid struct {
	TransmitterAddr string     `protobuf:"bytes,1,opt,name=transmitter_addr,json=transmitterAddr,proto3" json:"transmitter_addr,omitempty"`
	PayeeAddr       string     `protobuf:"bytes,2,opt,name=payee_addr,json=payeeAddr,proto3" json:"payee_addr,omitempty"`
	Amount          types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
}

func (m *EventOraclePaid) Reset()         { *m = EventOraclePaid{} }
func (m *EventOraclePaid) String() string { return proto.CompactTextString(m) }
func (*EventOraclePaid) ProtoMessage()    {}
func (*EventOraclePaid) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{15}
}
func (m *EventOraclePaid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOraclePaid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOraclePaid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOraclePaid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOraclePaid.Merge(m, src)
}
func (m *EventOraclePaid) XXX_Size() int {
	return m.Size()
}
func (m *EventOraclePaid) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOraclePaid.DiscardUnknown(m)
}

var xxx_messageInfo_EventOraclePaid proto.InternalMessageInfo

func (m *EventOraclePaid) GetTransmitterAddr() string {
	if m != nil {
		return m.TransmitterAddr
	}
	return ""
}

func (m *EventOraclePaid) GetPayeeAddr() string {
	if m != nil {
		return m.PayeeAddr
	}
	return ""
}

func (m *EventOraclePaid) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

type EventAnswerUpdated struct {
	Current   github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=current,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"current"`
	RoundId   github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=round_id,json=roundId,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"round_id"`
	UpdatedAt time.Time                              `protobuf:"bytes,3,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
}

func (m *EventAnswerUpdated) Reset()         { *m = EventAnswerUpdated{} }
func (m *EventAnswerUpdated) String() string { return proto.CompactTextString(m) }
func (*EventAnswerUpdated) ProtoMessage()    {}
func (*EventAnswerUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{16}
}
func (m *EventAnswerUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAnswerUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAnswerUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAnswerUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAnswerUpdated.Merge(m, src)
}
func (m *EventAnswerUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventAnswerUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAnswerUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventAnswerUpdated proto.InternalMessageInfo

func (m *EventAnswerUpdated) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

type EventNewRound struct {
	RoundId github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=round_id,json=roundId,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"round_id"`
	// address of starter
	StartedBy string    `protobuf:"bytes,2,opt,name=started_by,json=startedBy,proto3" json:"started_by,omitempty"`
	StartedAt time.Time `protobuf:"bytes,3,opt,name=started_at,json=startedAt,proto3,stdtime" json:"started_at"`
}

func (m *EventNewRound) Reset()         { *m = EventNewRound{} }
func (m *EventNewRound) String() string { return proto.CompactTextString(m) }
func (*EventNewRound) ProtoMessage()    {}
func (*EventNewRound) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{17}
}
func (m *EventNewRound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNewRound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNewRound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNewRound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNewRound.Merge(m, src)
}
func (m *EventNewRound) XXX_Size() int {
	return m.Size()
}
func (m *EventNewRound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNewRound.DiscardUnknown(m)
}

var xxx_messageInfo_EventNewRound proto.InternalMessageInfo

func (m *EventNewRound) GetStartedBy() string {
	if m != nil {
		return m.StartedBy
	}
	return ""
}

func (m *EventNewRound) GetStartedAt() time.Time {
	if m != nil {
		return m.StartedAt
	}
	return time.Time{}
}

type EventTransmitted struct {
	ConfigDigest []byte `protobuf:"bytes,1,opt,name=config_digest,json=configDigest,proto3" json:"config_digest,omitempty"`
	Epoch        uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *EventTransmitted) Reset()         { *m = EventTransmitted{} }
func (m *EventTransmitted) String() string { return proto.CompactTextString(m) }
func (*EventTransmitted) ProtoMessage()    {}
func (*EventTransmitted) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{18}
}
func (m *EventTransmitted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTransmitted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTransmitted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTransmitted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTransmitted.Merge(m, src)
}
func (m *EventTransmitted) XXX_Size() int {
	return m.Size()
}
func (m *EventTransmitted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTransmitted.DiscardUnknown(m)
}

var xxx_messageInfo_EventTransmitted proto.InternalMessageInfo

func (m *EventTransmitted) GetConfigDigest() []byte {
	if m != nil {
		return m.ConfigDigest
	}
	return nil
}

func (m *EventTransmitted) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type EventNewTransmission struct {
	FeedId                string                                   `protobuf:"bytes,1,opt,name=feed_id,json=feedId,proto3" json:"feed_id,omitempty"`
	AggregatorRoundId     uint32                                   `protobuf:"varint,2,opt,name=aggregator_round_id,json=aggregatorRoundId,proto3" json:"aggregator_round_id,omitempty"`
	Answer                github_com_cosmos_cosmos_sdk_types.Dec   `protobuf:"bytes,3,opt,name=answer,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"answer"`
	Transmitter           string                                   `protobuf:"bytes,4,opt,name=transmitter,proto3" json:"transmitter,omitempty"`
	ObservationsTimestamp int64                                    `protobuf:"varint,5,opt,name=observations_timestamp,json=observationsTimestamp,proto3" json:"observations_timestamp,omitempty"`
	Observations          []github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,rep,name=observations,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"observations"`
	Observers             []byte                                   `protobuf:"bytes,7,opt,name=observers,proto3" json:"observers,omitempty"`
	ConfigDigest          []byte                                   `protobuf:"bytes,8,opt,name=config_digest,json=configDigest,proto3" json:"config_digest,omitempty"`
	EpochAndRound         *EpochAndRound                           `protobuf:"bytes,9,opt,name=epoch_and_round,json=epochAndRound,proto3" json:"epoch_and_round,omitempty"`
}

func (m *EventNewTransmission) Reset()         { *m = EventNewTransmission{} }
func (m *EventNewTransmission) String() string { return proto.CompactTextString(m) }
func (*EventNewTransmission) ProtoMessage()    {}
func (*EventNewTransmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{19}
}
func (m *EventNewTransmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNewTransmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNewTransmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNewTransmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNewTransmission.Merge(m, src)
}
func (m *EventNewTransmission) XXX_Size() int {
	return m.Size()
}
func (m *EventNewTransmission) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNewTransmission.DiscardUnknown(m)
}

var xxx_messageInfo_EventNewTransmission proto.InternalMessageInfo

func (m *EventNewTransmission) GetFeedId() string {
	if m != nil {
		return m.FeedId
	}
	return ""
}

func (m *EventNewTransmission) GetAggregatorRoundId() uint32 {
	if m != nil {
		return m.AggregatorRoundId
	}
	return 0
}

func (m *EventNewTransmission) GetTransmitter() string {
	if m != nil {
		return m.Transmitter
	}
	return ""
}

func (m *EventNewTransmission) GetObservationsTimestamp() int64 {
	if m != nil {
		return m.ObservationsTimestamp
	}
	return 0
}

func (m *EventNewTransmission) GetObservers() []byte {
	if m != nil {
		return m.Observers
	}
	return nil
}

func (m *EventNewTransmission) GetConfigDigest() []byte {
	if m != nil {
		return m.ConfigDigest
	}
	return nil
}

func (m *EventNewTransmission) GetEpochAndRound() *EpochAndRound {
	if m != nil {
		return m.EpochAndRound
	}
	return nil
}

type EventConfigSet struct {
	// hash of the config
	ConfigDigest []byte `protobuf:"bytes,1,opt,name=config_digest,json=configDigest,proto3" json:"config_digest,omitempty"`
	// previous_config_block_number block in which the previous config was set, to
	// simplify historic analysis
	PreviousConfigBlockNumber int64           `protobuf:"varint,2,opt,name=previous_config_block_number,json=previousConfigBlockNumber,proto3" json:"previous_config_block_number,omitempty"`
	Config                    *FeedConfig     `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	ConfigInfo                *FeedConfigInfo `protobuf:"bytes,4,opt,name=config_info,json=configInfo,proto3" json:"config_info,omitempty"`
}

func (m *EventConfigSet) Reset()         { *m = EventConfigSet{} }
func (m *EventConfigSet) String() string { return proto.CompactTextString(m) }
func (*EventConfigSet) ProtoMessage()    {}
func (*EventConfigSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0acb79560f1720fa, []int{20}
}
func (m *EventConfigSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventConfigSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventConfigSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventConfigSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventConfigSet.Merge(m, src)
}
func (m *EventConfigSet) XXX_Size() int {
	return m.Size()
}
func (m *EventConfigSet) XXX_DiscardUnknown() {
	xxx_messageInfo_EventConfigSet.DiscardUnknown(m)
}

var xxx_messageInfo_EventConfigSet proto.InternalMessageInfo

func (m *EventConfigSet) GetConfigDigest() []byte {
	if m != nil {
		return m.ConfigDigest
	}
	return nil
}

func (m *EventConfigSet) GetPreviousConfigBlockNumber() int64 {
	if m != nil {
		return m.PreviousConfigBlockNumber
	}
	return 0
}

func (m *EventConfigSet) GetConfig() *FeedConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *EventConfigSet) GetConfigInfo() *FeedConfigInfo {
	if m != nil {
		return m.ConfigInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*Params)(nil), "injective.ocr.v1beta1.Params")
	proto.RegisterType((*FeedConfig)(nil), "injective.ocr.v1beta1.FeedConfig")
	proto.RegisterType((*FeedConfigInfo)(nil), "injective.ocr.v1beta1.FeedConfigInfo")
	proto.RegisterType((*ModuleParams)(nil), "injective.ocr.v1beta1.ModuleParams")
	proto.RegisterType((*ContractConfig)(nil), "injective.ocr.v1beta1.ContractConfig")
	proto.RegisterType((*SetConfigProposal)(nil), "injective.ocr.v1beta1.SetConfigProposal")
	proto.RegisterType((*FeedProperties)(nil), "injective.ocr.v1beta1.FeedProperties")
	proto.RegisterType((*SetBatchConfigProposal)(nil), "injective.ocr.v1beta1.SetBatchConfigProposal")
	proto.RegisterType((*OracleObservationsCounts)(nil), "injective.ocr.v1beta1.OracleObservationsCounts")
	proto.RegisterType((*GasReimbursements)(nil), "injective.ocr.v1beta1.GasReimbursements")
	proto.RegisterType((*Payee)(nil), "injective.ocr.v1beta1.Payee")
	proto.RegisterType((*Transmission)(nil), "injective.ocr.v1beta1.Transmission")
	proto.RegisterType((*EpochAndRound)(nil), "injective.ocr.v1beta1.EpochAndRound")
	proto.RegisterType((*Report)(nil), "injective.ocr.v1beta1.Report")
	proto.RegisterType((*ReportToSign)(nil), "injective.ocr.v1beta1.ReportToSign")
	proto.RegisterType((*EventOraclePaid)(nil), "injective.ocr.v1beta1.EventOraclePaid")
	proto.RegisterType((*EventAnswerUpdated)(nil), "injective.ocr.v1beta1.EventAnswerUpdated")
	proto.RegisterType((*EventNewRound)(nil), "injective.ocr.v1beta1.EventNewRound")
	proto.RegisterType((*EventTransmitted)(nil), "injective.ocr.v1beta1.EventTransmitted")
	proto.RegisterType((*EventNewTransmission)(nil), "injective.ocr.v1beta1.EventNewTransmission")
	proto.RegisterType((*EventConfigSet)(nil), "injective.ocr.v1beta1.EventConfigSet")
}

func init() { proto.RegisterFile("injective/ocr/v1beta1/ocr.proto", fileDescriptor_0acb79560f1720fa) }

var fileDescriptor_0acb79560f1720fa = []byte{
	// 1599 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x3d, 0x6c, 0x1b, 0x55,
	0x1c, 0xcf, 0xd9, 0x8e, 0x13, 0xff, 0xfd, 0x91, 0xf6, 0x9a, 0xb4, 0x6e, 0xd4, 0xc6, 0xee, 0x95,
	0x96, 0x30, 0xd4, 0xa6, 0x41, 0x80, 0x68, 0x07, 0x94, 0xa4, 0x2d, 0xb5, 0xd4, 0x8f, 0xe8, 0x92,
	0x76, 0x60, 0x39, 0x9e, 0xef, 0x9e, 0x9d, 0xa3, 0xbe, 0xf7, 0x8e, 0x77, 0xcf, 0x69, 0xb3, 0x23,
	0xc1, 0xd8, 0x01, 0x31, 0x77, 0x61, 0x61, 0x40, 0x42, 0x42, 0x62, 0x63, 0x62, 0xa8, 0x98, 0x3a,
	0x22, 0x86, 0x82, 0x5a, 0x21, 0x75, 0x40, 0xec, 0x6c, 0xe8, 0x7d, 0x9c, 0x7d, 0xfe, 0x88, 0x55,
	0x37, 0xed, 0x14, 0xff, 0xbf, 0xdf, 0xfd, 0x3f, 0x7e, 0xef, 0xff, 0x02, 0x15, 0x9f, 0x7c, 0x8e,
	0x5d, 0xee, 0xef, 0xe1, 0x3a, 0x75, 0x59, 0x7d, 0xef, 0x62, 0x13, 0x73, 0x74, 0x51, 0xfc, 0xae,
	0x85, 0x8c, 0x72, 0x6a, 0x2e, 0xf5, 0x14, 0x6a, 0x82, 0xa9, 0x15, 0x96, 0x57, 0x5c, 0x1a, 0x05,
	0x34, 0xaa, 0x37, 0x51, 0x84, 0x7b, 0x56, 0x2e, 0xf5, 0x89, 0x32, 0x5b, 0x3e, 0xa9, 0xe4, 0x8e,
	0xa4, 0xea, 0x8a, 0xd0, 0xa2, 0xc5, 0x36, 0x6d, 0x53, 0xc5, 0x17, 0xbf, 0x34, 0xb7, 0xd2, 0xa6,
	0xb4, 0xdd, 0xc1, 0x75, 0x49, 0x35, 0xbb, 0xad, 0x3a, 0xf7, 0x03, 0x1c, 0x71, 0x14, 0x84, 0x4a,
	0xc1, 0xfa, 0xd2, 0x80, 0xec, 0x16, 0x62, 0x28, 0x88, 0xcc, 0xd3, 0x00, 0x1d, 0x9f, 0xdc, 0x73,
	0x3c, 0x4c, 0x68, 0x50, 0x36, 0xaa, 0xc6, 0x6a, 0xce, 0xce, 0x09, 0xce, 0x15, 0xc1, 0x30, 0xd7,
	0x60, 0x29, 0x44, 0xfb, 0xb4, 0xcb, 0x9d, 0x66, 0x87, 0xba, 0xf7, 0x1c, 0x9f, 0x70, 0xcc, 0xf6,
	0x50, 0xa7, 0x9c, 0xaa, 0x1a, 0xab, 0x19, 0xfb, 0x98, 0x12, 0x6e, 0x08, 0x59, 0x43, 0x8b, 0xcc,
	0x33, 0x50, 0x08, 0xa8, 0xd7, 0xed, 0x60, 0x07, 0x79, 0x81, 0x4f, 0xca, 0x69, 0xe9, 0x34, 0xaf,
	0x78, 0xeb, 0x82, 0x75, 0x29, 0xf3, 0xe2, 0x51, 0xc5, 0xb0, 0xbe, 0x4f, 0x01, 0x5c, 0xc3, 0xd8,
	0xdb, 0xa4, 0xa4, 0xe5, 0xb7, 0xcd, 0x32, 0xcc, 0x45, 0x7e, 0x9b, 0x60, 0x16, 0x95, 0x8d, 0x6a,
	0x7a, 0x35, 0x67, 0xc7, 0xa4, 0x69, 0x41, 0x81, 0x33, 0x44, 0xa2, 0xc0, 0xe7, 0x5c, 0x88, 0x53,
	0x52, 0x3c, 0xc0, 0x33, 0x0b, 0x60, 0xb4, 0x64, 0xa8, 0xa2, 0x6d, 0xb4, 0xcc, 0x73, 0x50, 0xa2,
	0xc4, 0xdd, 0x45, 0x3e, 0x71, 0x5c, 0xe9, 0xbd, 0x9c, 0xa9, 0x1a, 0xab, 0x05, 0xbb, 0xa8, 0xb9,
	0x3a, 0xe4, 0x07, 0x70, 0x82, 0xb6, 0x5a, 0x49, 0x3d, 0x67, 0x0f, 0xb3, 0xc8, 0xa7, 0xa4, 0x3c,
	0x2b, 0x3f, 0x70, 0x29, 0x16, 0x2b, 0x83, 0xbb, 0x4a, 0x68, 0xbe, 0x0d, 0x0b, 0x43, 0x76, 0xe5,
	0xac, 0xf4, 0x5f, 0x1a, 0xd4, 0x37, 0xaf, 0x43, 0x51, 0xe7, 0x22, 0x94, 0xf9, 0x2e, 0xcf, 0x55,
	0x8d, 0xd5, 0xfc, 0xda, 0xd9, 0xda, 0xd8, 0x56, 0xa8, 0xdd, 0x94, 0xba, 0xaa, 0x34, 0xb6, 0xce,
	0xa2, 0xa2, 0xac, 0x5f, 0x0c, 0x28, 0xf5, 0x93, 0xd5, 0x20, 0x2d, 0x6a, 0xbe, 0x0b, 0x8b, 0x1d,
	0xc4, 0x71, 0xc4, 0xe3, 0xb3, 0x7b, 0x7e, 0x1b, 0x47, 0x5c, 0x56, 0xb1, 0x60, 0x9b, 0x4a, 0xa6,
	0xf4, 0xaf, 0x48, 0x89, 0x4a, 0x52, 0x2a, 0x4e, 0x52, 0x01, 0x0c, 0x12, 0xa7, 0x8c, 0x88, 0xb2,
	0x69, 0x37, 0x2e, 0xed, 0x12, 0x2e, 0x13, 0x96, 0xb1, 0xf3, 0x8a, 0xb7, 0x29, 0x58, 0xe6, 0x65,
	0x58, 0x1e, 0x0c, 0xa8, 0x9a, 0x82, 0x74, 0x83, 0x26, 0x66, 0x32, 0x63, 0x69, 0xfb, 0x44, 0x32,
	0xac, 0x6c, 0x8c, 0x5b, 0x52, 0x6c, 0xfd, 0x9c, 0x81, 0x42, 0xf2, 0xfb, 0xcc, 0x13, 0x30, 0xd7,
	0xc2, 0xd8, 0x73, 0x7c, 0x4f, 0xf7, 0x5d, 0x56, 0x90, 0x0d, 0xcf, 0xbc, 0x09, 0x10, 0xf8, 0xc4,
	0x41, 0x24, 0xba, 0x8f, 0x99, 0x3c, 0x6e, 0x6e, 0xa3, 0xf6, 0xf8, 0x69, 0x65, 0xe6, 0x8f, 0xa7,
	0x95, 0xf3, 0x6d, 0x9f, 0xef, 0x76, 0x9b, 0x35, 0x97, 0x06, 0x7a, 0x14, 0xf4, 0x9f, 0x0b, 0x91,
	0x77, 0xaf, 0xce, 0xf7, 0x43, 0x1c, 0xd5, 0xae, 0x60, 0xd7, 0xce, 0x05, 0x3e, 0x59, 0x97, 0x0e,
	0xa4, 0x3b, 0xf4, 0x20, 0x76, 0x97, 0x7e, 0x45, 0x77, 0xe8, 0x81, 0x76, 0xf7, 0x19, 0x2c, 0xca,
	0x89, 0x09, 0x31, 0x73, 0x68, 0x33, 0x12, 0x3d, 0xcf, 0x45, 0xc3, 0x64, 0xa6, 0x76, 0xdc, 0x20,
	0xdc, 0x36, 0x85, 0xaf, 0x2d, 0xcc, 0x6e, 0xf7, 0x3d, 0x99, 0x4d, 0x58, 0xea, 0x45, 0xd0, 0x3d,
	0x1e, 0xf5, 0x7a, 0x72, 0xfa, 0x10, 0xc7, 0x74, 0x88, 0x9d, 0x84, 0xab, 0xa1, 0xb9, 0xcf, 0x0e,
	0xcf, 0xfd, 0x39, 0x28, 0x75, 0x89, 0xff, 0x45, 0x17, 0x3b, 0x0c, 0x87, 0x94, 0x71, 0xd5, 0xb8,
	0xf3, 0x76, 0x51, 0x71, 0x6d, 0xc5, 0x34, 0xab, 0x90, 0xf7, 0x70, 0xe4, 0x32, 0x3f, 0x94, 0x29,
	0x98, 0x57, 0x93, 0x9e, 0x60, 0x89, 0x38, 0xb2, 0xc8, 0x0a, 0x0a, 0x72, 0x2a, 0x8e, 0xe0, 0x48,
	0x20, 0x30, 0xcf, 0x42, 0xb1, 0xe9, 0x77, 0x3a, 0x3e, 0x69, 0x6b, 0x0d, 0x90, 0x1a, 0x05, 0xcd,
	0x94, 0x4a, 0xd6, 0x57, 0x29, 0x28, 0x6d, 0x52, 0xc2, 0x19, 0x72, 0x75, 0x5f, 0x8d, 0x34, 0xab,
	0x31, 0xda, 0xac, 0x09, 0x38, 0x49, 0x4d, 0x86, 0x93, 0xf4, 0x41, 0x70, 0x92, 0x39, 0x18, 0x4e,
	0x66, 0xa7, 0x84, 0x93, 0xec, 0x94, 0x70, 0x32, 0x37, 0x0e, 0x4e, 0xac, 0x1f, 0x0c, 0x38, 0xba,
	0x8d, 0x75, 0x12, 0xb6, 0x18, 0x0d, 0x69, 0x84, 0x3a, 0xe6, 0x22, 0xcc, 0x72, 0x9f, 0x77, 0xb0,
	0x1e, 0x23, 0x45, 0x0c, 0xd7, 0x26, 0x35, 0x5a, 0x9b, 0x8f, 0x20, 0xab, 0xa3, 0xa5, 0x25, 0x2a,
	0x9d, 0x39, 0x00, 0x95, 0xfa, 0xb0, 0x63, 0x6b, 0x83, 0x4b, 0xe7, 0xbf, 0x7e, 0x54, 0x99, 0x79,
	0xf1, 0xa8, 0x32, 0xf3, 0xdb, 0x4f, 0x17, 0x96, 0xf5, 0x95, 0xd4, 0xa6, 0x7b, 0x3d, 0x13, 0x51,
	0x2e, 0x4c, 0xb8, 0xf5, 0x4f, 0x46, 0xa1, 0x96, 0x38, 0x2b, 0x66, 0xdc, 0xc7, 0x13, 0xc6, 0x7e,
	0x10, 0x9c, 0x46, 0x53, 0x9e, 0x9e, 0x32, 0xe5, 0x99, 0x29, 0x53, 0x3e, 0x3b, 0x16, 0xc1, 0x07,
	0xc1, 0x28, 0xfb, 0x7a, 0xc1, 0x68, 0xee, 0x4d, 0x81, 0xd1, 0xfc, 0x9b, 0x07, 0xa3, 0xdc, 0xeb,
	0x03, 0xa3, 0x51, 0xb4, 0x81, 0x97, 0x40, 0x9b, 0xfc, 0x48, 0x47, 0x5b, 0xdf, 0xa5, 0xe0, 0xf8,
	0x36, 0xe6, 0x1b, 0x88, 0xbb, 0xbb, 0xaf, 0x69, 0x48, 0x12, 0x30, 0x92, 0x9e, 0x0c, 0x23, 0x99,
	0x31, 0x30, 0x32, 0x08, 0xb3, 0xb3, 0xc3, 0x30, 0x7b, 0x0b, 0x16, 0xe4, 0x2c, 0x84, 0xbd, 0xf1,
	0x28, 0x67, 0xab, 0xe9, 0xd5, 0xfc, 0xda, 0xb9, 0x09, 0xa3, 0xd8, 0x9f, 0x25, 0xbb, 0xd4, 0x1a,
	0xa0, 0x5f, 0x7a, 0x2c, 0xd7, 0xa0, 0x7c, 0x9b, 0x21, 0xb7, 0x83, 0x13, 0x95, 0x8e, 0x24, 0x6c,
	0x46, 0xe6, 0x71, 0x81, 0x0a, 0xe2, 0x97, 0xdc, 0xc2, 0x8a, 0xb6, 0xa6, 0xac, 0xbb, 0x70, 0xf4,
	0x13, 0x14, 0xd9, 0xd8, 0x0f, 0x9a, 0x5d, 0x16, 0xe1, 0x00, 0x0b, 0xe5, 0x75, 0x28, 0xb1, 0x01,
	0x8e, 0x34, 0xca, 0xaf, 0x9d, 0xac, 0xe9, 0xe8, 0x62, 0xa9, 0x4d, 0x84, 0xf7, 0x89, 0x3d, 0x64,
	0x60, 0xdd, 0x81, 0xd9, 0x2d, 0xb4, 0x8f, 0xb1, 0xf9, 0x0e, 0x1c, 0x49, 0xe4, 0xce, 0x41, 0x9e,
	0xc7, 0x74, 0xb1, 0x16, 0x12, 0xfc, 0x75, 0xcf, 0x63, 0x02, 0xfe, 0x43, 0xb4, 0x2f, 0xec, 0x95,
	0x9a, 0xae, 0x9b, 0xe6, 0x09, 0x15, 0xeb, 0x57, 0x03, 0x0a, 0x03, 0x4d, 0x76, 0x0d, 0xb2, 0x7a,
	0xea, 0x8c, 0x57, 0x9a, 0x3a, 0x6d, 0x6d, 0xbe, 0x0f, 0xc7, 0x13, 0x93, 0x16, 0x39, 0xbd, 0xe5,
	0x5a, 0x9e, 0x22, 0x6d, 0x2f, 0x25, 0xa5, 0x3b, 0xb1, 0x50, 0x98, 0x25, 0xc7, 0x27, 0x61, 0x96,
	0x56, 0x66, 0x49, 0x69, 0xcf, 0xcc, 0xba, 0x0c, 0xc5, 0xab, 0x21, 0x75, 0x77, 0xd7, 0x89, 0x67,
	0xd3, 0x2e, 0xf1, 0x44, 0x1f, 0x63, 0xc1, 0xd0, 0x57, 0x9e, 0x22, 0x04, 0x97, 0x09, 0xb1, 0xde,
	0xcb, 0x15, 0x61, 0xfd, 0x68, 0x40, 0x56, 0x0d, 0xcf, 0x84, 0x53, 0x1b, 0x93, 0x4e, 0x7d, 0x0a,
	0x72, 0x4a, 0xa0, 0xae, 0x51, 0x01, 0x90, 0x7d, 0x86, 0x69, 0x43, 0x21, 0x69, 0xa6, 0x06, 0x64,
	0xea, 0xc4, 0x0e, 0xf8, 0xb0, 0xbe, 0x35, 0xa0, 0xa0, 0xce, 0xbc, 0x43, 0xb7, 0xfd, 0xb6, 0x5c,
	0x11, 0xc6, 0xad, 0xb7, 0xfa, 0xfe, 0xd7, 0x8b, 0x6d, 0x2f, 0x2b, 0xa9, 0xb1, 0x59, 0x49, 0x27,
	0xb2, 0x22, 0x66, 0x12, 0x3f, 0xe0, 0x0c, 0x39, 0xbb, 0x28, 0xda, 0xd5, 0xef, 0x82, 0x9c, 0xe4,
	0x5c, 0x47, 0xd1, 0xae, 0xe8, 0x7f, 0x85, 0x42, 0xfa, 0x42, 0xd0, 0x94, 0xf5, 0x8d, 0x01, 0x0b,
	0x57, 0xf7, 0x30, 0xe1, 0x6a, 0x72, 0xb6, 0x90, 0xef, 0x4d, 0xd3, 0xb2, 0xa7, 0x01, 0x42, 0xd1,
	0xe6, 0xc9, 0x86, 0xcd, 0x49, 0x8e, 0x14, 0x7f, 0x08, 0x59, 0x14, 0xc8, 0x55, 0x46, 0xdd, 0xc5,
	0x07, 0x0f, 0xd0, 0x46, 0x46, 0xe4, 0xd7, 0xd6, 0xea, 0xd6, 0xbf, 0x06, 0x98, 0xf2, 0x58, 0xea,
	0x46, 0xb8, 0x13, 0x7a, 0x88, 0x63, 0xcf, 0xbc, 0x0e, 0x73, 0x6e, 0x97, 0x31, 0xac, 0x77, 0xa3,
	0xe9, 0x81, 0x3a, 0x36, 0x37, 0x1b, 0x30, 0x2f, 0xf3, 0x26, 0x2e, 0xec, 0xd4, 0xab, 0xb9, 0x92,
	0xf6, 0x0d, 0xcf, 0xdc, 0x04, 0xe8, 0xaa, 0xf3, 0x39, 0x28, 0xfe, 0xd0, 0xe5, 0x9a, 0x7a, 0xad,
	0xd6, 0xe2, 0xd7, 0x6a, 0xad, 0xd7, 0x7d, 0x1b, 0xf3, 0x22, 0xd0, 0xc3, 0x3f, 0x2b, 0x86, 0x9d,
	0xd3, 0x76, 0xeb, 0x5c, 0x3c, 0x84, 0x8a, 0xf2, 0x83, 0x6f, 0xe1, 0xfb, 0x6a, 0x24, 0x92, 0x27,
	0x34, 0x0e, 0x77, 0xc2, 0xd3, 0x00, 0x11, 0x47, 0x4c, 0x9c, 0xb0, 0xb9, 0x1f, 0x57, 0x49, 0x73,
	0x36, 0xf6, 0xc5, 0x07, 0xc4, 0xe2, 0x69, 0x3f, 0x40, 0xdb, 0xad, 0x73, 0xeb, 0x26, 0x1c, 0x91,
	0xe7, 0xdf, 0xe9, 0x75, 0x88, 0x77, 0x88, 0x26, 0xb7, 0xfe, 0x4e, 0xc3, 0x62, 0x9c, 0x8f, 0x01,
	0xc0, 0x3b, 0x70, 0xd1, 0xaa, 0xc1, 0x31, 0xd4, 0x6e, 0x33, 0xdc, 0x46, 0x9c, 0x32, 0x67, 0xa0,
	0xb8, 0x45, 0xfb, 0x68, 0x5f, 0x64, 0xeb, 0xa4, 0xf4, 0x91, 0x33, 0x7d, 0x28, 0xe4, 0xac, 0x42,
	0x3e, 0x31, 0x15, 0xea, 0xc1, 0x64, 0x27, 0x59, 0x13, 0x50, 0x6a, 0x76, 0x12, 0x4a, 0x0d, 0xe3,
	0x50, 0xf6, 0xf0, 0x38, 0x34, 0x88, 0x7c, 0x73, 0xc3, 0xc8, 0x37, 0x52, 0xaf, 0xf9, 0x31, 0xf5,
	0xba, 0x01, 0x0b, 0xb2, 0x44, 0x0e, 0x22, 0x9e, 0x4a, 0xb3, 0x5c, 0x9a, 0xf2, 0x6b, 0x6f, 0x1d,
	0x70, 0xbb, 0x0f, 0x20, 0xbd, 0x5d, 0xc4, 0x49, 0xd2, 0xfa, 0xcf, 0x80, 0x92, 0xac, 0xb3, 0x5a,
	0x6c, 0xb6, 0x31, 0x7f, 0xb9, 0xae, 0xf9, 0x18, 0x4e, 0x85, 0x0c, 0xef, 0xf9, 0xb4, 0x1b, 0x8d,
	0x7d, 0xb6, 0xab, 0x5b, 0xeb, 0x64, 0xac, 0x33, 0xf2, 0x70, 0x3f, 0xc4, 0x33, 0xc1, 0xbc, 0x06,
	0xfa, 0x49, 0xe6, 0xf8, 0xa4, 0x45, 0x65, 0xc5, 0x27, 0xef, 0x36, 0xfd, 0xff, 0x6e, 0xd8, 0xe0,
	0xf6, 0x7e, 0x6f, 0xb8, 0x8f, 0x9f, 0xad, 0x18, 0x4f, 0x9e, 0xad, 0x18, 0x7f, 0x3d, 0x5b, 0x31,
	0x1e, 0x3e, 0x5f, 0x99, 0x79, 0xf2, 0x7c, 0x65, 0xe6, 0xf7, 0xe7, 0x2b, 0x33, 0x9f, 0x36, 0x12,
	0xc5, 0x6d, 0xc4, 0x6e, 0x6f, 0xa0, 0x66, 0x54, 0xef, 0x05, 0xb9, 0xe0, 0x52, 0x86, 0x93, 0xa4,
	0xd8, 0xee, 0xeb, 0xea, 0x9f, 0x2b, 0x91, 0xfc, 0x57, 0x9d, 0xec, 0x81, 0x66, 0x56, 0x0e, 0xf0,
	0x7b, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x29, 0x4b, 0xf3, 0x34, 0xc8, 0x13, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LinkDenom != that1.LinkDenom {
		return false
	}
	if this.PayoutBlockInterval != that1.PayoutBlockInterval {
		return false
	}
	if this.ModuleAdmin != that1.ModuleAdmin {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModuleAdmin) > 0 {
		i -= len(m.ModuleAdmin)
		copy(dAtA[i:], m.ModuleAdmin)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.ModuleAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PayoutBlockInterval != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.PayoutBlockInterval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LinkDenom) > 0 {
		i -= len(m.LinkDenom)
		copy(dAtA[i:], m.LinkDenom)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.LinkDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeedConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModuleParams != nil {
		{
			size, err := m.ModuleParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOcr(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OffchainConfig) > 0 {
		i -= len(m.OffchainConfig)
		copy(dAtA[i:], m.OffchainConfig)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.OffchainConfig)))
		i--
		dAtA[i] = 0x32
	}
	if m.OffchainConfigVersion != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.OffchainConfigVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OnchainConfig) > 0 {
		i -= len(m.OnchainConfig)
		copy(dAtA[i:], m.OnchainConfig)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.OnchainConfig)))
		i--
		dAtA[i] = 0x22
	}
	if m.F != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.F))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Transmitters) > 0 {
		for iNdEx := len(m.Transmitters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Transmitters[iNdEx])
			copy(dAtA[i:], m.Transmitters[iNdEx])
			i = encodeVarintOcr(dAtA, i, uint64(len(m.Transmitters[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintOcr(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FeedConfigInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedConfigInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedConfigInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestConfigBlockNumber != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.LatestConfigBlockNumber))
		i--
		dAtA[i] = 0x28
	}
	if m.ConfigCount != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.ConfigCount))
		i--
		dAtA[i] = 0x20
	}
	if m.N != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x18
	}
	if m.F != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.F))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LatestConfigDigest) > 0 {
		i -= len(m.LatestConfigDigest)
		copy(dAtA[i:], m.LatestConfigDigest)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.LatestConfigDigest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModuleParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BillingAdmin) > 0 {
		i -= len(m.BillingAdmin)
		copy(dAtA[i:], m.BillingAdmin)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.BillingAdmin)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FeedAdmin) > 0 {
		i -= len(m.FeedAdmin)
		copy(dAtA[i:], m.FeedAdmin)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.FeedAdmin)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x42
	}
	if m.UniqueReports {
		i--
		if m.UniqueReports {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.LinkDenom) > 0 {
		i -= len(m.LinkDenom)
		copy(dAtA[i:], m.LinkDenom)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.LinkDenom)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.LinkPerTransmission.Size()
		i -= size
		if _, err := m.LinkPerTransmission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.LinkPerObservation.Size()
		i -= size
		if _, err := m.LinkPerObservation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.MaxAnswer.Size()
		i -= size
		if _, err := m.MaxAnswer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MinAnswer.Size()
		i -= size
		if _, err := m.MinAnswer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.FeedId) > 0 {
		i -= len(m.FeedId)
		copy(dAtA[i:], m.FeedId)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.FeedId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OffchainConfig) > 0 {
		i -= len(m.OffchainConfig)
		copy(dAtA[i:], m.OffchainConfig)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.OffchainConfig)))
		i--
		dAtA[i] = 0x3a
	}
	if m.OffchainConfigVersion != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.OffchainConfigVersion))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OnchainConfig) > 0 {
		i -= len(m.OnchainConfig)
		copy(dAtA[i:], m.OnchainConfig)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.OnchainConfig)))
		i--
		dAtA[i] = 0x2a
	}
	if m.F != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.F))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Transmitters) > 0 {
		for iNdEx := len(m.Transmitters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Transmitters[iNdEx])
			copy(dAtA[i:], m.Transmitters[iNdEx])
			i = encodeVarintOcr(dAtA, i, uint64(len(m.Transmitters[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintOcr(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ConfigCount != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.ConfigCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetConfigProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetConfigProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetConfigProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOcr(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeedProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedProperties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedProperties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x5a
	}
	if m.UniqueReports {
		i--
		if m.UniqueReports {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.LinkPerTransmission.Size()
		i -= size
		if _, err := m.LinkPerTransmission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.LinkPerObservation.Size()
		i -= size
		if _, err := m.LinkPerObservation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.MaxAnswer.Size()
		i -= size
		if _, err := m.MaxAnswer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinAnswer.Size()
		i -= size
		if _, err := m.MinAnswer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.OffchainConfig) > 0 {
		i -= len(m.OffchainConfig)
		copy(dAtA[i:], m.OffchainConfig)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.OffchainConfig)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OffchainConfigVersion != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.OffchainConfigVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.OnchainConfig) > 0 {
		i -= len(m.OnchainConfig)
		copy(dAtA[i:], m.OnchainConfig)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.OnchainConfig)))
		i--
		dAtA[i] = 0x1a
	}
	if m.F != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.F))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FeedId) > 0 {
		i -= len(m.FeedId)
		copy(dAtA[i:], m.FeedId)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.FeedId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetBatchConfigProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBatchConfigProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetBatchConfigProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeedProperties) > 0 {
		for iNdEx := len(m.FeedProperties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeedProperties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcr(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LinkDenom) > 0 {
		i -= len(m.LinkDenom)
		copy(dAtA[i:], m.LinkDenom)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.LinkDenom)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Transmitters) > 0 {
		for iNdEx := len(m.Transmitters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Transmitters[iNdEx])
			copy(dAtA[i:], m.Transmitters[iNdEx])
			i = encodeVarintOcr(dAtA, i, uint64(len(m.Transmitters[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintOcr(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleObservationsCounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleObservationsCounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleObservationsCounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Counts) > 0 {
		dAtA4 := make([]byte, len(m.Counts)*10)
		var j3 int
		for _, num := range m.Counts {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintOcr(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GasReimbursements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasReimbursements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasReimbursements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reimbursements) > 0 {
		for iNdEx := len(m.Reimbursements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reimbursements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcr(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Payee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PaymentAddr) > 0 {
		i -= len(m.PaymentAddr)
		copy(dAtA[i:], m.PaymentAddr)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.PaymentAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransmitterAddr) > 0 {
		i -= len(m.TransmitterAddr)
		copy(dAtA[i:], m.TransmitterAddr)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.TransmitterAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransmissionTimestamp != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.TransmissionTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.ObservationsTimestamp != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.ObservationsTimestamp))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Answer.Size()
		i -= size
		if _, err := m.Answer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EpochAndRound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochAndRound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochAndRound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Epoch != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Report) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Observations) > 0 {
		for iNdEx := len(m.Observations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Observations[iNdEx].Size()
				i -= size
				if _, err := m.Observations[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintOcr(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Observers) > 0 {
		i -= len(m.Observers)
		copy(dAtA[i:], m.Observers)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Observers)))
		i--
		dAtA[i] = 0x12
	}
	if m.ObservationsTimestamp != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.ObservationsTimestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportToSign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportToSign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportToSign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Report) > 0 {
		i -= len(m.Report)
		copy(dAtA[i:], m.Report)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Report)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExtraHash) > 0 {
		i -= len(m.ExtraHash)
		copy(dAtA[i:], m.ExtraHash)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.ExtraHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.Round != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ConfigDigest) > 0 {
		i -= len(m.ConfigDigest)
		copy(dAtA[i:], m.ConfigDigest)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.ConfigDigest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOraclePaid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOraclePaid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOraclePaid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PayeeAddr) > 0 {
		i -= len(m.PayeeAddr)
		copy(dAtA[i:], m.PayeeAddr)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.PayeeAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransmitterAddr) > 0 {
		i -= len(m.TransmitterAddr)
		copy(dAtA[i:], m.TransmitterAddr)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.TransmitterAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAnswerUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAnswerUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAnswerUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintOcr(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	{
		size := m.RoundId.Size()
		i -= size
		if _, err := m.RoundId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Current.Size()
		i -= size
		if _, err := m.Current.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventNewRound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNewRound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNewRound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.StartedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartedAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintOcr(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x1a
	if len(m.StartedBy) > 0 {
		i -= len(m.StartedBy)
		copy(dAtA[i:], m.StartedBy)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.StartedBy)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.RoundId.Size()
		i -= size
		if _, err := m.RoundId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTransmitted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTransmitted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTransmitted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ConfigDigest) > 0 {
		i -= len(m.ConfigDigest)
		copy(dAtA[i:], m.ConfigDigest)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.ConfigDigest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventNewTransmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNewTransmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNewTransmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochAndRound != nil {
		{
			size, err := m.EpochAndRound.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOcr(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ConfigDigest) > 0 {
		i -= len(m.ConfigDigest)
		copy(dAtA[i:], m.ConfigDigest)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.ConfigDigest)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Observers) > 0 {
		i -= len(m.Observers)
		copy(dAtA[i:], m.Observers)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Observers)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Observations) > 0 {
		for iNdEx := len(m.Observations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Observations[iNdEx].Size()
				i -= size
				if _, err := m.Observations[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintOcr(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ObservationsTimestamp != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.ObservationsTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Transmitter) > 0 {
		i -= len(m.Transmitter)
		copy(dAtA[i:], m.Transmitter)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.Transmitter)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Answer.Size()
		i -= size
		if _, err := m.Answer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOcr(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.AggregatorRoundId != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.AggregatorRoundId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FeedId) > 0 {
		i -= len(m.FeedId)
		copy(dAtA[i:], m.FeedId)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.FeedId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventConfigSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventConfigSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventConfigSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigInfo != nil {
		{
			size, err := m.ConfigInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOcr(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOcr(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PreviousConfigBlockNumber != 0 {
		i = encodeVarintOcr(dAtA, i, uint64(m.PreviousConfigBlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ConfigDigest) > 0 {
		i -= len(m.ConfigDigest)
		copy(dAtA[i:], m.ConfigDigest)
		i = encodeVarintOcr(dAtA, i, uint64(len(m.ConfigDigest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOcr(dAtA []byte, offset int, v uint64) int {
	offset -= sovOcr(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LinkDenom)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.PayoutBlockInterval != 0 {
		n += 1 + sovOcr(uint64(m.PayoutBlockInterval))
	}
	l = len(m.ModuleAdmin)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *FeedConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signers) > 0 {
		for _, s := range m.Signers {
			l = len(s)
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	if len(m.Transmitters) > 0 {
		for _, s := range m.Transmitters {
			l = len(s)
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	if m.F != 0 {
		n += 1 + sovOcr(uint64(m.F))
	}
	l = len(m.OnchainConfig)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.OffchainConfigVersion != 0 {
		n += 1 + sovOcr(uint64(m.OffchainConfigVersion))
	}
	l = len(m.OffchainConfig)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.ModuleParams != nil {
		l = m.ModuleParams.Size()
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *FeedConfigInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LatestConfigDigest)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.F != 0 {
		n += 1 + sovOcr(uint64(m.F))
	}
	if m.N != 0 {
		n += 1 + sovOcr(uint64(m.N))
	}
	if m.ConfigCount != 0 {
		n += 1 + sovOcr(uint64(m.ConfigCount))
	}
	if m.LatestConfigBlockNumber != 0 {
		n += 1 + sovOcr(uint64(m.LatestConfigBlockNumber))
	}
	return n
}

func (m *ModuleParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FeedId)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = m.MinAnswer.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = m.MaxAnswer.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = m.LinkPerObservation.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = m.LinkPerTransmission.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = len(m.LinkDenom)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.UniqueReports {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.FeedAdmin)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.BillingAdmin)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *ContractConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigCount != 0 {
		n += 1 + sovOcr(uint64(m.ConfigCount))
	}
	if len(m.Signers) > 0 {
		for _, s := range m.Signers {
			l = len(s)
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	if len(m.Transmitters) > 0 {
		for _, s := range m.Transmitters {
			l = len(s)
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	if m.F != 0 {
		n += 1 + sovOcr(uint64(m.F))
	}
	l = len(m.OnchainConfig)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.OffchainConfigVersion != 0 {
		n += 1 + sovOcr(uint64(m.OffchainConfigVersion))
	}
	l = len(m.OffchainConfig)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *SetConfigProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *FeedProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FeedId)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.F != 0 {
		n += 1 + sovOcr(uint64(m.F))
	}
	l = len(m.OnchainConfig)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.OffchainConfigVersion != 0 {
		n += 1 + sovOcr(uint64(m.OffchainConfigVersion))
	}
	l = len(m.OffchainConfig)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = m.MinAnswer.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = m.MaxAnswer.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = m.LinkPerObservation.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = m.LinkPerTransmission.Size()
	n += 1 + l + sovOcr(uint64(l))
	if m.UniqueReports {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *SetBatchConfigProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if len(m.Signers) > 0 {
		for _, s := range m.Signers {
			l = len(s)
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	if len(m.Transmitters) > 0 {
		for _, s := range m.Transmitters {
			l = len(s)
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	l = len(m.LinkDenom)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if len(m.FeedProperties) > 0 {
		for _, e := range m.FeedProperties {
			l = e.Size()
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	return n
}

func (m *OracleObservationsCounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovOcr(uint64(e))
		}
		n += 1 + sovOcr(uint64(l)) + l
	}
	return n
}

func (m *GasReimbursements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reimbursements) > 0 {
		for _, e := range m.Reimbursements {
			l = e.Size()
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	return n
}

func (m *Payee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransmitterAddr)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.PaymentAddr)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *Transmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Answer.Size()
	n += 1 + l + sovOcr(uint64(l))
	if m.ObservationsTimestamp != 0 {
		n += 1 + sovOcr(uint64(m.ObservationsTimestamp))
	}
	if m.TransmissionTimestamp != 0 {
		n += 1 + sovOcr(uint64(m.TransmissionTimestamp))
	}
	return n
}

func (m *EpochAndRound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovOcr(uint64(m.Epoch))
	}
	if m.Round != 0 {
		n += 1 + sovOcr(uint64(m.Round))
	}
	return n
}

func (m *Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObservationsTimestamp != 0 {
		n += 1 + sovOcr(uint64(m.ObservationsTimestamp))
	}
	l = len(m.Observers)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if len(m.Observations) > 0 {
		for _, e := range m.Observations {
			l = e.Size()
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	return n
}

func (m *ReportToSign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigDigest)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovOcr(uint64(m.Epoch))
	}
	if m.Round != 0 {
		n += 1 + sovOcr(uint64(m.Round))
	}
	l = len(m.ExtraHash)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.Report)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *EventOraclePaid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransmitterAddr)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.PayeeAddr)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovOcr(uint64(l))
	return n
}

func (m *EventAnswerUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Current.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = m.RoundId.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovOcr(uint64(l))
	return n
}

func (m *EventNewRound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RoundId.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = len(m.StartedBy)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartedAt)
	n += 1 + l + sovOcr(uint64(l))
	return n
}

func (m *EventTransmitted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigDigest)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovOcr(uint64(m.Epoch))
	}
	return n
}

func (m *EventNewTransmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FeedId)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.AggregatorRoundId != 0 {
		n += 1 + sovOcr(uint64(m.AggregatorRoundId))
	}
	l = m.Answer.Size()
	n += 1 + l + sovOcr(uint64(l))
	l = len(m.Transmitter)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.ObservationsTimestamp != 0 {
		n += 1 + sovOcr(uint64(m.ObservationsTimestamp))
	}
	if len(m.Observations) > 0 {
		for _, e := range m.Observations {
			l = e.Size()
			n += 1 + l + sovOcr(uint64(l))
		}
	}
	l = len(m.Observers)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	l = len(m.ConfigDigest)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.EpochAndRound != nil {
		l = m.EpochAndRound.Size()
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func (m *EventConfigSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigDigest)
	if l > 0 {
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.PreviousConfigBlockNumber != 0 {
		n += 1 + sovOcr(uint64(m.PreviousConfigBlockNumber))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovOcr(uint64(l))
	}
	if m.ConfigInfo != nil {
		l = m.ConfigInfo.Size()
		n += 1 + l + sovOcr(uint64(l))
	}
	return n
}

func sovOcr(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOcr(x uint64) (n int) {
	return sovOcr(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutBlockInterval", wireType)
			}
			m.PayoutBlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayoutBlockInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transmitters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transmitters = append(m.Transmitters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			m.F = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.F |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnchainConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnchainConfig = append(m.OnchainConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.OnchainConfig == nil {
				m.OnchainConfig = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffchainConfigVersion", wireType)
			}
			m.OffchainConfigVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffchainConfigVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffchainConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffchainConfig = append(m.OffchainConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.OffchainConfig == nil {
				m.OffchainConfig = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModuleParams == nil {
				m.ModuleParams = &ModuleParams{}
			}
			if err := m.ModuleParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedConfigInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedConfigInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedConfigInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestConfigDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestConfigDigest = append(m.LatestConfigDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.LatestConfigDigest == nil {
				m.LatestConfigDigest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			m.F = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.F |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigCount", wireType)
			}
			m.ConfigCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestConfigBlockNumber", wireType)
			}
			m.LatestConfigBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestConfigBlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAnswer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxAnswer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkPerObservation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LinkPerObservation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkPerTransmission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LinkPerTransmission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueReports", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueReports = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigCount", wireType)
			}
			m.ConfigCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transmitters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transmitters = append(m.Transmitters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			m.F = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.F |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnchainConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnchainConfig = append(m.OnchainConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.OnchainConfig == nil {
				m.OnchainConfig = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffchainConfigVersion", wireType)
			}
			m.OffchainConfigVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffchainConfigVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffchainConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffchainConfig = append(m.OffchainConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.OffchainConfig == nil {
				m.OffchainConfig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetConfigProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetConfigProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetConfigProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &FeedConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			m.F = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.F |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnchainConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnchainConfig = append(m.OnchainConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.OnchainConfig == nil {
				m.OnchainConfig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffchainConfigVersion", wireType)
			}
			m.OffchainConfigVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffchainConfigVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffchainConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffchainConfig = append(m.OffchainConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.OffchainConfig == nil {
				m.OffchainConfig = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAnswer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxAnswer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkPerObservation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LinkPerObservation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkPerTransmission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LinkPerTransmission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueReports", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueReports = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBatchConfigProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBatchConfigProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBatchConfigProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transmitters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transmitters = append(m.Transmitters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedProperties = append(m.FeedProperties, &FeedProperties{})
			if err := m.FeedProperties[len(m.FeedProperties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleObservationsCounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleObservationsCounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleObservationsCounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOcr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOcr
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOcr
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOcr
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Counts) == 0 {
					m.Counts = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOcr
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasReimbursements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasReimbursements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasReimbursements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reimbursements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reimbursements = append(m.Reimbursements, &types.Coin{})
			if err := m.Reimbursements[len(m.Reimbursements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransmitterAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransmitterAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Answer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservationsTimestamp", wireType)
			}
			m.ObservationsTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservationsTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransmissionTimestamp", wireType)
			}
			m.TransmissionTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransmissionTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochAndRound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochAndRound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochAndRound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Report) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservationsTimestamp", wireType)
			}
			m.ObservationsTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservationsTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Observers = append(m.Observers[:0], dAtA[iNdEx:postIndex]...)
			if m.Observers == nil {
				m.Observers = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.Observations = append(m.Observations, v)
			if err := m.Observations[len(m.Observations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportToSign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportToSign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportToSign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigDigest = append(m.ConfigDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.ConfigDigest == nil {
				m.ConfigDigest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraHash = append(m.ExtraHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtraHash == nil {
				m.ExtraHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Report = append(m.Report[:0], dAtA[iNdEx:postIndex]...)
			if m.Report == nil {
				m.Report = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOraclePaid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOraclePaid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOraclePaid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransmitterAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransmitterAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayeeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayeeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAnswerUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAnswerUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAnswerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Current.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RoundId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNewRound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNewRound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNewRound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RoundId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.StartedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTransmitted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTransmitted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTransmitted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigDigest = append(m.ConfigDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.ConfigDigest == nil {
				m.ConfigDigest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNewTransmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNewTransmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNewTransmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorRoundId", wireType)
			}
			m.AggregatorRoundId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregatorRoundId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Answer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transmitter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transmitter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservationsTimestamp", wireType)
			}
			m.ObservationsTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObservationsTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.Observations = append(m.Observations, v)
			if err := m.Observations[len(m.Observations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Observers = append(m.Observers[:0], dAtA[iNdEx:postIndex]...)
			if m.Observers == nil {
				m.Observers = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigDigest = append(m.ConfigDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.ConfigDigest == nil {
				m.ConfigDigest = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochAndRound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EpochAndRound == nil {
				m.EpochAndRound = &EpochAndRound{}
			}
			if err := m.EpochAndRound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventConfigSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventConfigSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventConfigSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigDigest = append(m.ConfigDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.ConfigDigest == nil {
				m.ConfigDigest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousConfigBlockNumber", wireType)
			}
			m.PreviousConfigBlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousConfigBlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &FeedConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcr
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcr
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigInfo == nil {
				m.ConfigInfo = &FeedConfigInfo{}
			}
			if err := m.ConfigInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcr(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOcr(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOcr
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOcr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOcr
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOcr
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOcr
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOcr        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOcr          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOcr = fmt.Errorf("proto: unexpected end of group")
)
