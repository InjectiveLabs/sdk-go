// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/stream/v2/query.proto

package v2

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	v2 "github.com/InjectiveLabs/sdk-go/chain/exchange/types/v2"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OrderUpdateStatus int32

const (
	OrderUpdateStatus_Unspecified OrderUpdateStatus = 0
	OrderUpdateStatus_Booked      OrderUpdateStatus = 1
	OrderUpdateStatus_Matched     OrderUpdateStatus = 2
	OrderUpdateStatus_Cancelled   OrderUpdateStatus = 3
)

var OrderUpdateStatus_name = map[int32]string{
	0: "Unspecified",
	1: "Booked",
	2: "Matched",
	3: "Cancelled",
}

var OrderUpdateStatus_value = map[string]int32{
	"Unspecified": 0,
	"Booked":      1,
	"Matched":     2,
	"Cancelled":   3,
}

func (x OrderUpdateStatus) String() string {
	return proto.EnumName(OrderUpdateStatus_name, int32(x))
}

func (OrderUpdateStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{0}
}

type StreamRequest struct {
	// filter for bank balances events
	BankBalancesFilter *BankBalancesFilter `protobuf:"bytes,1,opt,name=bank_balances_filter,json=bankBalancesFilter,proto3" json:"bank_balances_filter,omitempty"`
	// filter for subaccount deposits events
	SubaccountDepositsFilter *SubaccountDepositsFilter `protobuf:"bytes,2,opt,name=subaccount_deposits_filter,json=subaccountDepositsFilter,proto3" json:"subaccount_deposits_filter,omitempty"`
	// filter for spot trades events
	SpotTradesFilter *TradesFilter `protobuf:"bytes,3,opt,name=spot_trades_filter,json=spotTradesFilter,proto3" json:"spot_trades_filter,omitempty"`
	// filter for derivative trades events
	DerivativeTradesFilter *TradesFilter `protobuf:"bytes,4,opt,name=derivative_trades_filter,json=derivativeTradesFilter,proto3" json:"derivative_trades_filter,omitempty"`
	// filter for spot orders events
	SpotOrdersFilter *OrdersFilter `protobuf:"bytes,5,opt,name=spot_orders_filter,json=spotOrdersFilter,proto3" json:"spot_orders_filter,omitempty"`
	// filter for derivative orders events
	DerivativeOrdersFilter *OrdersFilter `protobuf:"bytes,6,opt,name=derivative_orders_filter,json=derivativeOrdersFilter,proto3" json:"derivative_orders_filter,omitempty"`
	// filter for spot orderbooks events
	SpotOrderbooksFilter *OrderbookFilter `protobuf:"bytes,7,opt,name=spot_orderbooks_filter,json=spotOrderbooksFilter,proto3" json:"spot_orderbooks_filter,omitempty"`
	// filter for derivative orderbooks events
	DerivativeOrderbooksFilter *OrderbookFilter `protobuf:"bytes,8,opt,name=derivative_orderbooks_filter,json=derivativeOrderbooksFilter,proto3" json:"derivative_orderbooks_filter,omitempty"`
	// filter for positions events
	PositionsFilter *PositionsFilter `protobuf:"bytes,9,opt,name=positions_filter,json=positionsFilter,proto3" json:"positions_filter,omitempty"`
	// filter for oracle prices events
	OraclePriceFilter *OraclePriceFilter `protobuf:"bytes,10,opt,name=oracle_price_filter,json=oraclePriceFilter,proto3" json:"oracle_price_filter,omitempty"`
}

func (m *StreamRequest) Reset()         { *m = StreamRequest{} }
func (m *StreamRequest) String() string { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()    {}
func (*StreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{0}
}
func (m *StreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamRequest.Merge(m, src)
}
func (m *StreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamRequest proto.InternalMessageInfo

func (m *StreamRequest) GetBankBalancesFilter() *BankBalancesFilter {
	if m != nil {
		return m.BankBalancesFilter
	}
	return nil
}

func (m *StreamRequest) GetSubaccountDepositsFilter() *SubaccountDepositsFilter {
	if m != nil {
		return m.SubaccountDepositsFilter
	}
	return nil
}

func (m *StreamRequest) GetSpotTradesFilter() *TradesFilter {
	if m != nil {
		return m.SpotTradesFilter
	}
	return nil
}

func (m *StreamRequest) GetDerivativeTradesFilter() *TradesFilter {
	if m != nil {
		return m.DerivativeTradesFilter
	}
	return nil
}

func (m *StreamRequest) GetSpotOrdersFilter() *OrdersFilter {
	if m != nil {
		return m.SpotOrdersFilter
	}
	return nil
}

func (m *StreamRequest) GetDerivativeOrdersFilter() *OrdersFilter {
	if m != nil {
		return m.DerivativeOrdersFilter
	}
	return nil
}

func (m *StreamRequest) GetSpotOrderbooksFilter() *OrderbookFilter {
	if m != nil {
		return m.SpotOrderbooksFilter
	}
	return nil
}

func (m *StreamRequest) GetDerivativeOrderbooksFilter() *OrderbookFilter {
	if m != nil {
		return m.DerivativeOrderbooksFilter
	}
	return nil
}

func (m *StreamRequest) GetPositionsFilter() *PositionsFilter {
	if m != nil {
		return m.PositionsFilter
	}
	return nil
}

func (m *StreamRequest) GetOraclePriceFilter() *OraclePriceFilter {
	if m != nil {
		return m.OraclePriceFilter
	}
	return nil
}

type StreamResponse struct {
	// the block height
	BlockHeight uint64 `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// the block time
	BlockTime int64 `protobuf:"varint,2,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	// list of bank balances updates
	BankBalances []*BankBalance `protobuf:"bytes,3,rep,name=bank_balances,json=bankBalances,proto3" json:"bank_balances,omitempty"`
	// list of subaccount deposits updates
	SubaccountDeposits []*SubaccountDeposits `protobuf:"bytes,4,rep,name=subaccount_deposits,json=subaccountDeposits,proto3" json:"subaccount_deposits,omitempty"`
	// list of spot trades updates
	SpotTrades []*SpotTrade `protobuf:"bytes,5,rep,name=spot_trades,json=spotTrades,proto3" json:"spot_trades,omitempty"`
	// list of derivative trades updates
	DerivativeTrades []*DerivativeTrade `protobuf:"bytes,6,rep,name=derivative_trades,json=derivativeTrades,proto3" json:"derivative_trades,omitempty"`
	// list of spot orders updates
	SpotOrders []*SpotOrderUpdate `protobuf:"bytes,7,rep,name=spot_orders,json=spotOrders,proto3" json:"spot_orders,omitempty"`
	// list of derivative orders updates
	DerivativeOrders []*DerivativeOrderUpdate `protobuf:"bytes,8,rep,name=derivative_orders,json=derivativeOrders,proto3" json:"derivative_orders,omitempty"`
	// list of spot orderbook updates
	SpotOrderbookUpdates []*OrderbookUpdate `protobuf:"bytes,9,rep,name=spot_orderbook_updates,json=spotOrderbookUpdates,proto3" json:"spot_orderbook_updates,omitempty"`
	// list of derivative orderbook updates
	DerivativeOrderbookUpdates []*OrderbookUpdate `protobuf:"bytes,10,rep,name=derivative_orderbook_updates,json=derivativeOrderbookUpdates,proto3" json:"derivative_orderbook_updates,omitempty"`
	// list of positions updates
	Positions []*Position `protobuf:"bytes,11,rep,name=positions,proto3" json:"positions,omitempty"`
	// list of oracle prices updates
	OraclePrices []*OraclePrice `protobuf:"bytes,12,rep,name=oracle_prices,json=oraclePrices,proto3" json:"oracle_prices,omitempty"`
	// the current gas price when the block was processed (in chain format)
	GasPrice string `protobuf:"bytes,13,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
}

func (m *StreamResponse) Reset()         { *m = StreamResponse{} }
func (m *StreamResponse) String() string { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()    {}
func (*StreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{1}
}
func (m *StreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamResponse.Merge(m, src)
}
func (m *StreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamResponse proto.InternalMessageInfo

func (m *StreamResponse) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *StreamResponse) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *StreamResponse) GetBankBalances() []*BankBalance {
	if m != nil {
		return m.BankBalances
	}
	return nil
}

func (m *StreamResponse) GetSubaccountDeposits() []*SubaccountDeposits {
	if m != nil {
		return m.SubaccountDeposits
	}
	return nil
}

func (m *StreamResponse) GetSpotTrades() []*SpotTrade {
	if m != nil {
		return m.SpotTrades
	}
	return nil
}

func (m *StreamResponse) GetDerivativeTrades() []*DerivativeTrade {
	if m != nil {
		return m.DerivativeTrades
	}
	return nil
}

func (m *StreamResponse) GetSpotOrders() []*SpotOrderUpdate {
	if m != nil {
		return m.SpotOrders
	}
	return nil
}

func (m *StreamResponse) GetDerivativeOrders() []*DerivativeOrderUpdate {
	if m != nil {
		return m.DerivativeOrders
	}
	return nil
}

func (m *StreamResponse) GetSpotOrderbookUpdates() []*OrderbookUpdate {
	if m != nil {
		return m.SpotOrderbookUpdates
	}
	return nil
}

func (m *StreamResponse) GetDerivativeOrderbookUpdates() []*OrderbookUpdate {
	if m != nil {
		return m.DerivativeOrderbookUpdates
	}
	return nil
}

func (m *StreamResponse) GetPositions() []*Position {
	if m != nil {
		return m.Positions
	}
	return nil
}

func (m *StreamResponse) GetOraclePrices() []*OraclePrice {
	if m != nil {
		return m.OraclePrices
	}
	return nil
}

func (m *StreamResponse) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

type OrderbookUpdate struct {
	// the sequence number of the orderbook update
	Seq uint64 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// the orderbook details
	Orderbook *Orderbook `protobuf:"bytes,2,opt,name=orderbook,proto3" json:"orderbook,omitempty"`
}

func (m *OrderbookUpdate) Reset()         { *m = OrderbookUpdate{} }
func (m *OrderbookUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderbookUpdate) ProtoMessage()    {}
func (*OrderbookUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{2}
}
func (m *OrderbookUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderbookUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderbookUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderbookUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderbookUpdate.Merge(m, src)
}
func (m *OrderbookUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderbookUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderbookUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderbookUpdate proto.InternalMessageInfo

func (m *OrderbookUpdate) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *OrderbookUpdate) GetOrderbook() *Orderbook {
	if m != nil {
		return m.Orderbook
	}
	return nil
}

type Orderbook struct {
	// the market ID
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// list of buy levels
	BuyLevels []*v2.Level `protobuf:"bytes,2,rep,name=buy_levels,json=buyLevels,proto3" json:"buy_levels,omitempty"`
	// list of sell levels
	SellLevels []*v2.Level `protobuf:"bytes,3,rep,name=sell_levels,json=sellLevels,proto3" json:"sell_levels,omitempty"`
}

func (m *Orderbook) Reset()         { *m = Orderbook{} }
func (m *Orderbook) String() string { return proto.CompactTextString(m) }
func (*Orderbook) ProtoMessage()    {}
func (*Orderbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{3}
}
func (m *Orderbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Orderbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Orderbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Orderbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Orderbook.Merge(m, src)
}
func (m *Orderbook) XXX_Size() int {
	return m.Size()
}
func (m *Orderbook) XXX_DiscardUnknown() {
	xxx_messageInfo_Orderbook.DiscardUnknown(m)
}

var xxx_messageInfo_Orderbook proto.InternalMessageInfo

func (m *Orderbook) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *Orderbook) GetBuyLevels() []*v2.Level {
	if m != nil {
		return m.BuyLevels
	}
	return nil
}

func (m *Orderbook) GetSellLevels() []*v2.Level {
	if m != nil {
		return m.SellLevels
	}
	return nil
}

type BankBalance struct {
	// the account address
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// list of account balances
	Balances github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=balances,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"balances"`
}

func (m *BankBalance) Reset()         { *m = BankBalance{} }
func (m *BankBalance) String() string { return proto.CompactTextString(m) }
func (*BankBalance) ProtoMessage()    {}
func (*BankBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{4}
}
func (m *BankBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BankBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BankBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BankBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BankBalance.Merge(m, src)
}
func (m *BankBalance) XXX_Size() int {
	return m.Size()
}
func (m *BankBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BankBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BankBalance proto.InternalMessageInfo

func (m *BankBalance) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *BankBalance) GetBalances() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Balances
	}
	return nil
}

type SubaccountDeposits struct {
	// the subaccount ID
	SubaccountId string `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// the deposits details
	Deposits []SubaccountDeposit `protobuf:"bytes,2,rep,name=deposits,proto3" json:"deposits"`
}

func (m *SubaccountDeposits) Reset()         { *m = SubaccountDeposits{} }
func (m *SubaccountDeposits) String() string { return proto.CompactTextString(m) }
func (*SubaccountDeposits) ProtoMessage()    {}
func (*SubaccountDeposits) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{5}
}
func (m *SubaccountDeposits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountDeposits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountDeposits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountDeposits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountDeposits.Merge(m, src)
}
func (m *SubaccountDeposits) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountDeposits) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountDeposits.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountDeposits proto.InternalMessageInfo

func (m *SubaccountDeposits) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *SubaccountDeposits) GetDeposits() []SubaccountDeposit {
	if m != nil {
		return m.Deposits
	}
	return nil
}

type SubaccountDeposit struct {
	Denom   string     `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Deposit v2.Deposit `protobuf:"bytes,2,opt,name=deposit,proto3" json:"deposit"`
}

func (m *SubaccountDeposit) Reset()         { *m = SubaccountDeposit{} }
func (m *SubaccountDeposit) String() string { return proto.CompactTextString(m) }
func (*SubaccountDeposit) ProtoMessage()    {}
func (*SubaccountDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{6}
}
func (m *SubaccountDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountDeposit.Merge(m, src)
}
func (m *SubaccountDeposit) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountDeposit proto.InternalMessageInfo

func (m *SubaccountDeposit) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *SubaccountDeposit) GetDeposit() v2.Deposit {
	if m != nil {
		return m.Deposit
	}
	return v2.Deposit{}
}

type SpotOrderUpdate struct {
	// the status of the order
	Status OrderUpdateStatus `protobuf:"varint,1,opt,name=status,proto3,enum=injective.stream.v2.OrderUpdateStatus" json:"status,omitempty"`
	// the order hash
	OrderHash string `protobuf:"bytes,2,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// the client order ID
	Cid string `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
	// the order details
	Order *SpotOrder `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *SpotOrderUpdate) Reset()         { *m = SpotOrderUpdate{} }
func (m *SpotOrderUpdate) String() string { return proto.CompactTextString(m) }
func (*SpotOrderUpdate) ProtoMessage()    {}
func (*SpotOrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{7}
}
func (m *SpotOrderUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotOrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotOrderUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotOrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotOrderUpdate.Merge(m, src)
}
func (m *SpotOrderUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SpotOrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotOrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SpotOrderUpdate proto.InternalMessageInfo

func (m *SpotOrderUpdate) GetStatus() OrderUpdateStatus {
	if m != nil {
		return m.Status
	}
	return OrderUpdateStatus_Unspecified
}

func (m *SpotOrderUpdate) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *SpotOrderUpdate) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *SpotOrderUpdate) GetOrder() *SpotOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type SpotOrder struct {
	// the market ID
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// the order details
	Order v2.SpotLimitOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *SpotOrder) Reset()         { *m = SpotOrder{} }
func (m *SpotOrder) String() string { return proto.CompactTextString(m) }
func (*SpotOrder) ProtoMessage()    {}
func (*SpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{8}
}
func (m *SpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotOrder.Merge(m, src)
}
func (m *SpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *SpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SpotOrder proto.InternalMessageInfo

func (m *SpotOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *SpotOrder) GetOrder() v2.SpotLimitOrder {
	if m != nil {
		return m.Order
	}
	return v2.SpotLimitOrder{}
}

type DerivativeOrderUpdate struct {
	// the status of the order
	Status OrderUpdateStatus `protobuf:"varint,1,opt,name=status,proto3,enum=injective.stream.v2.OrderUpdateStatus" json:"status,omitempty"`
	// the order hash
	OrderHash string `protobuf:"bytes,2,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// the client order ID
	Cid string `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
	// the order details
	Order *DerivativeOrder `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *DerivativeOrderUpdate) Reset()         { *m = DerivativeOrderUpdate{} }
func (m *DerivativeOrderUpdate) String() string { return proto.CompactTextString(m) }
func (*DerivativeOrderUpdate) ProtoMessage()    {}
func (*DerivativeOrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{9}
}
func (m *DerivativeOrderUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeOrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeOrderUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeOrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeOrderUpdate.Merge(m, src)
}
func (m *DerivativeOrderUpdate) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeOrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeOrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeOrderUpdate proto.InternalMessageInfo

func (m *DerivativeOrderUpdate) GetStatus() OrderUpdateStatus {
	if m != nil {
		return m.Status
	}
	return OrderUpdateStatus_Unspecified
}

func (m *DerivativeOrderUpdate) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *DerivativeOrderUpdate) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *DerivativeOrderUpdate) GetOrder() *DerivativeOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type DerivativeOrder struct {
	// the market ID
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// the order details
	Order v2.DerivativeLimitOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
	// whether the order is a market order
	IsMarket bool `protobuf:"varint,3,opt,name=is_market,json=isMarket,proto3" json:"is_market,omitempty"`
}

func (m *DerivativeOrder) Reset()         { *m = DerivativeOrder{} }
func (m *DerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*DerivativeOrder) ProtoMessage()    {}
func (*DerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{10}
}
func (m *DerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeOrder.Merge(m, src)
}
func (m *DerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeOrder proto.InternalMessageInfo

func (m *DerivativeOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeOrder) GetOrder() v2.DerivativeLimitOrder {
	if m != nil {
		return m.Order
	}
	return v2.DerivativeLimitOrder{}
}

func (m *DerivativeOrder) GetIsMarket() bool {
	if m != nil {
		return m.IsMarket
	}
	return false
}

type Position struct {
	// the market ID
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// the subaccount ID
	SubaccountId string `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// whether the position is long or short
	IsLong bool `protobuf:"varint,3,opt,name=isLong,proto3" json:"isLong,omitempty"`
	// the quantity of the position (in human readable format)
	Quantity cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=quantity,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"quantity"`
	// the entry price of the position (in human readable format)
	EntryPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=entry_price,json=entryPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"entry_price"`
	// the margin of the position (in human readable format)
	Margin cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=margin,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"margin"`
	// the cumulative funding entry of the position (in human readable format)
	CumulativeFundingEntry cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=cumulative_funding_entry,json=cumulativeFundingEntry,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"cumulative_funding_entry"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{11}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *Position) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *Position) GetIsLong() bool {
	if m != nil {
		return m.IsLong
	}
	return false
}

type OraclePrice struct {
	// the symbol of the oracle price
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// the updated price
	Price cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	// the oracle type
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *OraclePrice) Reset()         { *m = OraclePrice{} }
func (m *OraclePrice) String() string { return proto.CompactTextString(m) }
func (*OraclePrice) ProtoMessage()    {}
func (*OraclePrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{12}
}
func (m *OraclePrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePrice.Merge(m, src)
}
func (m *OraclePrice) XXX_Size() int {
	return m.Size()
}
func (m *OraclePrice) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePrice.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePrice proto.InternalMessageInfo

func (m *OraclePrice) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *OraclePrice) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type SpotTrade struct {
	// the market ID
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// whether the trade is a buy or sell
	IsBuy bool `protobuf:"varint,2,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	// the execution type
	ExecutionType string `protobuf:"bytes,3,opt,name=executionType,proto3" json:"executionType,omitempty"`
	// the quantity of the trade (in human readable format)
	Quantity cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=quantity,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"quantity"`
	// the price of the trade (in human readable format)
	Price cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	// the subaccount ID that executed the trade
	SubaccountId string `protobuf:"bytes,6,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// the fee of the trade (in human readable format)
	Fee cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=fee,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"fee"`
	// the order hash
	OrderHash string `protobuf:"bytes,8,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// the fee recipient address
	FeeRecipientAddress string `protobuf:"bytes,9,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	// the client order ID
	Cid string `protobuf:"bytes,10,opt,name=cid,proto3" json:"cid,omitempty"`
	// the trade ID
	TradeId string `protobuf:"bytes,11,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
}

func (m *SpotTrade) Reset()         { *m = SpotTrade{} }
func (m *SpotTrade) String() string { return proto.CompactTextString(m) }
func (*SpotTrade) ProtoMessage()    {}
func (*SpotTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{13}
}
func (m *SpotTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotTrade.Merge(m, src)
}
func (m *SpotTrade) XXX_Size() int {
	return m.Size()
}
func (m *SpotTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotTrade.DiscardUnknown(m)
}

var xxx_messageInfo_SpotTrade proto.InternalMessageInfo

func (m *SpotTrade) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *SpotTrade) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *SpotTrade) GetExecutionType() string {
	if m != nil {
		return m.ExecutionType
	}
	return ""
}

func (m *SpotTrade) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *SpotTrade) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *SpotTrade) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *SpotTrade) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *SpotTrade) GetTradeId() string {
	if m != nil {
		return m.TradeId
	}
	return ""
}

type DerivativeTrade struct {
	// the market ID
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// whether the trade is a buy or sell
	IsBuy bool `protobuf:"varint,2,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	// the execution type
	ExecutionType string `protobuf:"bytes,3,opt,name=executionType,proto3" json:"executionType,omitempty"`
	// the subaccount ID
	SubaccountId string `protobuf:"bytes,4,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// the position delta of the trade (in human readable format)
	PositionDelta *v2.PositionDelta `protobuf:"bytes,5,opt,name=position_delta,json=positionDelta,proto3" json:"position_delta,omitempty"`
	// the payout of the trade (in human readable format)
	Payout cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=payout,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"payout"`
	// the fee of the trade (in human readable format)
	Fee cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=fee,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"fee"`
	// the order hash
	OrderHash string `protobuf:"bytes,8,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// the fee recipient address
	FeeRecipientAddress string `protobuf:"bytes,9,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	// the client order ID
	Cid string `protobuf:"bytes,10,opt,name=cid,proto3" json:"cid,omitempty"`
	// the trade ID
	TradeId string `protobuf:"bytes,11,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
}

func (m *DerivativeTrade) Reset()         { *m = DerivativeTrade{} }
func (m *DerivativeTrade) String() string { return proto.CompactTextString(m) }
func (*DerivativeTrade) ProtoMessage()    {}
func (*DerivativeTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{14}
}
func (m *DerivativeTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeTrade.Merge(m, src)
}
func (m *DerivativeTrade) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeTrade.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeTrade proto.InternalMessageInfo

func (m *DerivativeTrade) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeTrade) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *DerivativeTrade) GetExecutionType() string {
	if m != nil {
		return m.ExecutionType
	}
	return ""
}

func (m *DerivativeTrade) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *DerivativeTrade) GetPositionDelta() *v2.PositionDelta {
	if m != nil {
		return m.PositionDelta
	}
	return nil
}

func (m *DerivativeTrade) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *DerivativeTrade) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *DerivativeTrade) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *DerivativeTrade) GetTradeId() string {
	if m != nil {
		return m.TradeId
	}
	return ""
}

type TradesFilter struct {
	// list of subaccount IDs to filter by
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
	// list of market IDs to filter by
	MarketIds []string `protobuf:"bytes,2,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *TradesFilter) Reset()         { *m = TradesFilter{} }
func (m *TradesFilter) String() string { return proto.CompactTextString(m) }
func (*TradesFilter) ProtoMessage()    {}
func (*TradesFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{15}
}
func (m *TradesFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradesFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradesFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradesFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradesFilter.Merge(m, src)
}
func (m *TradesFilter) XXX_Size() int {
	return m.Size()
}
func (m *TradesFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_TradesFilter.DiscardUnknown(m)
}

var xxx_messageInfo_TradesFilter proto.InternalMessageInfo

func (m *TradesFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

func (m *TradesFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type PositionsFilter struct {
	// list of subaccount IDs to filter by
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
	// list of market IDs to filter by
	MarketIds []string `protobuf:"bytes,2,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *PositionsFilter) Reset()         { *m = PositionsFilter{} }
func (m *PositionsFilter) String() string { return proto.CompactTextString(m) }
func (*PositionsFilter) ProtoMessage()    {}
func (*PositionsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{16}
}
func (m *PositionsFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionsFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionsFilter.Merge(m, src)
}
func (m *PositionsFilter) XXX_Size() int {
	return m.Size()
}
func (m *PositionsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PositionsFilter proto.InternalMessageInfo

func (m *PositionsFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

func (m *PositionsFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type OrdersFilter struct {
	// list of subaccount IDs to filter by
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
	// list of market IDs to filter by
	MarketIds []string `protobuf:"bytes,2,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *OrdersFilter) Reset()         { *m = OrdersFilter{} }
func (m *OrdersFilter) String() string { return proto.CompactTextString(m) }
func (*OrdersFilter) ProtoMessage()    {}
func (*OrdersFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{17}
}
func (m *OrdersFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrdersFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrdersFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrdersFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrdersFilter.Merge(m, src)
}
func (m *OrdersFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrdersFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrdersFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrdersFilter proto.InternalMessageInfo

func (m *OrdersFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

func (m *OrdersFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type OrderbookFilter struct {
	// list of market IDs to filter by
	MarketIds []string `protobuf:"bytes,1,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *OrderbookFilter) Reset()         { *m = OrderbookFilter{} }
func (m *OrderbookFilter) String() string { return proto.CompactTextString(m) }
func (*OrderbookFilter) ProtoMessage()    {}
func (*OrderbookFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{18}
}
func (m *OrderbookFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderbookFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderbookFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderbookFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderbookFilter.Merge(m, src)
}
func (m *OrderbookFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrderbookFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderbookFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrderbookFilter proto.InternalMessageInfo

func (m *OrderbookFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type BankBalancesFilter struct {
	// list of account addresses to filter by
	Accounts []string `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts,omitempty"`
}

func (m *BankBalancesFilter) Reset()         { *m = BankBalancesFilter{} }
func (m *BankBalancesFilter) String() string { return proto.CompactTextString(m) }
func (*BankBalancesFilter) ProtoMessage()    {}
func (*BankBalancesFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{19}
}
func (m *BankBalancesFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BankBalancesFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BankBalancesFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BankBalancesFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BankBalancesFilter.Merge(m, src)
}
func (m *BankBalancesFilter) XXX_Size() int {
	return m.Size()
}
func (m *BankBalancesFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_BankBalancesFilter.DiscardUnknown(m)
}

var xxx_messageInfo_BankBalancesFilter proto.InternalMessageInfo

func (m *BankBalancesFilter) GetAccounts() []string {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type SubaccountDepositsFilter struct {
	// list of subaccount IDs to filter by
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
}

func (m *SubaccountDepositsFilter) Reset()         { *m = SubaccountDepositsFilter{} }
func (m *SubaccountDepositsFilter) String() string { return proto.CompactTextString(m) }
func (*SubaccountDepositsFilter) ProtoMessage()    {}
func (*SubaccountDepositsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{20}
}
func (m *SubaccountDepositsFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountDepositsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountDepositsFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountDepositsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountDepositsFilter.Merge(m, src)
}
func (m *SubaccountDepositsFilter) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountDepositsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountDepositsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountDepositsFilter proto.InternalMessageInfo

func (m *SubaccountDepositsFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

type OraclePriceFilter struct {
	// list of symbol to filter by
	Symbol []string `protobuf:"bytes,1,rep,name=symbol,proto3" json:"symbol,omitempty"`
}

func (m *OraclePriceFilter) Reset()         { *m = OraclePriceFilter{} }
func (m *OraclePriceFilter) String() string { return proto.CompactTextString(m) }
func (*OraclePriceFilter) ProtoMessage()    {}
func (*OraclePriceFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_63d15adfde4eb6f9, []int{21}
}
func (m *OraclePriceFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePriceFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePriceFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePriceFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePriceFilter.Merge(m, src)
}
func (m *OraclePriceFilter) XXX_Size() int {
	return m.Size()
}
func (m *OraclePriceFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePriceFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePriceFilter proto.InternalMessageInfo

func (m *OraclePriceFilter) GetSymbol() []string {
	if m != nil {
		return m.Symbol
	}
	return nil
}

func init() {
	proto.RegisterEnum("injective.stream.v2.OrderUpdateStatus", OrderUpdateStatus_name, OrderUpdateStatus_value)
	proto.RegisterType((*StreamRequest)(nil), "injective.stream.v2.StreamRequest")
	proto.RegisterType((*StreamResponse)(nil), "injective.stream.v2.StreamResponse")
	proto.RegisterType((*OrderbookUpdate)(nil), "injective.stream.v2.OrderbookUpdate")
	proto.RegisterType((*Orderbook)(nil), "injective.stream.v2.Orderbook")
	proto.RegisterType((*BankBalance)(nil), "injective.stream.v2.BankBalance")
	proto.RegisterType((*SubaccountDeposits)(nil), "injective.stream.v2.SubaccountDeposits")
	proto.RegisterType((*SubaccountDeposit)(nil), "injective.stream.v2.SubaccountDeposit")
	proto.RegisterType((*SpotOrderUpdate)(nil), "injective.stream.v2.SpotOrderUpdate")
	proto.RegisterType((*SpotOrder)(nil), "injective.stream.v2.SpotOrder")
	proto.RegisterType((*DerivativeOrderUpdate)(nil), "injective.stream.v2.DerivativeOrderUpdate")
	proto.RegisterType((*DerivativeOrder)(nil), "injective.stream.v2.DerivativeOrder")
	proto.RegisterType((*Position)(nil), "injective.stream.v2.Position")
	proto.RegisterType((*OraclePrice)(nil), "injective.stream.v2.OraclePrice")
	proto.RegisterType((*SpotTrade)(nil), "injective.stream.v2.SpotTrade")
	proto.RegisterType((*DerivativeTrade)(nil), "injective.stream.v2.DerivativeTrade")
	proto.RegisterType((*TradesFilter)(nil), "injective.stream.v2.TradesFilter")
	proto.RegisterType((*PositionsFilter)(nil), "injective.stream.v2.PositionsFilter")
	proto.RegisterType((*OrdersFilter)(nil), "injective.stream.v2.OrdersFilter")
	proto.RegisterType((*OrderbookFilter)(nil), "injective.stream.v2.OrderbookFilter")
	proto.RegisterType((*BankBalancesFilter)(nil), "injective.stream.v2.BankBalancesFilter")
	proto.RegisterType((*SubaccountDepositsFilter)(nil), "injective.stream.v2.SubaccountDepositsFilter")
	proto.RegisterType((*OraclePriceFilter)(nil), "injective.stream.v2.OraclePriceFilter")
}

func init() { proto.RegisterFile("injective/stream/v2/query.proto", fileDescriptor_63d15adfde4eb6f9) }

var fileDescriptor_63d15adfde4eb6f9 = []byte{
	// 1673 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xcd, 0x6f, 0xdb, 0xca,
	0x11, 0x37, 0x2d, 0x4b, 0x16, 0x47, 0xfe, 0x90, 0xd7, 0x8e, 0xc1, 0x38, 0x89, 0xec, 0x30, 0x4e,
	0x62, 0x24, 0x88, 0x94, 0xa8, 0x2d, 0xd0, 0x36, 0x6d, 0x82, 0x28, 0xce, 0x87, 0x51, 0x07, 0x4d,
	0x69, 0xbb, 0x29, 0x82, 0x16, 0xec, 0x8a, 0x5c, 0x4b, 0xac, 0x24, 0x52, 0xe6, 0x92, 0x42, 0x74,
	0xee, 0xa1, 0x97, 0x1e, 0x72, 0xe8, 0x9f, 0xd0, 0x53, 0xff, 0x82, 0xde, 0xdb, 0x43, 0x8e, 0xb9,
	0xb5, 0x28, 0x8a, 0xbc, 0x87, 0xe4, 0x1f, 0x79, 0xd8, 0x0f, 0x52, 0xa4, 0xbe, 0x22, 0xe3, 0xe5,
	0x3d, 0xe0, 0x9d, 0xb4, 0xbb, 0x9c, 0xf9, 0xfd, 0x66, 0x67, 0x67, 0x66, 0x47, 0x0b, 0xdb, 0x8e,
	0xfb, 0x27, 0x62, 0x05, 0x4e, 0x8f, 0x54, 0x68, 0xe0, 0x13, 0xdc, 0xa9, 0xf4, 0xaa, 0x95, 0xb3,
	0x90, 0xf8, 0xfd, 0x72, 0xd7, 0xf7, 0x02, 0x0f, 0xad, 0xc7, 0x02, 0x65, 0x21, 0x50, 0xee, 0x55,
	0xb7, 0x4a, 0x96, 0x47, 0x3b, 0x1e, 0xad, 0xd4, 0x31, 0x25, 0x95, 0xde, 0xbd, 0x3a, 0x09, 0xf0,
	0xbd, 0x8a, 0xe5, 0x39, 0xae, 0x50, 0xda, 0xda, 0x68, 0x78, 0x0d, 0x8f, 0x0f, 0x2b, 0x6c, 0x24,
	0x57, 0xf5, 0x01, 0x17, 0x79, 0x63, 0x35, 0xb1, 0xdb, 0x20, 0x8c, 0x8d, 0xf4, 0x88, 0x1b, 0x50,
	0x29, 0xb3, 0x3b, 0x41, 0x46, 0x8e, 0xa5, 0xd4, 0xd5, 0xf1, 0x52, 0x9e, 0x6f, 0x13, 0x5f, 0x88,
	0xe8, 0xff, 0x5f, 0x84, 0xe5, 0x23, 0x6e, 0xb0, 0x41, 0xce, 0x42, 0x42, 0x03, 0x64, 0xc2, 0x46,
	0x1d, 0xbb, 0x2d, 0xb3, 0x8e, 0xdb, 0xd8, 0xb5, 0x08, 0x35, 0x4f, 0x9d, 0x76, 0x40, 0x7c, 0x4d,
	0xd9, 0x51, 0xf6, 0x0a, 0xd5, 0x9b, 0xe5, 0x31, 0x1b, 0x2d, 0xd7, 0xb0, 0xdb, 0xaa, 0x49, 0xf9,
	0xa7, 0x5c, 0xbc, 0xb6, 0xf0, 0xee, 0xc3, 0xb6, 0x62, 0xa0, 0xfa, 0xc8, 0x17, 0x74, 0x06, 0x5b,
	0x34, 0xac, 0x63, 0xcb, 0xf2, 0x42, 0x37, 0x30, 0x6d, 0xd2, 0xf5, 0xa8, 0x13, 0xc4, 0x34, 0xf3,
	0x9c, 0xe6, 0xce, 0x58, 0x9a, 0xa3, 0x58, 0x6d, 0x5f, 0x6a, 0xa5, 0xc8, 0x34, 0x3a, 0xe1, 0x3b,
	0x3a, 0x01, 0x44, 0xbb, 0x5e, 0x60, 0x06, 0x3e, 0xb6, 0x07, 0x3b, 0xca, 0x70, 0xaa, 0xab, 0x63,
	0xa9, 0x8e, 0xb9, 0x64, 0x0a, 0xbe, 0xc8, 0x20, 0x92, 0xeb, 0x08, 0x83, 0x66, 0x13, 0xdf, 0xe9,
	0x61, 0xa6, 0x3c, 0x04, 0xbe, 0x70, 0x3e, 0xf0, 0xcd, 0x01, 0x50, 0x8a, 0x22, 0xb2, 0x9c, 0x9f,
	0x59, 0x0c, 0x9e, 0x9d, 0x02, 0xfe, 0x6b, 0x2e, 0x39, 0x6a, 0x79, 0x72, 0x7d, 0xc8, 0xf2, 0x34,
	0x78, 0xee, 0x7c, 0xe0, 0x09, 0xcb, 0x53, 0x14, 0x7f, 0x84, 0xcd, 0x81, 0xe5, 0x75, 0xcf, 0x6b,
	0xc5, 0x04, 0x8b, 0x9c, 0x60, 0x77, 0x32, 0x01, 0x93, 0x4e, 0x71, 0x6c, 0xc4, 0x1b, 0xe0, 0x40,
	0x92, 0xa1, 0x0d, 0x97, 0x87, 0x37, 0x91, 0xe2, 0xc9, 0x9f, 0x9b, 0x67, 0x6b, 0x68, 0x2f, 0x49,
	0xb6, 0x13, 0x28, 0xf2, 0x98, 0x72, 0x3c, 0x37, 0x66, 0x50, 0xa7, 0x30, 0xbc, 0x8c, 0x84, 0x53,
	0x0c, 0xab, 0xdd, 0xf4, 0x32, 0xfa, 0x3d, 0xac, 0x7b, 0x3e, 0xb6, 0xda, 0xc4, 0xec, 0xfa, 0x8e,
	0x45, 0x22, 0x64, 0xe0, 0xc8, 0x37, 0x26, 0xd8, 0xce, 0xe4, 0x5f, 0x32, 0xf1, 0x14, 0xf6, 0x9a,
	0x37, 0xfc, 0x41, 0xff, 0xeb, 0x22, 0xac, 0x44, 0xe9, 0x4d, 0xbb, 0x9e, 0x4b, 0x09, 0xba, 0x0a,
	0x4b, 0xf5, 0xb6, 0x67, 0xb5, 0xcc, 0x26, 0x71, 0x1a, 0xcd, 0x80, 0xe7, 0xf5, 0x82, 0x51, 0xe0,
	0x6b, 0xcf, 0xf9, 0x12, 0xba, 0x02, 0x20, 0x44, 0x02, 0xa7, 0x43, 0x78, 0x46, 0x66, 0x0c, 0x95,
	0xaf, 0x1c, 0x3b, 0x1d, 0x82, 0x9e, 0xc0, 0x72, 0xaa, 0x42, 0x68, 0x99, 0x9d, 0xcc, 0x5e, 0xa1,
	0xba, 0xf3, 0xb9, 0xd2, 0x60, 0x2c, 0x25, 0xab, 0x01, 0xfa, 0x1d, 0xac, 0x8f, 0xa9, 0x03, 0xda,
	0x02, 0x07, 0xbb, 0x39, 0x63, 0x01, 0x30, 0xd0, 0x68, 0xd2, 0xa3, 0x87, 0x50, 0x48, 0xa4, 0xbb,
	0x96, 0xe5, 0x88, 0xa5, 0xf1, 0x88, 0x51, 0x4e, 0x1b, 0x30, 0x48, 0x6f, 0xf4, 0x1b, 0x58, 0x1b,
	0x49, 0x6c, 0x2d, 0xc7, 0x61, 0xc6, 0x1f, 0xf6, 0x7e, 0x3a, 0x7b, 0x8d, 0xe2, 0x70, 0x3a, 0xa3,
	0x27, 0xd2, 0x26, 0x91, 0x6b, 0xda, 0xe2, 0x14, 0xb0, 0xa3, 0x28, 0xd8, 0x4f, 0xba, 0x36, 0x0e,
	0xa4, 0x65, 0x22, 0xb7, 0xd0, 0xab, 0x94, 0x65, 0x12, 0x2c, 0xcf, 0xc1, 0x6e, 0x7d, 0xc6, 0xb2,
	0x24, 0x64, 0x71, 0x38, 0x69, 0xd1, 0xeb, 0xe1, 0x74, 0x35, 0x43, 0x2e, 0x4a, 0x35, 0x75, 0x8a,
	0xa9, 0x71, 0x96, 0x48, 0xdc, 0x74, 0xa2, 0x8a, 0x45, 0x8a, 0x4e, 0xc7, 0x27, 0x6a, 0xcc, 0x00,
	0xe7, 0x60, 0x18, 0x97, 0xa2, 0x11, 0xcf, 0x7d, 0x50, 0xe3, 0xf4, 0xd2, 0x0a, 0x1c, 0xf4, 0xca,
	0xd4, 0xdc, 0x34, 0x06, 0xf2, 0x2c, 0xaa, 0x93, 0x89, 0x48, 0xb5, 0xa5, 0x29, 0x51, 0x9d, 0x48,
	0x41, 0x63, 0x29, 0x91, 0x76, 0x14, 0x5d, 0x02, 0xb5, 0x81, 0xa9, 0xc0, 0xd0, 0x96, 0x77, 0x94,
	0x3d, 0xd5, 0xc8, 0x37, 0x30, 0xe5, 0x5f, 0x75, 0x0c, 0xab, 0x43, 0x46, 0xa3, 0x22, 0x64, 0x28,
	0x39, 0x93, 0x59, 0xc8, 0x86, 0xe8, 0x17, 0xa0, 0xc6, 0x2e, 0x92, 0xd7, 0x61, 0x69, 0xba, 0x6b,
	0x8c, 0x81, 0x82, 0xfe, 0x77, 0x05, 0xd4, 0xf8, 0x03, 0xb3, 0xa6, 0x83, 0xfd, 0x16, 0x09, 0x4c,
	0xc7, 0xe6, 0x1c, 0xaa, 0x91, 0x17, 0x0b, 0x07, 0x36, 0xba, 0x0f, 0x50, 0x0f, 0xfb, 0x66, 0x9b,
	0xf4, 0x48, 0x9b, 0x6a, 0xf3, 0x7c, 0xbb, 0x97, 0x13, 0x4c, 0x71, 0x37, 0xd1, 0xab, 0x96, 0x0f,
	0x99, 0x90, 0xa1, 0xd6, 0xc3, 0x3e, 0x1f, 0x51, 0xf4, 0x4b, 0x28, 0x50, 0xd2, 0x6e, 0x47, 0xda,
	0x99, 0x19, 0xb4, 0x81, 0x29, 0x08, 0x75, 0xfd, 0xad, 0x02, 0x85, 0x44, 0x69, 0x40, 0x1a, 0x2c,
	0xca, 0x2c, 0x96, 0x66, 0x46, 0x53, 0xd4, 0x80, 0x7c, 0x5c, 0x68, 0x84, 0x8d, 0x17, 0xcb, 0xa2,
	0xaf, 0x2a, 0xb3, 0xbe, 0xaa, 0x2c, 0xfb, 0xaa, 0xf2, 0x63, 0xcf, 0x71, 0x6b, 0x77, 0xdf, 0x7d,
	0xd8, 0x9e, 0xfb, 0xc7, 0x57, 0xdb, 0x7b, 0x0d, 0x27, 0x68, 0x86, 0xf5, 0xb2, 0xe5, 0x75, 0x2a,
	0xb2, 0x09, 0x13, 0x3f, 0x77, 0xa8, 0xdd, 0xaa, 0x04, 0xfd, 0x2e, 0xa1, 0x5c, 0x81, 0x1a, 0x31,
	0xb8, 0xfe, 0x67, 0x05, 0xd0, 0x68, 0x81, 0x41, 0xd7, 0x60, 0x39, 0x51, 0xa6, 0x62, 0x37, 0x2e,
	0x0d, 0x16, 0x0f, 0x6c, 0xf4, 0x1c, 0xf2, 0x71, 0x01, 0x13, 0x46, 0xde, 0x98, 0xad, 0x80, 0xf1,
	0xd2, 0x3d, 0x67, 0xc4, 0xda, 0xba, 0x03, 0x6b, 0x23, 0x42, 0x68, 0x03, 0xb2, 0x36, 0x71, 0xbd,
	0x8e, 0xe4, 0x16, 0x13, 0xf4, 0x00, 0x16, 0xa5, 0xda, 0x98, 0x30, 0x49, 0xba, 0x3f, 0xcd, 0x15,
	0x29, 0xe9, 0xff, 0x54, 0x60, 0x75, 0xa8, 0xd6, 0xa0, 0x07, 0x90, 0xa3, 0x01, 0x0e, 0x42, 0xca,
	0xa9, 0x56, 0x26, 0xde, 0x40, 0xb1, 0xc6, 0x11, 0x97, 0x36, 0xa4, 0x16, 0xbb, 0x3a, 0x78, 0x2c,
	0x9a, 0x4d, 0x4c, 0x9b, 0xdc, 0x2c, 0x55, 0x46, 0xe7, 0x73, 0x4c, 0x9b, 0x2c, 0xda, 0x2d, 0xc7,
	0xe6, 0x9d, 0x97, 0x6a, 0xb0, 0x21, 0xfa, 0x31, 0x64, 0xf9, 0x67, 0xd9, 0x30, 0x95, 0xa6, 0x57,
	0x44, 0x43, 0x08, 0xeb, 0x2d, 0x50, 0xe3, 0xb5, 0xe9, 0x41, 0xfe, 0x28, 0xc2, 0x17, 0x2e, 0xba,
	0x3e, 0xc1, 0x45, 0x0c, 0xed, 0xd0, 0xe9, 0x38, 0x02, 0x52, 0x7a, 0x4a, 0x92, 0xfd, 0x5b, 0x81,
	0x0b, 0x63, 0xcb, 0xe8, 0xf7, 0xef, 0xad, 0x9f, 0xa7, 0xbd, 0xb5, 0x3b, 0x4b, 0xc9, 0x8f, 0xb6,
	0xf1, 0x37, 0x05, 0x56, 0x87, 0x3e, 0x4d, 0x77, 0xdd, 0xb3, 0xb4, 0xeb, 0x6e, 0x4f, 0x8c, 0xae,
	0x08, 0x73, 0x82, 0x03, 0x19, 0x8b, 0x43, 0x4d, 0x81, 0xcb, 0x77, 0x93, 0x37, 0xf2, 0x0e, 0x7d,
	0xc1, 0xe7, 0xfa, 0x5f, 0x32, 0x90, 0x8f, 0xea, 0xf1, 0x74, 0x7b, 0x46, 0x32, 0x71, 0x7e, 0x4c,
	0x26, 0x6e, 0x42, 0xce, 0xa1, 0x87, 0x9e, 0xdb, 0x90, 0x44, 0x72, 0x86, 0x1e, 0x42, 0xfe, 0x2c,
	0xc4, 0x6e, 0xe0, 0x04, 0x7d, 0xee, 0x3c, 0xb5, 0x76, 0x8d, 0x99, 0xf8, 0xbf, 0x0f, 0xdb, 0x97,
	0x44, 0x65, 0xa0, 0x76, 0xab, 0xec, 0x78, 0x95, 0x0e, 0x0e, 0x9a, 0xe5, 0x43, 0xd2, 0xc0, 0x56,
	0x7f, 0x9f, 0x58, 0x46, 0xac, 0x84, 0xf6, 0xa1, 0x40, 0xdc, 0xc0, 0xef, 0xcb, 0xd2, 0x9e, 0x9d,
	0x1d, 0x03, 0xb8, 0x1e, 0xbf, 0x01, 0xd0, 0x7d, 0xc8, 0x75, 0xb0, 0xdf, 0x70, 0x5c, 0xde, 0x66,
	0xcf, 0x08, 0x20, 0x55, 0xd0, 0x1f, 0x40, 0xb3, 0xc2, 0x4e, 0xd8, 0x16, 0xf7, 0xe8, 0x69, 0xe8,
	0xda, 0x8e, 0xdb, 0x30, 0x39, 0x3a, 0x6f, 0xaa, 0x67, 0x84, 0xdb, 0x1c, 0x80, 0x3c, 0x15, 0x18,
	0x4f, 0x18, 0x84, 0x1e, 0x40, 0x21, 0x71, 0xaf, 0x31, 0x4f, 0xd2, 0x7e, 0xa7, 0xee, 0xb5, 0xe5,
	0x41, 0xc8, 0x19, 0xfa, 0x19, 0x64, 0x85, 0x0b, 0xe6, 0x67, 0xa7, 0x14, 0x1a, 0x08, 0xc1, 0x02,
	0xab, 0xbd, 0x32, 0xa2, 0xf9, 0x58, 0xff, 0x57, 0x46, 0xe4, 0x32, 0xef, 0x93, 0xa6, 0x07, 0xc0,
	0x05, 0x76, 0xb6, 0x66, 0x3d, 0xec, 0x73, 0xea, 0xbc, 0x91, 0x75, 0x68, 0x2d, 0xec, 0xa3, 0x5d,
	0x58, 0x26, 0x6f, 0x88, 0x15, 0xb2, 0x08, 0x3a, 0x1e, 0xc0, 0xa7, 0x17, 0xbf, 0x7d, 0x00, 0xc4,
	0xfb, 0xce, 0x9e, 0x7b, 0xdf, 0x23, 0x91, 0x9b, 0x1b, 0x13, 0xb9, 0x3f, 0x81, 0xcc, 0x29, 0x21,
	0xe7, 0x39, 0x48, 0x26, 0x3f, 0x54, 0x43, 0xf2, 0xc3, 0x35, 0xe4, 0xa7, 0x70, 0xe1, 0x94, 0x10,
	0xd3, 0x27, 0x96, 0xd3, 0x75, 0x88, 0x1b, 0x98, 0xd8, 0xb6, 0x7d, 0x42, 0x29, 0xff, 0xef, 0xa2,
	0xca, 0x7f, 0x0e, 0xeb, 0xa7, 0x84, 0x18, 0x91, 0xc4, 0x23, 0x21, 0x10, 0x55, 0x1f, 0x18, 0x54,
	0x9f, 0x8b, 0x90, 0xe7, 0xbd, 0x30, 0xdb, 0x41, 0x41, 0xdc, 0xd2, 0x7c, 0x7e, 0x60, 0xeb, 0xff,
	0xc9, 0x24, 0x8b, 0xcb, 0x77, 0x7d, 0x96, 0x23, 0xfe, 0x5c, 0x18, 0xe3, 0xcf, 0x5f, 0xc1, 0x4a,
	0xd4, 0xdd, 0x99, 0x36, 0x69, 0x07, 0x58, 0xfe, 0x6d, 0xde, 0x9d, 0x50, 0xc7, 0xa2, 0x22, 0xb4,
	0xcf, 0x64, 0x8d, 0xe5, 0x6e, 0x72, 0xca, 0xf2, 0xb6, 0x8b, 0xfb, 0x5e, 0x18, 0x9c, 0x2b, 0x6f,
	0x85, 0xca, 0x0f, 0xfb, 0x64, 0x8f, 0x61, 0x29, 0xf5, 0x22, 0x71, 0x1d, 0x56, 0x52, 0xbe, 0x67,
	0x77, 0x5f, 0x86, 0x1d, 0x51, 0xd2, 0xf9, 0xfc, 0x6a, 0x8b, 0x0f, 0x5f, 0xf4, 0x44, 0xaa, 0xa1,
	0x46, 0xa7, 0x4f, 0xf5, 0x57, 0xb0, 0x3a, 0xf4, 0x07, 0xf9, 0x0b, 0x01, 0x1f, 0xc3, 0x52, 0xea,
	0x19, 0xe2, 0xcb, 0xa0, 0xde, 0x4d, 0x34, 0xee, 0x12, 0x38, 0xad, 0xa1, 0x8c, 0x6a, 0xa0, 0xd1,
	0x57, 0x31, 0xb4, 0x05, 0x79, 0x49, 0x1a, 0xa9, 0xc4, 0x73, 0xfd, 0x11, 0x68, 0x93, 0x1e, 0xb8,
	0x66, 0xdc, 0x85, 0x7e, 0x1b, 0xd6, 0x46, 0x1e, 0x07, 0x52, 0x75, 0x3c, 0x33, 0xa8, 0xe3, 0xb7,
	0x0e, 0x99, 0xf0, 0x50, 0x67, 0x82, 0x56, 0xa1, 0x70, 0xe2, 0xd2, 0x2e, 0xb1, 0x9c, 0x53, 0x87,
	0xd8, 0xc5, 0x39, 0x04, 0x90, 0xab, 0x79, 0x5e, 0x8b, 0xd8, 0x45, 0x05, 0x15, 0x60, 0xf1, 0x05,
	0x0e, 0xac, 0x26, 0xb1, 0x8b, 0xf3, 0x68, 0x19, 0xd4, 0xc7, 0x6c, 0x6b, 0xed, 0x36, 0xb1, 0x8b,
	0x99, 0xaa, 0x09, 0x39, 0xf1, 0xd0, 0x80, 0x4e, 0x20, 0x2f, 0x46, 0xbf, 0xad, 0x22, 0x7d, 0x7c,
	0x3b, 0x97, 0x7c, 0x70, 0xdc, 0xba, 0x36, 0x55, 0x46, 0xbc, 0x5a, 0xdc, 0x55, 0x6a, 0xf8, 0xdd,
	0xc7, 0x92, 0xf2, 0xfe, 0x63, 0x49, 0xf9, 0xfa, 0x63, 0x49, 0x79, 0xfb, 0xa9, 0x34, 0xf7, 0xfe,
	0x53, 0x69, 0xee, 0xbf, 0x9f, 0x4a, 0x73, 0xaf, 0x9f, 0x25, 0x9a, 0xfd, 0x83, 0x08, 0xea, 0x10,
	0xd7, 0x69, 0x25, 0x06, 0xbe, 0x63, 0x79, 0x3e, 0x49, 0x4e, 0x9b, 0xd8, 0x71, 0xa3, 0xa7, 0x5c,
	0xfe, 0x77, 0xa0, 0xd2, 0xab, 0xd6, 0x73, 0xfc, 0x4d, 0xf4, 0x47, 0xdf, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x06, 0x95, 0x51, 0x5c, 0xee, 0x15, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StreamClient is the client API for Stream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamClient interface {
	StreamV2(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (Stream_StreamV2Client, error)
}

type streamClient struct {
	cc grpc1.ClientConn
}

func NewStreamClient(cc grpc1.ClientConn) StreamClient {
	return &streamClient{cc}
}

func (c *streamClient) StreamV2(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (Stream_StreamV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_Stream_serviceDesc.Streams[0], "/injective.stream.v2.Stream/StreamV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamStreamV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stream_StreamV2Client interface {
	Recv() (*StreamResponse, error)
	grpc.ClientStream
}

type streamStreamV2Client struct {
	grpc.ClientStream
}

func (x *streamStreamV2Client) Recv() (*StreamResponse, error) {
	m := new(StreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamServer is the server API for Stream service.
type StreamServer interface {
	StreamV2(*StreamRequest, Stream_StreamV2Server) error
}

// UnimplementedStreamServer can be embedded to have forward compatible implementations.
type UnimplementedStreamServer struct {
}

func (*UnimplementedStreamServer) StreamV2(req *StreamRequest, srv Stream_StreamV2Server) error {
	return status.Errorf(codes.Unimplemented, "method StreamV2 not implemented")
}

func RegisterStreamServer(s grpc1.Server, srv StreamServer) {
	s.RegisterService(&_Stream_serviceDesc, srv)
}

func _Stream_StreamV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamServer).StreamV2(m, &streamStreamV2Server{stream})
}

type Stream_StreamV2Server interface {
	Send(*StreamResponse) error
	grpc.ServerStream
}

type streamStreamV2Server struct {
	grpc.ServerStream
}

func (x *streamStreamV2Server) Send(m *StreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Stream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "injective.stream.v2.Stream",
	HandlerType: (*StreamServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamV2",
			Handler:       _Stream_StreamV2_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "injective/stream/v2/query.proto",
}

func (m *StreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OraclePriceFilter != nil {
		{
			size, err := m.OraclePriceFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PositionsFilter != nil {
		{
			size, err := m.PositionsFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DerivativeOrderbooksFilter != nil {
		{
			size, err := m.DerivativeOrderbooksFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SpotOrderbooksFilter != nil {
		{
			size, err := m.SpotOrderbooksFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DerivativeOrdersFilter != nil {
		{
			size, err := m.DerivativeOrdersFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SpotOrdersFilter != nil {
		{
			size, err := m.SpotOrdersFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DerivativeTradesFilter != nil {
		{
			size, err := m.DerivativeTradesFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SpotTradesFilter != nil {
		{
			size, err := m.SpotTradesFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SubaccountDepositsFilter != nil {
		{
			size, err := m.SubaccountDepositsFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BankBalancesFilter != nil {
		{
			size, err := m.BankBalancesFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GasPrice) > 0 {
		i -= len(m.GasPrice)
		copy(dAtA[i:], m.GasPrice)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.GasPrice)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.OraclePrices) > 0 {
		for iNdEx := len(m.OraclePrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OraclePrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DerivativeOrderbookUpdates) > 0 {
		for iNdEx := len(m.DerivativeOrderbookUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrderbookUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.SpotOrderbookUpdates) > 0 {
		for iNdEx := len(m.SpotOrderbookUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrderbookUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.DerivativeOrders) > 0 {
		for iNdEx := len(m.DerivativeOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SpotOrders) > 0 {
		for iNdEx := len(m.SpotOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DerivativeTrades) > 0 {
		for iNdEx := len(m.DerivativeTrades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeTrades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SpotTrades) > 0 {
		for iNdEx := len(m.SpotTrades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotTrades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SubaccountDeposits) > 0 {
		for iNdEx := len(m.SubaccountDeposits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubaccountDeposits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.BankBalances) > 0 {
		for iNdEx := len(m.BankBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BankBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BlockTime != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderbookUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderbookUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderbookUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Orderbook != nil {
		{
			size, err := m.Orderbook.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Orderbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Orderbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Orderbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SellLevels) > 0 {
		for iNdEx := len(m.SellLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SellLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BuyLevels) > 0 {
		for iNdEx := len(m.BuyLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuyLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BankBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BankBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubaccountDeposits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountDeposits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountDeposits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposits) > 0 {
		for iNdEx := len(m.Deposits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deposits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubaccountDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Deposit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotOrderUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotOrderUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotOrderUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeOrderUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeOrderUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeOrderUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMarket {
		i--
		if m.IsMarket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CumulativeFundingEntry.Size()
		i -= size
		if _, err := m.CumulativeFundingEntry.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Margin.Size()
		i -= size
		if _, err := m.Margin.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.EntryPrice.Size()
		i -= size
		if _, err := m.EntryPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.IsLong {
		i--
		if m.IsLong {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OraclePrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradeId) > 0 {
		i -= len(m.TradeId)
		copy(dAtA[i:], m.TradeId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TradeId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ExecutionType) > 0 {
		i -= len(m.ExecutionType)
		copy(dAtA[i:], m.ExecutionType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExecutionType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradeId) > 0 {
		i -= len(m.TradeId)
		copy(dAtA[i:], m.TradeId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TradeId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Payout.Size()
		i -= size
		if _, err := m.Payout.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.PositionDelta != nil {
		{
			size, err := m.PositionDelta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExecutionType) > 0 {
		i -= len(m.ExecutionType)
		copy(dAtA[i:], m.ExecutionType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExecutionType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradesFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradesFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradesFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PositionsFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionsFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionsFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrdersFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrdersFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrdersFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderbookFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderbookFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderbookFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BankBalancesFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankBalancesFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BankBalancesFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Accounts[iNdEx])
			copy(dAtA[i:], m.Accounts[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Accounts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubaccountDepositsFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountDepositsFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountDepositsFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OraclePriceFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePriceFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePriceFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Symbol) > 0 {
		for iNdEx := len(m.Symbol) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Symbol[iNdEx])
			copy(dAtA[i:], m.Symbol[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Symbol[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BankBalancesFilter != nil {
		l = m.BankBalancesFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SubaccountDepositsFilter != nil {
		l = m.SubaccountDepositsFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SpotTradesFilter != nil {
		l = m.SpotTradesFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DerivativeTradesFilter != nil {
		l = m.DerivativeTradesFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SpotOrdersFilter != nil {
		l = m.SpotOrdersFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DerivativeOrdersFilter != nil {
		l = m.DerivativeOrdersFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SpotOrderbooksFilter != nil {
		l = m.SpotOrderbooksFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DerivativeOrderbooksFilter != nil {
		l = m.DerivativeOrderbooksFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.PositionsFilter != nil {
		l = m.PositionsFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.OraclePriceFilter != nil {
		l = m.OraclePriceFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *StreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovQuery(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovQuery(uint64(m.BlockTime))
	}
	if len(m.BankBalances) > 0 {
		for _, e := range m.BankBalances {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SubaccountDeposits) > 0 {
		for _, e := range m.SubaccountDeposits {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SpotTrades) > 0 {
		for _, e := range m.SpotTrades {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.DerivativeTrades) > 0 {
		for _, e := range m.DerivativeTrades {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SpotOrders) > 0 {
		for _, e := range m.SpotOrders {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.DerivativeOrders) > 0 {
		for _, e := range m.DerivativeOrders {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SpotOrderbookUpdates) > 0 {
		for _, e := range m.SpotOrderbookUpdates {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.DerivativeOrderbookUpdates) > 0 {
		for _, e := range m.DerivativeOrderbookUpdates {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.OraclePrices) > 0 {
		for _, e := range m.OraclePrices {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *OrderbookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovQuery(uint64(m.Seq))
	}
	if m.Orderbook != nil {
		l = m.Orderbook.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *Orderbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.BuyLevels) > 0 {
		for _, e := range m.BuyLevels {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SellLevels) > 0 {
		for _, e := range m.SellLevels {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *BankBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *SubaccountDeposits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Deposits) > 0 {
		for _, e := range m.Deposits {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *SubaccountDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Deposit.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *SpotOrderUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *SpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *DerivativeOrderUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.IsMarket {
		n += 2
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsLong {
		n += 2
	}
	l = m.Quantity.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.EntryPrice.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Margin.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.CumulativeFundingEntry.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *OraclePrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *SpotTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsBuy {
		n += 2
	}
	l = len(m.ExecutionType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Quantity.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Price.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Fee.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TradeId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DerivativeTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsBuy {
		n += 2
	}
	l = len(m.ExecutionType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.PositionDelta != nil {
		l = m.PositionDelta.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Payout.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TradeId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *TradesFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *PositionsFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *OrdersFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *OrderbookFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *BankBalancesFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, s := range m.Accounts {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *SubaccountDepositsFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *OraclePriceFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Symbol) > 0 {
		for _, s := range m.Symbol {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankBalancesFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BankBalancesFilter == nil {
				m.BankBalancesFilter = &BankBalancesFilter{}
			}
			if err := m.BankBalancesFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountDepositsFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubaccountDepositsFilter == nil {
				m.SubaccountDepositsFilter = &SubaccountDepositsFilter{}
			}
			if err := m.SubaccountDepositsFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotTradesFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpotTradesFilter == nil {
				m.SpotTradesFilter = &TradesFilter{}
			}
			if err := m.SpotTradesFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeTradesFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DerivativeTradesFilter == nil {
				m.DerivativeTradesFilter = &TradesFilter{}
			}
			if err := m.DerivativeTradesFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrdersFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpotOrdersFilter == nil {
				m.SpotOrdersFilter = &OrdersFilter{}
			}
			if err := m.SpotOrdersFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrdersFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DerivativeOrdersFilter == nil {
				m.DerivativeOrdersFilter = &OrdersFilter{}
			}
			if err := m.DerivativeOrdersFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrderbooksFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpotOrderbooksFilter == nil {
				m.SpotOrderbooksFilter = &OrderbookFilter{}
			}
			if err := m.SpotOrderbooksFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrderbooksFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DerivativeOrderbooksFilter == nil {
				m.DerivativeOrderbooksFilter = &OrderbookFilter{}
			}
			if err := m.DerivativeOrderbooksFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionsFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionsFilter == nil {
				m.PositionsFilter = &PositionsFilter{}
			}
			if err := m.PositionsFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OraclePriceFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OraclePriceFilter == nil {
				m.OraclePriceFilter = &OraclePriceFilter{}
			}
			if err := m.OraclePriceFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankBalances = append(m.BankBalances, &BankBalance{})
			if err := m.BankBalances[len(m.BankBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountDeposits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountDeposits = append(m.SubaccountDeposits, &SubaccountDeposits{})
			if err := m.SubaccountDeposits[len(m.SubaccountDeposits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotTrades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotTrades = append(m.SpotTrades, &SpotTrade{})
			if err := m.SpotTrades[len(m.SpotTrades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeTrades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeTrades = append(m.DerivativeTrades, &DerivativeTrade{})
			if err := m.DerivativeTrades[len(m.DerivativeTrades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrders = append(m.SpotOrders, &SpotOrderUpdate{})
			if err := m.SpotOrders[len(m.SpotOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrders = append(m.DerivativeOrders, &DerivativeOrderUpdate{})
			if err := m.DerivativeOrders[len(m.DerivativeOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrderbookUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrderbookUpdates = append(m.SpotOrderbookUpdates, &OrderbookUpdate{})
			if err := m.SpotOrderbookUpdates[len(m.SpotOrderbookUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrderbookUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrderbookUpdates = append(m.DerivativeOrderbookUpdates, &OrderbookUpdate{})
			if err := m.DerivativeOrderbookUpdates[len(m.DerivativeOrderbookUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &Position{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OraclePrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OraclePrices = append(m.OraclePrices, &OraclePrice{})
			if err := m.OraclePrices[len(m.OraclePrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderbookUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderbookUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderbookUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orderbook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Orderbook == nil {
				m.Orderbook = &Orderbook{}
			}
			if err := m.Orderbook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Orderbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Orderbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Orderbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyLevels = append(m.BuyLevels, &v2.Level{})
			if err := m.BuyLevels[len(m.BuyLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SellLevels = append(m.SellLevels, &v2.Level{})
			if err := m.SellLevels[len(m.SellLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, types.Coin{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountDeposits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountDeposits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountDeposits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposits = append(m.Deposits, SubaccountDeposit{})
			if err := m.Deposits[len(m.Deposits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotOrderUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotOrderUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotOrderUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderUpdateStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &SpotOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeOrderUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeOrderUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeOrderUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderUpdateStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &DerivativeOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMarket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMarket = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLong", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLong = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EntryPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Margin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeFundingEntry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CumulativeFundingEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionDelta == nil {
				m.PositionDelta = &v2.PositionDelta{}
			}
			if err := m.PositionDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Payout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradesFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradesFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradesFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionsFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionsFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionsFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrdersFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrdersFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrdersFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderbookFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderbookFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderbookFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankBalancesFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankBalancesFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankBalancesFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountDepositsFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountDepositsFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountDepositsFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePriceFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePriceFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePriceFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = append(m.Symbol, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
