// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/stream/v1beta1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	types "github.com/InjectiveLabs/sdk-go/chain/exchange/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OrderUpdateStatus int32

const (
	OrderUpdateStatus_Unspecified OrderUpdateStatus = 0
	OrderUpdateStatus_Booked      OrderUpdateStatus = 1
	OrderUpdateStatus_Matched     OrderUpdateStatus = 2
	OrderUpdateStatus_Cancelled   OrderUpdateStatus = 3
)

var OrderUpdateStatus_name = map[int32]string{
	0: "Unspecified",
	1: "Booked",
	2: "Matched",
	3: "Cancelled",
}

var OrderUpdateStatus_value = map[string]int32{
	"Unspecified": 0,
	"Booked":      1,
	"Matched":     2,
	"Cancelled":   3,
}

func (x OrderUpdateStatus) String() string {
	return proto.EnumName(OrderUpdateStatus_name, int32(x))
}

func (OrderUpdateStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{0}
}

type StreamRequest struct {
	BankBalancesFilter         *BankBalancesFilter       `protobuf:"bytes,1,opt,name=bank_balances_filter,json=bankBalancesFilter,proto3" json:"bank_balances_filter,omitempty"`
	SubaccountDepositsFilter   *SubaccountDepositsFilter `protobuf:"bytes,2,opt,name=subaccount_deposits_filter,json=subaccountDepositsFilter,proto3" json:"subaccount_deposits_filter,omitempty"`
	SpotTradesFilter           *TradesFilter             `protobuf:"bytes,3,opt,name=spot_trades_filter,json=spotTradesFilter,proto3" json:"spot_trades_filter,omitempty"`
	DerivativeTradesFilter     *TradesFilter             `protobuf:"bytes,4,opt,name=derivative_trades_filter,json=derivativeTradesFilter,proto3" json:"derivative_trades_filter,omitempty"`
	SpotOrdersFilter           *OrdersFilter             `protobuf:"bytes,5,opt,name=spot_orders_filter,json=spotOrdersFilter,proto3" json:"spot_orders_filter,omitempty"`
	DerivativeOrdersFilter     *OrdersFilter             `protobuf:"bytes,6,opt,name=derivative_orders_filter,json=derivativeOrdersFilter,proto3" json:"derivative_orders_filter,omitempty"`
	SpotOrderbooksFilter       *OrderbookFilter          `protobuf:"bytes,7,opt,name=spot_orderbooks_filter,json=spotOrderbooksFilter,proto3" json:"spot_orderbooks_filter,omitempty"`
	DerivativeOrderbooksFilter *OrderbookFilter          `protobuf:"bytes,8,opt,name=derivative_orderbooks_filter,json=derivativeOrderbooksFilter,proto3" json:"derivative_orderbooks_filter,omitempty"`
	PositionsFilter            *PositionsFilter          `protobuf:"bytes,9,opt,name=positions_filter,json=positionsFilter,proto3" json:"positions_filter,omitempty"`
	OraclePriceFilter          *OraclePriceFilter        `protobuf:"bytes,10,opt,name=oracle_price_filter,json=oraclePriceFilter,proto3" json:"oracle_price_filter,omitempty"`
}

func (m *StreamRequest) Reset()         { *m = StreamRequest{} }
func (m *StreamRequest) String() string { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()    {}
func (*StreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{0}
}
func (m *StreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamRequest.Merge(m, src)
}
func (m *StreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamRequest proto.InternalMessageInfo

func (m *StreamRequest) GetBankBalancesFilter() *BankBalancesFilter {
	if m != nil {
		return m.BankBalancesFilter
	}
	return nil
}

func (m *StreamRequest) GetSubaccountDepositsFilter() *SubaccountDepositsFilter {
	if m != nil {
		return m.SubaccountDepositsFilter
	}
	return nil
}

func (m *StreamRequest) GetSpotTradesFilter() *TradesFilter {
	if m != nil {
		return m.SpotTradesFilter
	}
	return nil
}

func (m *StreamRequest) GetDerivativeTradesFilter() *TradesFilter {
	if m != nil {
		return m.DerivativeTradesFilter
	}
	return nil
}

func (m *StreamRequest) GetSpotOrdersFilter() *OrdersFilter {
	if m != nil {
		return m.SpotOrdersFilter
	}
	return nil
}

func (m *StreamRequest) GetDerivativeOrdersFilter() *OrdersFilter {
	if m != nil {
		return m.DerivativeOrdersFilter
	}
	return nil
}

func (m *StreamRequest) GetSpotOrderbooksFilter() *OrderbookFilter {
	if m != nil {
		return m.SpotOrderbooksFilter
	}
	return nil
}

func (m *StreamRequest) GetDerivativeOrderbooksFilter() *OrderbookFilter {
	if m != nil {
		return m.DerivativeOrderbooksFilter
	}
	return nil
}

func (m *StreamRequest) GetPositionsFilter() *PositionsFilter {
	if m != nil {
		return m.PositionsFilter
	}
	return nil
}

func (m *StreamRequest) GetOraclePriceFilter() *OraclePriceFilter {
	if m != nil {
		return m.OraclePriceFilter
	}
	return nil
}

type StreamResponse struct {
	BlockHeight                uint64                   `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	BlockTime                  int64                    `protobuf:"varint,2,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	BankBalances               []*BankBalance           `protobuf:"bytes,3,rep,name=bank_balances,json=bankBalances,proto3" json:"bank_balances,omitempty"`
	SubaccountDeposits         []*SubaccountDeposits    `protobuf:"bytes,4,rep,name=subaccount_deposits,json=subaccountDeposits,proto3" json:"subaccount_deposits,omitempty"`
	SpotTrades                 []*SpotTrade             `protobuf:"bytes,5,rep,name=spot_trades,json=spotTrades,proto3" json:"spot_trades,omitempty"`
	DerivativeTrades           []*DerivativeTrade       `protobuf:"bytes,6,rep,name=derivative_trades,json=derivativeTrades,proto3" json:"derivative_trades,omitempty"`
	SpotOrders                 []*SpotOrderUpdate       `protobuf:"bytes,7,rep,name=spot_orders,json=spotOrders,proto3" json:"spot_orders,omitempty"`
	DerivativeOrders           []*DerivativeOrderUpdate `protobuf:"bytes,8,rep,name=derivative_orders,json=derivativeOrders,proto3" json:"derivative_orders,omitempty"`
	SpotOrderbookUpdates       []*OrderbookUpdate       `protobuf:"bytes,9,rep,name=spot_orderbook_updates,json=spotOrderbookUpdates,proto3" json:"spot_orderbook_updates,omitempty"`
	DerivativeOrderbookUpdates []*OrderbookUpdate       `protobuf:"bytes,10,rep,name=derivative_orderbook_updates,json=derivativeOrderbookUpdates,proto3" json:"derivative_orderbook_updates,omitempty"`
	Positions                  []*Position              `protobuf:"bytes,11,rep,name=positions,proto3" json:"positions,omitempty"`
	OraclePrices               []*OraclePrice           `protobuf:"bytes,12,rep,name=oracle_prices,json=oraclePrices,proto3" json:"oracle_prices,omitempty"`
}

func (m *StreamResponse) Reset()         { *m = StreamResponse{} }
func (m *StreamResponse) String() string { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()    {}
func (*StreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{1}
}
func (m *StreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamResponse.Merge(m, src)
}
func (m *StreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamResponse proto.InternalMessageInfo

func (m *StreamResponse) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *StreamResponse) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *StreamResponse) GetBankBalances() []*BankBalance {
	if m != nil {
		return m.BankBalances
	}
	return nil
}

func (m *StreamResponse) GetSubaccountDeposits() []*SubaccountDeposits {
	if m != nil {
		return m.SubaccountDeposits
	}
	return nil
}

func (m *StreamResponse) GetSpotTrades() []*SpotTrade {
	if m != nil {
		return m.SpotTrades
	}
	return nil
}

func (m *StreamResponse) GetDerivativeTrades() []*DerivativeTrade {
	if m != nil {
		return m.DerivativeTrades
	}
	return nil
}

func (m *StreamResponse) GetSpotOrders() []*SpotOrderUpdate {
	if m != nil {
		return m.SpotOrders
	}
	return nil
}

func (m *StreamResponse) GetDerivativeOrders() []*DerivativeOrderUpdate {
	if m != nil {
		return m.DerivativeOrders
	}
	return nil
}

func (m *StreamResponse) GetSpotOrderbookUpdates() []*OrderbookUpdate {
	if m != nil {
		return m.SpotOrderbookUpdates
	}
	return nil
}

func (m *StreamResponse) GetDerivativeOrderbookUpdates() []*OrderbookUpdate {
	if m != nil {
		return m.DerivativeOrderbookUpdates
	}
	return nil
}

func (m *StreamResponse) GetPositions() []*Position {
	if m != nil {
		return m.Positions
	}
	return nil
}

func (m *StreamResponse) GetOraclePrices() []*OraclePrice {
	if m != nil {
		return m.OraclePrices
	}
	return nil
}

type OrderbookUpdate struct {
	Seq       uint64     `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Orderbook *Orderbook `protobuf:"bytes,2,opt,name=orderbook,proto3" json:"orderbook,omitempty"`
}

func (m *OrderbookUpdate) Reset()         { *m = OrderbookUpdate{} }
func (m *OrderbookUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderbookUpdate) ProtoMessage()    {}
func (*OrderbookUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{2}
}
func (m *OrderbookUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderbookUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderbookUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderbookUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderbookUpdate.Merge(m, src)
}
func (m *OrderbookUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderbookUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderbookUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderbookUpdate proto.InternalMessageInfo

func (m *OrderbookUpdate) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *OrderbookUpdate) GetOrderbook() *Orderbook {
	if m != nil {
		return m.Orderbook
	}
	return nil
}

type Orderbook struct {
	MarketId   string         `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	BuyLevels  []*types.Level `protobuf:"bytes,2,rep,name=buy_levels,json=buyLevels,proto3" json:"buy_levels,omitempty"`
	SellLevels []*types.Level `protobuf:"bytes,3,rep,name=sell_levels,json=sellLevels,proto3" json:"sell_levels,omitempty"`
}

func (m *Orderbook) Reset()         { *m = Orderbook{} }
func (m *Orderbook) String() string { return proto.CompactTextString(m) }
func (*Orderbook) ProtoMessage()    {}
func (*Orderbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{3}
}
func (m *Orderbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Orderbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Orderbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Orderbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Orderbook.Merge(m, src)
}
func (m *Orderbook) XXX_Size() int {
	return m.Size()
}
func (m *Orderbook) XXX_DiscardUnknown() {
	xxx_messageInfo_Orderbook.DiscardUnknown(m)
}

var xxx_messageInfo_Orderbook proto.InternalMessageInfo

func (m *Orderbook) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *Orderbook) GetBuyLevels() []*types.Level {
	if m != nil {
		return m.BuyLevels
	}
	return nil
}

func (m *Orderbook) GetSellLevels() []*types.Level {
	if m != nil {
		return m.SellLevels
	}
	return nil
}

type BankBalance struct {
	Account  string                                   `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	Balances github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=balances,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"balances"`
}

func (m *BankBalance) Reset()         { *m = BankBalance{} }
func (m *BankBalance) String() string { return proto.CompactTextString(m) }
func (*BankBalance) ProtoMessage()    {}
func (*BankBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{4}
}
func (m *BankBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BankBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BankBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BankBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BankBalance.Merge(m, src)
}
func (m *BankBalance) XXX_Size() int {
	return m.Size()
}
func (m *BankBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BankBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BankBalance proto.InternalMessageInfo

func (m *BankBalance) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *BankBalance) GetBalances() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Balances
	}
	return nil
}

type SubaccountDeposits struct {
	SubaccountId string              `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Deposits     []SubaccountDeposit `protobuf:"bytes,2,rep,name=deposits,proto3" json:"deposits"`
}

func (m *SubaccountDeposits) Reset()         { *m = SubaccountDeposits{} }
func (m *SubaccountDeposits) String() string { return proto.CompactTextString(m) }
func (*SubaccountDeposits) ProtoMessage()    {}
func (*SubaccountDeposits) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{5}
}
func (m *SubaccountDeposits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountDeposits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountDeposits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountDeposits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountDeposits.Merge(m, src)
}
func (m *SubaccountDeposits) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountDeposits) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountDeposits.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountDeposits proto.InternalMessageInfo

func (m *SubaccountDeposits) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *SubaccountDeposits) GetDeposits() []SubaccountDeposit {
	if m != nil {
		return m.Deposits
	}
	return nil
}

type SubaccountDeposit struct {
	Denom   string        `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Deposit types.Deposit `protobuf:"bytes,2,opt,name=deposit,proto3" json:"deposit"`
}

func (m *SubaccountDeposit) Reset()         { *m = SubaccountDeposit{} }
func (m *SubaccountDeposit) String() string { return proto.CompactTextString(m) }
func (*SubaccountDeposit) ProtoMessage()    {}
func (*SubaccountDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{6}
}
func (m *SubaccountDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountDeposit.Merge(m, src)
}
func (m *SubaccountDeposit) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountDeposit proto.InternalMessageInfo

func (m *SubaccountDeposit) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *SubaccountDeposit) GetDeposit() types.Deposit {
	if m != nil {
		return m.Deposit
	}
	return types.Deposit{}
}

type SpotOrderUpdate struct {
	Status    OrderUpdateStatus `protobuf:"varint,1,opt,name=status,proto3,enum=injective.stream.v1beta1.OrderUpdateStatus" json:"status,omitempty"`
	OrderHash []byte            `protobuf:"bytes,2,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Cid       string            `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
	Order     *SpotOrder        `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *SpotOrderUpdate) Reset()         { *m = SpotOrderUpdate{} }
func (m *SpotOrderUpdate) String() string { return proto.CompactTextString(m) }
func (*SpotOrderUpdate) ProtoMessage()    {}
func (*SpotOrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{7}
}
func (m *SpotOrderUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotOrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotOrderUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotOrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotOrderUpdate.Merge(m, src)
}
func (m *SpotOrderUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SpotOrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotOrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SpotOrderUpdate proto.InternalMessageInfo

func (m *SpotOrderUpdate) GetStatus() OrderUpdateStatus {
	if m != nil {
		return m.Status
	}
	return OrderUpdateStatus_Unspecified
}

func (m *SpotOrderUpdate) GetOrderHash() []byte {
	if m != nil {
		return m.OrderHash
	}
	return nil
}

func (m *SpotOrderUpdate) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *SpotOrderUpdate) GetOrder() *SpotOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type SpotOrder struct {
	MarketId string               `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Order    types.SpotLimitOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
}

func (m *SpotOrder) Reset()         { *m = SpotOrder{} }
func (m *SpotOrder) String() string { return proto.CompactTextString(m) }
func (*SpotOrder) ProtoMessage()    {}
func (*SpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{8}
}
func (m *SpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotOrder.Merge(m, src)
}
func (m *SpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *SpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SpotOrder proto.InternalMessageInfo

func (m *SpotOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *SpotOrder) GetOrder() types.SpotLimitOrder {
	if m != nil {
		return m.Order
	}
	return types.SpotLimitOrder{}
}

type DerivativeOrderUpdate struct {
	Status    OrderUpdateStatus `protobuf:"varint,1,opt,name=status,proto3,enum=injective.stream.v1beta1.OrderUpdateStatus" json:"status,omitempty"`
	OrderHash []byte            `protobuf:"bytes,2,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	Cid       string            `protobuf:"bytes,3,opt,name=cid,proto3" json:"cid,omitempty"`
	Order     *DerivativeOrder  `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *DerivativeOrderUpdate) Reset()         { *m = DerivativeOrderUpdate{} }
func (m *DerivativeOrderUpdate) String() string { return proto.CompactTextString(m) }
func (*DerivativeOrderUpdate) ProtoMessage()    {}
func (*DerivativeOrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{9}
}
func (m *DerivativeOrderUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeOrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeOrderUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeOrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeOrderUpdate.Merge(m, src)
}
func (m *DerivativeOrderUpdate) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeOrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeOrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeOrderUpdate proto.InternalMessageInfo

func (m *DerivativeOrderUpdate) GetStatus() OrderUpdateStatus {
	if m != nil {
		return m.Status
	}
	return OrderUpdateStatus_Unspecified
}

func (m *DerivativeOrderUpdate) GetOrderHash() []byte {
	if m != nil {
		return m.OrderHash
	}
	return nil
}

func (m *DerivativeOrderUpdate) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *DerivativeOrderUpdate) GetOrder() *DerivativeOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type DerivativeOrder struct {
	MarketId string                     `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Order    types.DerivativeLimitOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order"`
	IsMarket bool                       `protobuf:"varint,3,opt,name=is_market,json=isMarket,proto3" json:"is_market,omitempty"`
}

func (m *DerivativeOrder) Reset()         { *m = DerivativeOrder{} }
func (m *DerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*DerivativeOrder) ProtoMessage()    {}
func (*DerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{10}
}
func (m *DerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeOrder.Merge(m, src)
}
func (m *DerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeOrder proto.InternalMessageInfo

func (m *DerivativeOrder) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeOrder) GetOrder() types.DerivativeLimitOrder {
	if m != nil {
		return m.Order
	}
	return types.DerivativeLimitOrder{}
}

func (m *DerivativeOrder) GetIsMarket() bool {
	if m != nil {
		return m.IsMarket
	}
	return false
}

type Position struct {
	MarketId               string                                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	SubaccountId           string                                 `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	IsLong                 bool                                   `protobuf:"varint,3,opt,name=isLong,proto3" json:"isLong,omitempty"`
	Quantity               github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=quantity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"quantity"`
	EntryPrice             github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=entry_price,json=entryPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"entry_price"`
	Margin                 github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=margin,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"margin"`
	CumulativeFundingEntry github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=cumulative_funding_entry,json=cumulativeFundingEntry,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"cumulative_funding_entry"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{11}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *Position) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *Position) GetIsLong() bool {
	if m != nil {
		return m.IsLong
	}
	return false
}

type OraclePrice struct {
	Symbol string                                 `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Price  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=price,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"price"`
	Type   string                                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *OraclePrice) Reset()         { *m = OraclePrice{} }
func (m *OraclePrice) String() string { return proto.CompactTextString(m) }
func (*OraclePrice) ProtoMessage()    {}
func (*OraclePrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{12}
}
func (m *OraclePrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePrice.Merge(m, src)
}
func (m *OraclePrice) XXX_Size() int {
	return m.Size()
}
func (m *OraclePrice) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePrice.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePrice proto.InternalMessageInfo

func (m *OraclePrice) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *OraclePrice) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type SpotTrade struct {
	MarketId      string                                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsBuy         bool                                   `protobuf:"varint,2,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	ExecutionType string                                 `protobuf:"bytes,3,opt,name=executionType,proto3" json:"executionType,omitempty"`
	Quantity      github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=quantity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"quantity"`
	Price         github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=price,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"price"`
	// bytes32 subaccount ID that executed the trade
	SubaccountId        string                                 `protobuf:"bytes,6,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Fee                 github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=fee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"fee"`
	OrderHash           []byte                                 `protobuf:"bytes,8,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	FeeRecipientAddress string                                 `protobuf:"bytes,9,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	Cid                 string                                 `protobuf:"bytes,10,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *SpotTrade) Reset()         { *m = SpotTrade{} }
func (m *SpotTrade) String() string { return proto.CompactTextString(m) }
func (*SpotTrade) ProtoMessage()    {}
func (*SpotTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{13}
}
func (m *SpotTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotTrade.Merge(m, src)
}
func (m *SpotTrade) XXX_Size() int {
	return m.Size()
}
func (m *SpotTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotTrade.DiscardUnknown(m)
}

var xxx_messageInfo_SpotTrade proto.InternalMessageInfo

func (m *SpotTrade) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *SpotTrade) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *SpotTrade) GetExecutionType() string {
	if m != nil {
		return m.ExecutionType
	}
	return ""
}

func (m *SpotTrade) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *SpotTrade) GetOrderHash() []byte {
	if m != nil {
		return m.OrderHash
	}
	return nil
}

func (m *SpotTrade) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *SpotTrade) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

type DerivativeTrade struct {
	MarketId            string                                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsBuy               bool                                   `protobuf:"varint,2,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	ExecutionType       string                                 `protobuf:"bytes,3,opt,name=executionType,proto3" json:"executionType,omitempty"`
	SubaccountId        string                                 `protobuf:"bytes,4,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	PositionDelta       *types.PositionDelta                   `protobuf:"bytes,5,opt,name=position_delta,json=positionDelta,proto3" json:"position_delta,omitempty"`
	Payout              github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=payout,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"payout"`
	Fee                 github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=fee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"fee"`
	OrderHash           string                                 `protobuf:"bytes,8,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	FeeRecipientAddress string                                 `protobuf:"bytes,9,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	Cid                 string                                 `protobuf:"bytes,10,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *DerivativeTrade) Reset()         { *m = DerivativeTrade{} }
func (m *DerivativeTrade) String() string { return proto.CompactTextString(m) }
func (*DerivativeTrade) ProtoMessage()    {}
func (*DerivativeTrade) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{14}
}
func (m *DerivativeTrade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeTrade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeTrade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeTrade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeTrade.Merge(m, src)
}
func (m *DerivativeTrade) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeTrade) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeTrade.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeTrade proto.InternalMessageInfo

func (m *DerivativeTrade) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeTrade) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *DerivativeTrade) GetExecutionType() string {
	if m != nil {
		return m.ExecutionType
	}
	return ""
}

func (m *DerivativeTrade) GetSubaccountId() string {
	if m != nil {
		return m.SubaccountId
	}
	return ""
}

func (m *DerivativeTrade) GetPositionDelta() *types.PositionDelta {
	if m != nil {
		return m.PositionDelta
	}
	return nil
}

func (m *DerivativeTrade) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *DerivativeTrade) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *DerivativeTrade) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

type TradesFilter struct {
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
	MarketIds     []string `protobuf:"bytes,2,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *TradesFilter) Reset()         { *m = TradesFilter{} }
func (m *TradesFilter) String() string { return proto.CompactTextString(m) }
func (*TradesFilter) ProtoMessage()    {}
func (*TradesFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{15}
}
func (m *TradesFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradesFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradesFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradesFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradesFilter.Merge(m, src)
}
func (m *TradesFilter) XXX_Size() int {
	return m.Size()
}
func (m *TradesFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_TradesFilter.DiscardUnknown(m)
}

var xxx_messageInfo_TradesFilter proto.InternalMessageInfo

func (m *TradesFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

func (m *TradesFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type PositionsFilter struct {
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
	MarketIds     []string `protobuf:"bytes,2,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *PositionsFilter) Reset()         { *m = PositionsFilter{} }
func (m *PositionsFilter) String() string { return proto.CompactTextString(m) }
func (*PositionsFilter) ProtoMessage()    {}
func (*PositionsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{16}
}
func (m *PositionsFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionsFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionsFilter.Merge(m, src)
}
func (m *PositionsFilter) XXX_Size() int {
	return m.Size()
}
func (m *PositionsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PositionsFilter proto.InternalMessageInfo

func (m *PositionsFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

func (m *PositionsFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type OrdersFilter struct {
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
	MarketIds     []string `protobuf:"bytes,2,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *OrdersFilter) Reset()         { *m = OrdersFilter{} }
func (m *OrdersFilter) String() string { return proto.CompactTextString(m) }
func (*OrdersFilter) ProtoMessage()    {}
func (*OrdersFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{17}
}
func (m *OrdersFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrdersFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrdersFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrdersFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrdersFilter.Merge(m, src)
}
func (m *OrdersFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrdersFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrdersFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrdersFilter proto.InternalMessageInfo

func (m *OrdersFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

func (m *OrdersFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type OrderbookFilter struct {
	MarketIds []string `protobuf:"bytes,1,rep,name=market_ids,json=marketIds,proto3" json:"market_ids,omitempty"`
}

func (m *OrderbookFilter) Reset()         { *m = OrderbookFilter{} }
func (m *OrderbookFilter) String() string { return proto.CompactTextString(m) }
func (*OrderbookFilter) ProtoMessage()    {}
func (*OrderbookFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{18}
}
func (m *OrderbookFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderbookFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderbookFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderbookFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderbookFilter.Merge(m, src)
}
func (m *OrderbookFilter) XXX_Size() int {
	return m.Size()
}
func (m *OrderbookFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderbookFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OrderbookFilter proto.InternalMessageInfo

func (m *OrderbookFilter) GetMarketIds() []string {
	if m != nil {
		return m.MarketIds
	}
	return nil
}

type BankBalancesFilter struct {
	Accounts []string `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts,omitempty"`
}

func (m *BankBalancesFilter) Reset()         { *m = BankBalancesFilter{} }
func (m *BankBalancesFilter) String() string { return proto.CompactTextString(m) }
func (*BankBalancesFilter) ProtoMessage()    {}
func (*BankBalancesFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{19}
}
func (m *BankBalancesFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BankBalancesFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BankBalancesFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BankBalancesFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BankBalancesFilter.Merge(m, src)
}
func (m *BankBalancesFilter) XXX_Size() int {
	return m.Size()
}
func (m *BankBalancesFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_BankBalancesFilter.DiscardUnknown(m)
}

var xxx_messageInfo_BankBalancesFilter proto.InternalMessageInfo

func (m *BankBalancesFilter) GetAccounts() []string {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type SubaccountDepositsFilter struct {
	SubaccountIds []string `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
}

func (m *SubaccountDepositsFilter) Reset()         { *m = SubaccountDepositsFilter{} }
func (m *SubaccountDepositsFilter) String() string { return proto.CompactTextString(m) }
func (*SubaccountDepositsFilter) ProtoMessage()    {}
func (*SubaccountDepositsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{20}
}
func (m *SubaccountDepositsFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountDepositsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountDepositsFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountDepositsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountDepositsFilter.Merge(m, src)
}
func (m *SubaccountDepositsFilter) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountDepositsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountDepositsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountDepositsFilter proto.InternalMessageInfo

func (m *SubaccountDepositsFilter) GetSubaccountIds() []string {
	if m != nil {
		return m.SubaccountIds
	}
	return nil
}

type OraclePriceFilter struct {
	Symbol []string `protobuf:"bytes,1,rep,name=symbol,proto3" json:"symbol,omitempty"`
}

func (m *OraclePriceFilter) Reset()         { *m = OraclePriceFilter{} }
func (m *OraclePriceFilter) String() string { return proto.CompactTextString(m) }
func (*OraclePriceFilter) ProtoMessage()    {}
func (*OraclePriceFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e23b7dcfb2fbc9c7, []int{21}
}
func (m *OraclePriceFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePriceFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePriceFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePriceFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePriceFilter.Merge(m, src)
}
func (m *OraclePriceFilter) XXX_Size() int {
	return m.Size()
}
func (m *OraclePriceFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePriceFilter.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePriceFilter proto.InternalMessageInfo

func (m *OraclePriceFilter) GetSymbol() []string {
	if m != nil {
		return m.Symbol
	}
	return nil
}

func init() {
	proto.RegisterEnum("injective.stream.v1beta1.OrderUpdateStatus", OrderUpdateStatus_name, OrderUpdateStatus_value)
	proto.RegisterType((*StreamRequest)(nil), "injective.stream.v1beta1.StreamRequest")
	proto.RegisterType((*StreamResponse)(nil), "injective.stream.v1beta1.StreamResponse")
	proto.RegisterType((*OrderbookUpdate)(nil), "injective.stream.v1beta1.OrderbookUpdate")
	proto.RegisterType((*Orderbook)(nil), "injective.stream.v1beta1.Orderbook")
	proto.RegisterType((*BankBalance)(nil), "injective.stream.v1beta1.BankBalance")
	proto.RegisterType((*SubaccountDeposits)(nil), "injective.stream.v1beta1.SubaccountDeposits")
	proto.RegisterType((*SubaccountDeposit)(nil), "injective.stream.v1beta1.SubaccountDeposit")
	proto.RegisterType((*SpotOrderUpdate)(nil), "injective.stream.v1beta1.SpotOrderUpdate")
	proto.RegisterType((*SpotOrder)(nil), "injective.stream.v1beta1.SpotOrder")
	proto.RegisterType((*DerivativeOrderUpdate)(nil), "injective.stream.v1beta1.DerivativeOrderUpdate")
	proto.RegisterType((*DerivativeOrder)(nil), "injective.stream.v1beta1.DerivativeOrder")
	proto.RegisterType((*Position)(nil), "injective.stream.v1beta1.Position")
	proto.RegisterType((*OraclePrice)(nil), "injective.stream.v1beta1.OraclePrice")
	proto.RegisterType((*SpotTrade)(nil), "injective.stream.v1beta1.SpotTrade")
	proto.RegisterType((*DerivativeTrade)(nil), "injective.stream.v1beta1.DerivativeTrade")
	proto.RegisterType((*TradesFilter)(nil), "injective.stream.v1beta1.TradesFilter")
	proto.RegisterType((*PositionsFilter)(nil), "injective.stream.v1beta1.PositionsFilter")
	proto.RegisterType((*OrdersFilter)(nil), "injective.stream.v1beta1.OrdersFilter")
	proto.RegisterType((*OrderbookFilter)(nil), "injective.stream.v1beta1.OrderbookFilter")
	proto.RegisterType((*BankBalancesFilter)(nil), "injective.stream.v1beta1.BankBalancesFilter")
	proto.RegisterType((*SubaccountDepositsFilter)(nil), "injective.stream.v1beta1.SubaccountDepositsFilter")
	proto.RegisterType((*OraclePriceFilter)(nil), "injective.stream.v1beta1.OraclePriceFilter")
}

func init() {
	proto.RegisterFile("injective/stream/v1beta1/query.proto", fileDescriptor_e23b7dcfb2fbc9c7)
}

var fileDescriptor_e23b7dcfb2fbc9c7 = []byte{
	// 1613 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4d, 0x6f, 0xdb, 0xc6,
	0x16, 0x35, 0x2d, 0x5b, 0x16, 0xaf, 0x64, 0x5b, 0x9e, 0x38, 0x06, 0x9f, 0xdf, 0x7b, 0x76, 0x42,
	0xe7, 0xc3, 0xce, 0x87, 0xe4, 0xf8, 0x6d, 0x5e, 0x57, 0x4d, 0x64, 0xd7, 0x48, 0x02, 0x07, 0x09,
	0x68, 0xa7, 0x05, 0x82, 0xa6, 0x04, 0x3f, 0x46, 0x12, 0x2b, 0x89, 0x94, 0x39, 0xa4, 0x11, 0xad,
	0xba, 0xed, 0xaa, 0xc8, 0xb6, 0xcb, 0x6e, 0xbb, 0xe8, 0xa6, 0xff, 0xa0, 0xab, 0x74, 0x53, 0x64,
	0xd7, 0xa2, 0x8b, 0xb4, 0x48, 0xfe, 0x48, 0xc1, 0x99, 0xe1, 0x88, 0xa4, 0x64, 0x49, 0x76, 0x13,
	0x74, 0x25, 0x72, 0x38, 0xf7, 0x9c, 0xb9, 0x77, 0xe6, 0x9c, 0x19, 0x0d, 0x5c, 0x71, 0xdc, 0x2f,
	0xb1, 0x15, 0x38, 0x27, 0xb8, 0x4a, 0x02, 0x1f, 0x1b, 0x9d, 0xea, 0xc9, 0x1d, 0x13, 0x07, 0xc6,
	0x9d, 0xea, 0x71, 0x88, 0xfd, 0x5e, 0xa5, 0xeb, 0x7b, 0x81, 0x87, 0x14, 0xd1, 0xab, 0xc2, 0x7a,
	0x55, 0x78, 0xaf, 0xd5, 0x35, 0xcb, 0x23, 0x1d, 0x8f, 0x54, 0x4d, 0x83, 0x60, 0x11, 0x6a, 0x79,
	0x8e, 0xcb, 0x22, 0x57, 0x97, 0x1b, 0x5e, 0xc3, 0xa3, 0x8f, 0xd5, 0xe8, 0x89, 0xb7, 0x5e, 0xef,
	0xb3, 0xe2, 0x17, 0x56, 0xd3, 0x70, 0x1b, 0xfd, 0x60, 0x7c, 0x82, 0xdd, 0x80, 0xf0, 0x8e, 0x5b,
	0xa3, 0x3a, 0xf2, 0x06, 0xd6, 0x55, 0xfd, 0xa6, 0x00, 0xf3, 0x87, 0x74, 0x70, 0x1a, 0x3e, 0x0e,
	0x31, 0x09, 0x90, 0x0d, 0xcb, 0xa6, 0xe1, 0xb6, 0x74, 0xd3, 0x68, 0x1b, 0xae, 0x85, 0x89, 0x5e,
	0x77, 0xda, 0x01, 0xf6, 0x15, 0xe9, 0x92, 0xb4, 0x59, 0xdc, 0xb9, 0x55, 0x39, 0x2d, 0xa9, 0x4a,
	0xcd, 0x70, 0x5b, 0x35, 0x1e, 0xb4, 0x4f, 0x63, 0x6a, 0x33, 0xaf, 0xde, 0xac, 0x4b, 0x1a, 0x32,
	0x07, 0xbe, 0xa0, 0x13, 0x58, 0x25, 0xa1, 0x69, 0x58, 0x96, 0x17, 0xba, 0x81, 0x6e, 0xe3, 0xae,
	0x47, 0x9c, 0x40, 0x70, 0x4d, 0x53, 0xae, 0x9d, 0xd3, 0xb9, 0x0e, 0x45, 0xec, 0x1e, 0x0f, 0x4d,
	0x31, 0x2a, 0xe4, 0x94, 0xef, 0xe8, 0x19, 0x20, 0xd2, 0xf5, 0x02, 0x3d, 0xf0, 0x0d, 0xbb, 0x9f,
	0x5b, 0x8e, 0xf2, 0x5d, 0x3b, 0x9d, 0xef, 0x88, 0x76, 0x4f, 0x71, 0x94, 0x23, 0x9c, 0x64, 0x3b,
	0xaa, 0x83, 0x62, 0x63, 0xdf, 0x39, 0x31, 0x22, 0x84, 0x0c, 0xc3, 0xcc, 0x39, 0x18, 0x56, 0xfa,
	0x68, 0x29, 0x9e, 0x38, 0x07, 0xcf, 0xb7, 0xb1, 0x2f, 0x18, 0x66, 0xc7, 0x31, 0x3c, 0xa6, 0xdd,
	0x07, 0x73, 0x48, 0xb6, 0x67, 0x72, 0x48, 0x33, 0xe4, 0xcf, 0xc1, 0x90, 0xc8, 0x21, 0xc5, 0x83,
	0x61, 0xa5, 0x9f, 0x83, 0xe9, 0x79, 0x2d, 0xc1, 0x32, 0x47, 0x59, 0xb6, 0xc6, 0xb0, 0x44, 0x21,
	0x29, 0xa2, 0x65, 0x91, 0x0a, 0x45, 0xe3, 0x34, 0xc7, 0xf0, 0x9f, 0x6c, 0x3a, 0x29, 0xb2, 0xc2,
	0xf9, 0xc8, 0x56, 0x33, 0x59, 0x25, 0x29, 0x9f, 0x41, 0x99, 0xae, 0x38, 0xc7, 0x73, 0x05, 0x8d,
	0x3c, 0x8e, 0xe6, 0x49, 0x1c, 0x91, 0xa2, 0x59, 0xec, 0xa6, 0x9b, 0x91, 0x01, 0x17, 0x3c, 0xdf,
	0xb0, 0xda, 0x58, 0xef, 0xfa, 0x8e, 0x85, 0x63, 0x78, 0xa0, 0xf0, 0x37, 0x47, 0x65, 0x11, 0x05,
	0x3d, 0x89, 0x62, 0x52, 0x04, 0x4b, 0x5e, 0xf6, 0x83, 0xfa, 0xdd, 0x1c, 0x2c, 0xc4, 0x86, 0x40,
	0xba, 0x9e, 0x4b, 0x30, 0xba, 0x0c, 0x25, 0xb3, 0xed, 0x59, 0x2d, 0xbd, 0x89, 0x9d, 0x46, 0x33,
	0xa0, 0x4e, 0x30, 0xa3, 0x15, 0x69, 0xdb, 0x7d, 0xda, 0x84, 0xfe, 0x0b, 0xc0, 0xba, 0x04, 0x4e,
	0x07, 0x53, 0xf9, 0xe6, 0x34, 0x99, 0xb6, 0x1c, 0x39, 0x1d, 0x8c, 0x1e, 0xc2, 0x7c, 0xca, 0x53,
	0x94, 0xdc, 0xa5, 0xdc, 0x66, 0x71, 0xe7, 0xea, 0x44, 0x66, 0xa2, 0x95, 0x92, 0xfe, 0x81, 0x9e,
	0xc3, 0x85, 0x21, 0xce, 0xa1, 0xcc, 0x50, 0xc4, 0x5b, 0x67, 0xb1, 0x0c, 0x0d, 0x0d, 0xda, 0x04,
	0xda, 0x83, 0x62, 0xc2, 0x20, 0x94, 0x59, 0x0a, 0xbb, 0x31, 0x02, 0x36, 0x76, 0x01, 0x0d, 0xfa,
	0x86, 0x80, 0x3e, 0x85, 0xa5, 0x01, 0x2b, 0x50, 0xf2, 0x14, 0x6b, 0xc4, 0x2a, 0xd8, 0x4b, 0xeb,
	0x5d, 0x2b, 0x67, 0x0d, 0x00, 0x3d, 0xe4, 0xa3, 0x63, 0xc2, 0x54, 0xe6, 0xc6, 0x21, 0x1e, 0xc6,
	0xa2, 0x78, 0xda, 0xb5, 0x8d, 0x80, 0x8f, 0x91, 0x09, 0x11, 0x7d, 0x9e, 0x1a, 0x23, 0x47, 0x2c,
	0x50, 0xc4, 0xea, 0x24, 0x63, 0x4c, 0xe2, 0x96, 0xb3, 0x32, 0x47, 0x7a, 0x56, 0xe0, 0x7a, 0x48,
	0xbb, 0x12, 0x45, 0x1e, 0x37, 0x68, 0x21, 0x29, 0x0e, 0x9e, 0x96, 0x36, 0x6b, 0x24, 0xa8, 0x35,
	0x5c, 0xda, 0x82, 0x06, 0xce, 0x4a, 0x33, 0x4c, 0xd4, 0x31, 0xd9, 0x5d, 0x90, 0x85, 0x16, 0x95,
	0x22, 0x45, 0x56, 0xc7, 0xab, 0x59, 0xeb, 0x07, 0x45, 0x12, 0x48, 0x4a, 0x97, 0x28, 0xa5, 0x71,
	0x12, 0x48, 0x88, 0x56, 0x2b, 0x25, 0x84, 0x4a, 0xd4, 0x3a, 0x2c, 0x66, 0x46, 0x88, 0xca, 0x90,
	0x23, 0xf8, 0x98, 0x4b, 0x33, 0x7a, 0x44, 0xf7, 0x40, 0x16, 0x45, 0xe1, 0x1b, 0xea, 0xc6, 0x04,
	0xc5, 0xd0, 0xfa, 0x51, 0xea, 0x0f, 0x12, 0xc8, 0xe2, 0x03, 0xfa, 0x37, 0xc8, 0x1d, 0xc3, 0x6f,
	0xe1, 0x40, 0x77, 0x6c, 0x4a, 0x24, 0x6b, 0x05, 0xd6, 0xf0, 0xc0, 0x46, 0x77, 0x01, 0xcc, 0xb0,
	0xa7, 0xb7, 0xf1, 0x09, 0x6e, 0x13, 0x65, 0x9a, 0xe6, 0x76, 0x39, 0x41, 0x27, 0x8e, 0x1d, 0x31,
	0xe1, 0x41, 0xd4, 0x53, 0x93, 0xcd, 0xb0, 0x47, 0x9f, 0x08, 0xaa, 0x41, 0x91, 0xe0, 0x76, 0x3b,
	0x86, 0xc8, 0x4d, 0x0a, 0x01, 0x51, 0x14, 0xc3, 0x50, 0x5f, 0x4a, 0x50, 0x4c, 0x38, 0x07, 0x52,
	0x60, 0x8e, 0xeb, 0x9b, 0x0f, 0x38, 0x7e, 0x45, 0x0d, 0x28, 0x08, 0x33, 0x62, 0xa3, 0xfd, 0x57,
	0x85, 0x1d, 0xca, 0x2a, 0xd1, 0xa1, 0x4c, 0x70, 0xec, 0x7a, 0x8e, 0x5b, 0xdb, 0x7e, 0xf5, 0x66,
	0x7d, 0xea, 0xfb, 0x3f, 0xd6, 0x37, 0x1b, 0x4e, 0xd0, 0x0c, 0xcd, 0x8a, 0xe5, 0x75, 0xaa, 0xfc,
	0x04, 0xc7, 0x7e, 0x6e, 0x13, 0xbb, 0x55, 0x0d, 0x7a, 0x5d, 0x4c, 0x68, 0x00, 0xd1, 0x04, 0xb8,
	0xfa, 0xb5, 0x04, 0x68, 0xd0, 0x7a, 0xd0, 0x06, 0xcc, 0x27, 0x5c, 0x4c, 0x14, 0xb4, 0xd4, 0x6f,
	0x7c, 0x60, 0xa3, 0x47, 0x50, 0x10, 0xfe, 0xc6, 0x06, 0x79, 0xf3, 0x0c, 0xfe, 0x46, 0x3d, 0x7e,
	0x4a, 0x13, 0x10, 0xaa, 0x0b, 0x4b, 0x03, 0x9d, 0xd0, 0x32, 0xcc, 0xda, 0xd8, 0xf5, 0x3a, 0x7c,
	0x00, 0xec, 0x05, 0xed, 0xc2, 0x1c, 0x0f, 0x1b, 0xb2, 0x74, 0x06, 0x26, 0x22, 0x4d, 0x18, 0x47,
	0xaa, 0x3f, 0x49, 0xb0, 0x98, 0x31, 0x20, 0xb4, 0x0b, 0x79, 0x12, 0x18, 0x41, 0x48, 0x28, 0xdf,
	0xc2, 0xe8, 0x4d, 0x4b, 0x84, 0x1d, 0xd2, 0x10, 0x8d, 0x87, 0x46, 0xbb, 0x0d, 0x5d, 0xa4, 0x7a,
	0xd3, 0x20, 0x4d, 0x3a, 0xc0, 0x12, 0x5f, 0xb6, 0xf7, 0x0d, 0xd2, 0x8c, 0xb4, 0x60, 0x39, 0x36,
	0x3d, 0xd4, 0xc9, 0x5a, 0xf4, 0x88, 0x3e, 0x82, 0x59, 0xfa, 0x99, 0x1f, 0xc3, 0x36, 0x26, 0x30,
	0x4c, 0x8d, 0x45, 0xa8, 0x5d, 0x90, 0x45, 0xdb, 0x68, 0x09, 0xec, 0xc7, 0x24, 0xac, 0x62, 0x37,
	0x46, 0x55, 0x2c, 0x82, 0x3c, 0x70, 0x3a, 0x0e, 0xc3, 0xe5, 0x85, 0xe3, 0x8c, 0xbf, 0x48, 0x70,
	0x71, 0xa8, 0xcb, 0xfe, 0x43, 0xc5, 0xfb, 0x38, 0x5d, 0xbc, 0xad, 0x89, 0xf7, 0x86, 0x38, 0xa1,
	0x6f, 0x25, 0x58, 0xcc, 0x7c, 0x1a, 0x5d, 0xc9, 0x83, 0x74, 0x25, 0xb7, 0x47, 0xaf, 0xbd, 0x18,
	0xf8, 0x94, 0x7a, 0x46, 0x54, 0x0e, 0xd1, 0x19, 0x38, 0xcd, 0xab, 0xa0, 0x15, 0x1c, 0xf2, 0x88,
	0xbe, 0xab, 0x3f, 0xe6, 0xa0, 0x10, 0xdb, 0xf5, 0xe8, 0x41, 0x0d, 0x28, 0x76, 0x7a, 0x88, 0x62,
	0x57, 0x20, 0xef, 0x90, 0x03, 0xcf, 0x6d, 0x70, 0x22, 0xfe, 0x86, 0x1e, 0x42, 0xe1, 0x38, 0x34,
	0xdc, 0xc0, 0x09, 0x7a, 0xb4, 0x8c, 0x72, 0xad, 0x12, 0x0d, 0xf1, 0xf7, 0x37, 0xeb, 0xd7, 0x26,
	0xf0, 0x94, 0x3d, 0x6c, 0x69, 0x22, 0x1e, 0x3d, 0x86, 0x22, 0x76, 0x03, 0xbf, 0xc7, 0x36, 0x12,
	0x7a, 0xee, 0x3f, 0x3b, 0x1c, 0x50, 0x08, 0xba, 0x9f, 0xa0, 0x7d, 0xc8, 0x77, 0x0c, 0xbf, 0xe1,
	0xb8, 0xf4, 0x84, 0x7f, 0x76, 0x2c, 0x1e, 0x8d, 0x9a, 0xa0, 0x58, 0x61, 0x27, 0x6c, 0xb3, 0x1d,
	0xb9, 0x1e, 0xba, 0xb6, 0xe3, 0x36, 0x74, 0x4a, 0x44, 0x4f, 0xf5, 0x67, 0x47, 0x5e, 0xe9, 0xe3,
	0xed, 0x33, 0xb8, 0x4f, 0x22, 0x34, 0xf5, 0x2b, 0x28, 0x26, 0x76, 0xc7, 0xa8, 0xea, 0xa4, 0xd7,
	0x31, 0xbd, 0x36, 0x9f, 0x34, 0xfe, 0x86, 0xf6, 0x60, 0x96, 0xd5, 0x68, 0xfa, 0x5c, 0xec, 0x2c,
	0x18, 0x21, 0x98, 0x89, 0xda, 0xb8, 0x24, 0xe8, 0xb3, 0xfa, 0x73, 0x8e, 0xd9, 0x02, 0x3d, 0x96,
	0x8d, 0x5e, 0x37, 0x17, 0xa3, 0x25, 0xa1, 0x9b, 0x61, 0x8f, 0x8e, 0xa2, 0xa0, 0xcd, 0x3a, 0xa4,
	0x16, 0xf6, 0xd0, 0x15, 0x98, 0xc7, 0x2f, 0xb0, 0x15, 0x46, 0x0b, 0xef, 0xa8, 0x0f, 0x9f, 0x6e,
	0x7c, 0xaf, 0xeb, 0x46, 0x54, 0x63, 0xf6, 0xef, 0x54, 0x63, 0x40, 0x06, 0xf9, 0x21, 0x32, 0xb8,
	0x0b, 0xb9, 0x3a, 0xc6, 0xe7, 0x9c, 0xf4, 0x28, 0x34, 0xe3, 0x52, 0x85, 0xac, 0x4b, 0xfd, 0x1f,
	0x2e, 0xd6, 0x31, 0xd6, 0x7d, 0x6c, 0x39, 0x5d, 0x07, 0xbb, 0x81, 0x6e, 0xd8, 0xb6, 0x8f, 0x09,
	0xa1, 0xff, 0xb4, 0x64, 0xfe, 0xef, 0xe6, 0x42, 0x1d, 0x63, 0x2d, 0xee, 0x71, 0x8f, 0x75, 0x88,
	0xfd, 0x0d, 0x84, 0xbf, 0xa9, 0xbf, 0xe6, 0x92, 0xf6, 0xf4, 0xa1, 0x67, 0x74, 0xa0, 0x7e, 0x33,
	0x43, 0xea, 0xf7, 0x04, 0x16, 0xe2, 0x93, 0xa3, 0x6e, 0xe3, 0x76, 0x60, 0xf0, 0x7f, 0xf7, 0x5b,
	0xa3, 0x9c, 0x30, 0xb6, 0xb1, 0xbd, 0x28, 0x40, 0x9b, 0xef, 0x26, 0x5f, 0x23, 0x8d, 0x77, 0x8d,
	0x9e, 0x17, 0x06, 0xe7, 0xd5, 0x38, 0x8b, 0xfe, 0x20, 0x33, 0x2b, 0x7f, 0xa8, 0x99, 0x3d, 0x82,
	0x52, 0xea, 0xe2, 0xe4, 0x2a, 0x2c, 0xa4, 0x6a, 0x1f, 0xed, 0xa3, 0xb9, 0x68, 0x8a, 0x92, 0xc5,
	0xa7, 0x3b, 0xa4, 0x98, 0x7c, 0x76, 0xf0, 0x92, 0x35, 0x39, 0x9e, 0x7d, 0xa2, 0x7e, 0x06, 0x8b,
	0x99, 0xbf, 0xeb, 0xef, 0x09, 0xf8, 0x08, 0x4a, 0xa9, 0x3b, 0x92, 0xf7, 0x83, 0xba, 0x9d, 0xf8,
	0xb3, 0xc0, 0x81, 0xd3, 0x11, 0xd2, 0x60, 0x04, 0x1a, 0xbc, 0xcb, 0x43, 0xab, 0x50, 0xe0, 0xa4,
	0x71, 0x88, 0x78, 0x57, 0xef, 0x81, 0x72, 0xda, 0x8d, 0xdc, 0x84, 0x59, 0xa8, 0x37, 0x61, 0x69,
	0xe0, 0x96, 0x22, 0x65, 0xec, 0xb9, 0xbe, 0xb1, 0xdf, 0x38, 0x88, 0x3a, 0x67, 0x0e, 0x38, 0x68,
	0x11, 0x8a, 0x4f, 0x5d, 0xd2, 0xc5, 0x96, 0x53, 0x77, 0xb0, 0x5d, 0x9e, 0x42, 0x00, 0xf9, 0x9a,
	0xe7, 0xb5, 0xb0, 0x5d, 0x96, 0x50, 0x11, 0xe6, 0x1e, 0x19, 0x81, 0xd5, 0xc4, 0x76, 0x79, 0x1a,
	0xcd, 0x83, 0xbc, 0x1b, 0xa5, 0xd6, 0x6e, 0x63, 0xbb, 0x9c, 0xdb, 0x69, 0x40, 0x9e, 0xdd, 0x78,
	0xa0, 0xe7, 0xe2, 0xe9, 0xfa, 0x88, 0x23, 0x62, 0xf2, 0xba, 0x74, 0x75, 0x73, 0x7c, 0x47, 0x76,
	0x8d, 0xb2, 0x2d, 0xd5, 0xbe, 0x78, 0xf5, 0x76, 0x4d, 0x7a, 0xfd, 0x76, 0x4d, 0xfa, 0xf3, 0xed,
	0x9a, 0xf4, 0xf2, 0xdd, 0xda, 0xd4, 0xeb, 0x77, 0x6b, 0x53, 0xbf, 0xbd, 0x5b, 0x9b, 0x7a, 0xb6,
	0x97, 0x50, 0xd0, 0x83, 0x18, 0xef, 0xc0, 0x30, 0x49, 0x55, 0xa0, 0xdf, 0xb6, 0x3c, 0x1f, 0x27,
	0x5f, 0x9b, 0x86, 0xe3, 0xc6, 0xd7, 0xcf, 0x54, 0x63, 0x66, 0x9e, 0xde, 0xe9, 0xfe, 0xef, 0xaf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x62, 0x5b, 0xfb, 0x13, 0x9f, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StreamClient is the client API for Stream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamClient interface {
	Stream(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (Stream_StreamClient, error)
}

type streamClient struct {
	cc grpc1.ClientConn
}

func NewStreamClient(cc grpc1.ClientConn) StreamClient {
	return &streamClient{cc}
}

func (c *streamClient) Stream(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (Stream_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Stream_serviceDesc.Streams[0], "/injective.stream.v1beta1.Stream/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stream_StreamClient interface {
	Recv() (*StreamResponse, error)
	grpc.ClientStream
}

type streamStreamClient struct {
	grpc.ClientStream
}

func (x *streamStreamClient) Recv() (*StreamResponse, error) {
	m := new(StreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamServer is the server API for Stream service.
type StreamServer interface {
	Stream(*StreamRequest, Stream_StreamServer) error
}

// UnimplementedStreamServer can be embedded to have forward compatible implementations.
type UnimplementedStreamServer struct {
}

func (*UnimplementedStreamServer) Stream(req *StreamRequest, srv Stream_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}

func RegisterStreamServer(s grpc1.Server, srv StreamServer) {
	s.RegisterService(&_Stream_serviceDesc, srv)
}

func _Stream_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamServer).Stream(m, &streamStreamServer{stream})
}

type Stream_StreamServer interface {
	Send(*StreamResponse) error
	grpc.ServerStream
}

type streamStreamServer struct {
	grpc.ServerStream
}

func (x *streamStreamServer) Send(m *StreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Stream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "injective.stream.v1beta1.Stream",
	HandlerType: (*StreamServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _Stream_Stream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "injective/stream/v1beta1/query.proto",
}

func (m *StreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OraclePriceFilter != nil {
		{
			size, err := m.OraclePriceFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PositionsFilter != nil {
		{
			size, err := m.PositionsFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DerivativeOrderbooksFilter != nil {
		{
			size, err := m.DerivativeOrderbooksFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SpotOrderbooksFilter != nil {
		{
			size, err := m.SpotOrderbooksFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DerivativeOrdersFilter != nil {
		{
			size, err := m.DerivativeOrdersFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SpotOrdersFilter != nil {
		{
			size, err := m.SpotOrdersFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DerivativeTradesFilter != nil {
		{
			size, err := m.DerivativeTradesFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SpotTradesFilter != nil {
		{
			size, err := m.SpotTradesFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SubaccountDepositsFilter != nil {
		{
			size, err := m.SubaccountDepositsFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BankBalancesFilter != nil {
		{
			size, err := m.BankBalancesFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OraclePrices) > 0 {
		for iNdEx := len(m.OraclePrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OraclePrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DerivativeOrderbookUpdates) > 0 {
		for iNdEx := len(m.DerivativeOrderbookUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrderbookUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.SpotOrderbookUpdates) > 0 {
		for iNdEx := len(m.SpotOrderbookUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrderbookUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.DerivativeOrders) > 0 {
		for iNdEx := len(m.DerivativeOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SpotOrders) > 0 {
		for iNdEx := len(m.SpotOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DerivativeTrades) > 0 {
		for iNdEx := len(m.DerivativeTrades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DerivativeTrades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SpotTrades) > 0 {
		for iNdEx := len(m.SpotTrades) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpotTrades[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SubaccountDeposits) > 0 {
		for iNdEx := len(m.SubaccountDeposits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubaccountDeposits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.BankBalances) > 0 {
		for iNdEx := len(m.BankBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BankBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BlockTime != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderbookUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderbookUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderbookUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Orderbook != nil {
		{
			size, err := m.Orderbook.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Orderbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Orderbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Orderbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SellLevels) > 0 {
		for iNdEx := len(m.SellLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SellLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BuyLevels) > 0 {
		for iNdEx := len(m.BuyLevels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuyLevels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BankBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BankBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubaccountDeposits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountDeposits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountDeposits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposits) > 0 {
		for iNdEx := len(m.Deposits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deposits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubaccountDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Deposit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotOrderUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotOrderUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotOrderUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeOrderUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeOrderUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeOrderUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMarket {
		i--
		if m.IsMarket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CumulativeFundingEntry.Size()
		i -= size
		if _, err := m.CumulativeFundingEntry.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Margin.Size()
		i -= size
		if _, err := m.Margin.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.EntryPrice.Size()
		i -= size
		if _, err := m.EntryPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.IsLong {
		i--
		if m.IsLong {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OraclePrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ExecutionType) > 0 {
		i -= len(m.ExecutionType)
		copy(dAtA[i:], m.ExecutionType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExecutionType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeTrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeTrade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeTrade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Payout.Size()
		i -= size
		if _, err := m.Payout.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.PositionDelta != nil {
		{
			size, err := m.PositionDelta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SubaccountId) > 0 {
		i -= len(m.SubaccountId)
		copy(dAtA[i:], m.SubaccountId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExecutionType) > 0 {
		i -= len(m.ExecutionType)
		copy(dAtA[i:], m.ExecutionType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExecutionType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradesFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradesFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradesFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PositionsFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionsFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionsFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrdersFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrdersFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrdersFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderbookFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderbookFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderbookFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for iNdEx := len(m.MarketIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MarketIds[iNdEx])
			copy(dAtA[i:], m.MarketIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BankBalancesFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankBalancesFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BankBalancesFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Accounts[iNdEx])
			copy(dAtA[i:], m.Accounts[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Accounts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubaccountDepositsFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountDepositsFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountDepositsFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for iNdEx := len(m.SubaccountIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubaccountIds[iNdEx])
			copy(dAtA[i:], m.SubaccountIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OraclePriceFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePriceFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePriceFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Symbol) > 0 {
		for iNdEx := len(m.Symbol) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Symbol[iNdEx])
			copy(dAtA[i:], m.Symbol[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Symbol[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BankBalancesFilter != nil {
		l = m.BankBalancesFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SubaccountDepositsFilter != nil {
		l = m.SubaccountDepositsFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SpotTradesFilter != nil {
		l = m.SpotTradesFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DerivativeTradesFilter != nil {
		l = m.DerivativeTradesFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SpotOrdersFilter != nil {
		l = m.SpotOrdersFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DerivativeOrdersFilter != nil {
		l = m.DerivativeOrdersFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SpotOrderbooksFilter != nil {
		l = m.SpotOrderbooksFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DerivativeOrderbooksFilter != nil {
		l = m.DerivativeOrderbooksFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.PositionsFilter != nil {
		l = m.PositionsFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.OraclePriceFilter != nil {
		l = m.OraclePriceFilter.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *StreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovQuery(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovQuery(uint64(m.BlockTime))
	}
	if len(m.BankBalances) > 0 {
		for _, e := range m.BankBalances {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SubaccountDeposits) > 0 {
		for _, e := range m.SubaccountDeposits {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SpotTrades) > 0 {
		for _, e := range m.SpotTrades {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.DerivativeTrades) > 0 {
		for _, e := range m.DerivativeTrades {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SpotOrders) > 0 {
		for _, e := range m.SpotOrders {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.DerivativeOrders) > 0 {
		for _, e := range m.DerivativeOrders {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SpotOrderbookUpdates) > 0 {
		for _, e := range m.SpotOrderbookUpdates {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.DerivativeOrderbookUpdates) > 0 {
		for _, e := range m.DerivativeOrderbookUpdates {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.OraclePrices) > 0 {
		for _, e := range m.OraclePrices {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *OrderbookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovQuery(uint64(m.Seq))
	}
	if m.Orderbook != nil {
		l = m.Orderbook.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *Orderbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.BuyLevels) > 0 {
		for _, e := range m.BuyLevels {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.SellLevels) > 0 {
		for _, e := range m.SellLevels {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *BankBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *SubaccountDeposits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Deposits) > 0 {
		for _, e := range m.Deposits {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *SubaccountDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Deposit.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *SpotOrderUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *SpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *DerivativeOrderUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Order.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.IsMarket {
		n += 2
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsLong {
		n += 2
	}
	l = m.Quantity.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.EntryPrice.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Margin.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.CumulativeFundingEntry.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *OraclePrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *SpotTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsBuy {
		n += 2
	}
	l = len(m.ExecutionType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Quantity.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Price.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Fee.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DerivativeTrade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsBuy {
		n += 2
	}
	l = len(m.ExecutionType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.PositionDelta != nil {
		l = m.PositionDelta.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.Payout.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *TradesFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *PositionsFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *OrdersFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *OrderbookFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MarketIds) > 0 {
		for _, s := range m.MarketIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *BankBalancesFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, s := range m.Accounts {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *SubaccountDepositsFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubaccountIds) > 0 {
		for _, s := range m.SubaccountIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *OraclePriceFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Symbol) > 0 {
		for _, s := range m.Symbol {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankBalancesFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BankBalancesFilter == nil {
				m.BankBalancesFilter = &BankBalancesFilter{}
			}
			if err := m.BankBalancesFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountDepositsFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubaccountDepositsFilter == nil {
				m.SubaccountDepositsFilter = &SubaccountDepositsFilter{}
			}
			if err := m.SubaccountDepositsFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotTradesFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpotTradesFilter == nil {
				m.SpotTradesFilter = &TradesFilter{}
			}
			if err := m.SpotTradesFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeTradesFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DerivativeTradesFilter == nil {
				m.DerivativeTradesFilter = &TradesFilter{}
			}
			if err := m.DerivativeTradesFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrdersFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpotOrdersFilter == nil {
				m.SpotOrdersFilter = &OrdersFilter{}
			}
			if err := m.SpotOrdersFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrdersFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DerivativeOrdersFilter == nil {
				m.DerivativeOrdersFilter = &OrdersFilter{}
			}
			if err := m.DerivativeOrdersFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrderbooksFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpotOrderbooksFilter == nil {
				m.SpotOrderbooksFilter = &OrderbookFilter{}
			}
			if err := m.SpotOrderbooksFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrderbooksFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DerivativeOrderbooksFilter == nil {
				m.DerivativeOrderbooksFilter = &OrderbookFilter{}
			}
			if err := m.DerivativeOrderbooksFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionsFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionsFilter == nil {
				m.PositionsFilter = &PositionsFilter{}
			}
			if err := m.PositionsFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OraclePriceFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OraclePriceFilter == nil {
				m.OraclePriceFilter = &OraclePriceFilter{}
			}
			if err := m.OraclePriceFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankBalances = append(m.BankBalances, &BankBalance{})
			if err := m.BankBalances[len(m.BankBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountDeposits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountDeposits = append(m.SubaccountDeposits, &SubaccountDeposits{})
			if err := m.SubaccountDeposits[len(m.SubaccountDeposits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotTrades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotTrades = append(m.SpotTrades, &SpotTrade{})
			if err := m.SpotTrades[len(m.SpotTrades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeTrades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeTrades = append(m.DerivativeTrades, &DerivativeTrade{})
			if err := m.DerivativeTrades[len(m.DerivativeTrades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrders = append(m.SpotOrders, &SpotOrderUpdate{})
			if err := m.SpotOrders[len(m.SpotOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrders = append(m.DerivativeOrders, &DerivativeOrderUpdate{})
			if err := m.DerivativeOrders[len(m.DerivativeOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpotOrderbookUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpotOrderbookUpdates = append(m.SpotOrderbookUpdates, &OrderbookUpdate{})
			if err := m.SpotOrderbookUpdates[len(m.SpotOrderbookUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DerivativeOrderbookUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DerivativeOrderbookUpdates = append(m.DerivativeOrderbookUpdates, &OrderbookUpdate{})
			if err := m.DerivativeOrderbookUpdates[len(m.DerivativeOrderbookUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &Position{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OraclePrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OraclePrices = append(m.OraclePrices, &OraclePrice{})
			if err := m.OraclePrices[len(m.OraclePrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderbookUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderbookUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderbookUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orderbook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Orderbook == nil {
				m.Orderbook = &Orderbook{}
			}
			if err := m.Orderbook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Orderbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Orderbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Orderbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyLevels = append(m.BuyLevels, &types.Level{})
			if err := m.BuyLevels[len(m.BuyLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellLevels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SellLevels = append(m.SellLevels, &types.Level{})
			if err := m.SellLevels[len(m.SellLevels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, types1.Coin{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountDeposits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountDeposits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountDeposits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposits = append(m.Deposits, SubaccountDeposit{})
			if err := m.Deposits[len(m.Deposits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotOrderUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotOrderUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotOrderUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderUpdateStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = append(m.OrderHash[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderHash == nil {
				m.OrderHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &SpotOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeOrderUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeOrderUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeOrderUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderUpdateStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = append(m.OrderHash[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderHash == nil {
				m.OrderHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &DerivativeOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMarket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMarket = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLong", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLong = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EntryPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Margin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeFundingEntry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CumulativeFundingEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = append(m.OrderHash[:0], dAtA[iNdEx:postIndex]...)
			if m.OrderHash == nil {
				m.OrderHash = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeTrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeTrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeTrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PositionDelta == nil {
				m.PositionDelta = &types.PositionDelta{}
			}
			if err := m.PositionDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Payout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradesFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradesFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradesFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionsFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionsFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionsFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrdersFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrdersFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrdersFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderbookFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderbookFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderbookFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketIds = append(m.MarketIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankBalancesFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankBalancesFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankBalancesFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountDepositsFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountDepositsFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountDepositsFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountIds = append(m.SubaccountIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePriceFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePriceFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePriceFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = append(m.Symbol, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
