package types

import (
	"bytes"
	"fmt"
	"strings"

	"cosmossdk.io/errors"
	"cosmossdk.io/math"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
	gethcommon "github.com/ethereum/go-ethereum/common"
)

const (
	// PeggyDenomPrefix indicates the prefix for all assests minted by this module
	PeggyDenomPrefix = ModuleName

	// PeggyDenomSeparator is the separator for peggy denoms
	PeggyDenomSeparator = ""

	// ETHContractAddressLen is the length of contract address bytes
	ETHContractAddressLen = 20

	// PeggyDenomLen is the length of the denoms generated by the peggy module
	PeggyDenomLen = len(PeggyDenomPrefix) + len(PeggyDenomSeparator) + ETHContractAddressLen

	// ZeroAddress is an EthAddress containing the zero ethereum address
	ZeroAddressString = "0x0000000000000000000000000000000000000000"
)

// EthAddrLessThan migrates the Ethereum address less than function
func EthAddrLessThan(e, o string) bool {
	return bytes.Compare([]byte(e), []byte(o)) == -1
}

// Returns a new EthAddress with 0x0000000000000000000000000000000000000000 as the wrapped address
func ZeroAddress() gethcommon.Address {
	return gethcommon.HexToAddress(ZeroAddressString)
}

// Creates a new EthAddress from a string, performing validation and returning any validation errors
func NewEthAddress(address string) (*gethcommon.Address, error) {
	if err := ValidateEthAddress(address); err != nil {
		return nil, errors.Wrap(err, "invalid input address")
	}

	addr := gethcommon.HexToAddress(address)
	return &addr, nil
}

// ValidateEthAddress validates the ethereum address strings
func ValidateEthAddress(address string) error {
	if address == "" {
		return fmt.Errorf("empty")
	}
	if !gethcommon.IsHexAddress(address) {
		return fmt.Errorf("%s is not a valid ETH address", address)
	}
	return nil
}

// NewERC20Token returns a new instance of an ERC20
func NewERC20Token(amount uint64, contract gethcommon.Address) *ERC20Token {
	return &ERC20Token{Amount: sdk.NewIntFromUint64(amount), Contract: contract.Hex()}
}

func NewSDKIntERC20Token(amount math.Int, contract gethcommon.Address) *ERC20Token {
	return &ERC20Token{Amount: amount, Contract: contract.Hex()}
}

// PeggyCoin returns the peggy representation of an ERC20 token
func (e *ERC20Token) PeggyCoin() sdk.Coin {
	return sdk.NewCoin(PeggyDenomString(gethcommon.HexToAddress(e.Contract)), e.Amount)
}

type PeggyDenom []byte

func (p PeggyDenom) String() string {
	contractAddress, err := p.TokenContract()
	if err != nil {
		// the case of unparseable peggy denom
		return fmt.Sprintf("%x(error: %s)", []byte(p), err.Error())
	}

	return PeggyDenomString(contractAddress)
}

func (p PeggyDenom) TokenContract() (gethcommon.Address, error) {
	fullPrefix := []byte(PeggyDenomPrefix + PeggyDenomSeparator)
	if !bytes.HasPrefix(p, fullPrefix) {
		err := fmt.Errorf("denom '%x' byte prefix not equal to expected '%x'", []byte(p), fullPrefix)
		return gethcommon.Address{}, err
	}

	addressBytes := bytes.TrimPrefix(p, fullPrefix)
	if len(addressBytes) != ETHContractAddressLen {
		err := fmt.Errorf("failed to validate Ethereum address bytes: %x", addressBytes)
		return gethcommon.Address{}, err
	}

	return gethcommon.BytesToAddress(addressBytes), nil
}

func NewPeggyDenom(tokenContract gethcommon.Address) PeggyDenom {
	buf := make([]byte, 0, PeggyDenomLen)
	buf = append(buf, PeggyDenomPrefix+PeggyDenomSeparator...)
	buf = append(buf, tokenContract.Bytes()...)

	return PeggyDenom(buf)
}

func NewPeggyDenomFromString(denom string) (PeggyDenom, error) {
	fullPrefix := PeggyDenomPrefix + PeggyDenomSeparator
	if !strings.HasPrefix(denom, fullPrefix) {
		err := fmt.Errorf("denom '%s' string prefix not equal to expected '%s'", denom, fullPrefix)
		return nil, err
	}

	addressHex := strings.TrimPrefix(denom, fullPrefix)
	if err := ValidateEthAddress(addressHex); err != nil {
		return nil, err
	}

	peggyDenom := NewPeggyDenom(gethcommon.HexToAddress(addressHex))
	return peggyDenom, nil
}

func PeggyDenomString(tokenContract gethcommon.Address) string {
	return fmt.Sprintf("%s%s%s", PeggyDenomPrefix, PeggyDenomSeparator, tokenContract.Hex())
}

// ValidateBasic permforms stateless validation
func (e *ERC20Token) ValidateBasic() error {
	if err := ValidateEthAddress(e.Contract); err != nil {
		return errors.Wrap(err, "ethereum address")
	}

	if !e.PeggyCoin().IsValid() {
		return errors.Wrap(sdkerrors.ErrInvalidCoins, e.PeggyCoin().String())
	}

	if !e.PeggyCoin().IsPositive() {
		return errors.Wrap(sdkerrors.ErrInvalidCoins, e.PeggyCoin().String())
	}

	return nil
}

// Add adds one ERC20 to another
func (e *ERC20Token) Add(o *ERC20Token) (*ERC20Token, error) {
	if e.Contract != o.Contract {
		return nil, fmt.Errorf("invalid contract address")
	}

	sum := e.Amount.Add(o.Amount)
	if !sum.IsUint64() {
		return nil, fmt.Errorf("invalid amount")
	}

	return NewERC20Token(sum.Uint64(), gethcommon.HexToAddress(e.Contract)), nil
}
