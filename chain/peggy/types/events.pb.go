// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/peggy/v1/events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventAttestationObserved struct {
	AttestationType ClaimType `protobuf:"varint,1,opt,name=attestation_type,json=attestationType,proto3,enum=injective.peggy.v1.ClaimType" json:"attestation_type,omitempty"`
	BridgeContract  string    `protobuf:"bytes,2,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId   uint64    `protobuf:"varint,3,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
	AttestationId   []byte    `protobuf:"bytes,4,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	Nonce           uint64    `protobuf:"varint,5,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *EventAttestationObserved) Reset()         { *m = EventAttestationObserved{} }
func (m *EventAttestationObserved) String() string { return proto.CompactTextString(m) }
func (*EventAttestationObserved) ProtoMessage()    {}
func (*EventAttestationObserved) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{0}
}
func (m *EventAttestationObserved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAttestationObserved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAttestationObserved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAttestationObserved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAttestationObserved.Merge(m, src)
}
func (m *EventAttestationObserved) XXX_Size() int {
	return m.Size()
}
func (m *EventAttestationObserved) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAttestationObserved.DiscardUnknown(m)
}

var xxx_messageInfo_EventAttestationObserved proto.InternalMessageInfo

func (m *EventAttestationObserved) GetAttestationType() ClaimType {
	if m != nil {
		return m.AttestationType
	}
	return CLAIM_TYPE_UNKNOWN
}

func (m *EventAttestationObserved) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventAttestationObserved) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

func (m *EventAttestationObserved) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

func (m *EventAttestationObserved) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type EventBridgeWithdrawCanceled struct {
	BridgeContract string `protobuf:"bytes,1,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId  uint64 `protobuf:"varint,2,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
}

func (m *EventBridgeWithdrawCanceled) Reset()         { *m = EventBridgeWithdrawCanceled{} }
func (m *EventBridgeWithdrawCanceled) String() string { return proto.CompactTextString(m) }
func (*EventBridgeWithdrawCanceled) ProtoMessage()    {}
func (*EventBridgeWithdrawCanceled) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{1}
}
func (m *EventBridgeWithdrawCanceled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBridgeWithdrawCanceled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBridgeWithdrawCanceled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBridgeWithdrawCanceled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBridgeWithdrawCanceled.Merge(m, src)
}
func (m *EventBridgeWithdrawCanceled) XXX_Size() int {
	return m.Size()
}
func (m *EventBridgeWithdrawCanceled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBridgeWithdrawCanceled.DiscardUnknown(m)
}

var xxx_messageInfo_EventBridgeWithdrawCanceled proto.InternalMessageInfo

func (m *EventBridgeWithdrawCanceled) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventBridgeWithdrawCanceled) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

type EventOutgoingBatch struct {
	Denom               string   `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	OrchestratorAddress string   `protobuf:"bytes,2,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
	BatchNonce          uint64   `protobuf:"varint,3,opt,name=batch_nonce,json=batchNonce,proto3" json:"batch_nonce,omitempty"`
	BatchTimeout        uint64   `protobuf:"varint,4,opt,name=batch_timeout,json=batchTimeout,proto3" json:"batch_timeout,omitempty"`
	BatchTxIds          []uint64 `protobuf:"varint,5,rep,packed,name=batch_tx_ids,json=batchTxIds,proto3" json:"batch_tx_ids,omitempty"`
}

func (m *EventOutgoingBatch) Reset()         { *m = EventOutgoingBatch{} }
func (m *EventOutgoingBatch) String() string { return proto.CompactTextString(m) }
func (*EventOutgoingBatch) ProtoMessage()    {}
func (*EventOutgoingBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{2}
}
func (m *EventOutgoingBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutgoingBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutgoingBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutgoingBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutgoingBatch.Merge(m, src)
}
func (m *EventOutgoingBatch) XXX_Size() int {
	return m.Size()
}
func (m *EventOutgoingBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutgoingBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutgoingBatch proto.InternalMessageInfo

func (m *EventOutgoingBatch) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *EventOutgoingBatch) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

func (m *EventOutgoingBatch) GetBatchNonce() uint64 {
	if m != nil {
		return m.BatchNonce
	}
	return 0
}

func (m *EventOutgoingBatch) GetBatchTimeout() uint64 {
	if m != nil {
		return m.BatchTimeout
	}
	return 0
}

func (m *EventOutgoingBatch) GetBatchTxIds() []uint64 {
	if m != nil {
		return m.BatchTxIds
	}
	return nil
}

type EventOutgoingBatchCanceled struct {
	BridgeContract string `protobuf:"bytes,1,opt,name=bridge_contract,json=bridgeContract,proto3" json:"bridge_contract,omitempty"`
	BridgeChainId  uint64 `protobuf:"varint,2,opt,name=bridge_chain_id,json=bridgeChainId,proto3" json:"bridge_chain_id,omitempty"`
	BatchId        uint64 `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	Nonce          uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *EventOutgoingBatchCanceled) Reset()         { *m = EventOutgoingBatchCanceled{} }
func (m *EventOutgoingBatchCanceled) String() string { return proto.CompactTextString(m) }
func (*EventOutgoingBatchCanceled) ProtoMessage()    {}
func (*EventOutgoingBatchCanceled) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{3}
}
func (m *EventOutgoingBatchCanceled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutgoingBatchCanceled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutgoingBatchCanceled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutgoingBatchCanceled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutgoingBatchCanceled.Merge(m, src)
}
func (m *EventOutgoingBatchCanceled) XXX_Size() int {
	return m.Size()
}
func (m *EventOutgoingBatchCanceled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutgoingBatchCanceled.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutgoingBatchCanceled proto.InternalMessageInfo

func (m *EventOutgoingBatchCanceled) GetBridgeContract() string {
	if m != nil {
		return m.BridgeContract
	}
	return ""
}

func (m *EventOutgoingBatchCanceled) GetBridgeChainId() uint64 {
	if m != nil {
		return m.BridgeChainId
	}
	return 0
}

func (m *EventOutgoingBatchCanceled) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *EventOutgoingBatchCanceled) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type EventValsetUpdateRequest struct {
	ValsetNonce   uint64                `protobuf:"varint,1,opt,name=valset_nonce,json=valsetNonce,proto3" json:"valset_nonce,omitempty"`
	ValsetHeight  uint64                `protobuf:"varint,2,opt,name=valset_height,json=valsetHeight,proto3" json:"valset_height,omitempty"`
	ValsetMembers []*BridgeValidator    `protobuf:"bytes,3,rep,name=valset_members,json=valsetMembers,proto3" json:"valset_members,omitempty"`
	RewardAmount  cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=reward_amount,json=rewardAmount,proto3,customtype=cosmossdk.io/math.Int" json:"reward_amount"`
	RewardToken   string                `protobuf:"bytes,5,opt,name=reward_token,json=rewardToken,proto3" json:"reward_token,omitempty"`
}

func (m *EventValsetUpdateRequest) Reset()         { *m = EventValsetUpdateRequest{} }
func (m *EventValsetUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*EventValsetUpdateRequest) ProtoMessage()    {}
func (*EventValsetUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{4}
}
func (m *EventValsetUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValsetUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValsetUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValsetUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValsetUpdateRequest.Merge(m, src)
}
func (m *EventValsetUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *EventValsetUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValsetUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EventValsetUpdateRequest proto.InternalMessageInfo

func (m *EventValsetUpdateRequest) GetValsetNonce() uint64 {
	if m != nil {
		return m.ValsetNonce
	}
	return 0
}

func (m *EventValsetUpdateRequest) GetValsetHeight() uint64 {
	if m != nil {
		return m.ValsetHeight
	}
	return 0
}

func (m *EventValsetUpdateRequest) GetValsetMembers() []*BridgeValidator {
	if m != nil {
		return m.ValsetMembers
	}
	return nil
}

func (m *EventValsetUpdateRequest) GetRewardToken() string {
	if m != nil {
		return m.RewardToken
	}
	return ""
}

type EventSetOrchestratorAddresses struct {
	ValidatorAddress    string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,2,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
	OperatorEthAddress  string `protobuf:"bytes,3,opt,name=operator_eth_address,json=operatorEthAddress,proto3" json:"operator_eth_address,omitempty"`
}

func (m *EventSetOrchestratorAddresses) Reset()         { *m = EventSetOrchestratorAddresses{} }
func (m *EventSetOrchestratorAddresses) String() string { return proto.CompactTextString(m) }
func (*EventSetOrchestratorAddresses) ProtoMessage()    {}
func (*EventSetOrchestratorAddresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{5}
}
func (m *EventSetOrchestratorAddresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetOrchestratorAddresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetOrchestratorAddresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetOrchestratorAddresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetOrchestratorAddresses.Merge(m, src)
}
func (m *EventSetOrchestratorAddresses) XXX_Size() int {
	return m.Size()
}
func (m *EventSetOrchestratorAddresses) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetOrchestratorAddresses.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetOrchestratorAddresses proto.InternalMessageInfo

func (m *EventSetOrchestratorAddresses) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *EventSetOrchestratorAddresses) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

func (m *EventSetOrchestratorAddresses) GetOperatorEthAddress() string {
	if m != nil {
		return m.OperatorEthAddress
	}
	return ""
}

type EventValsetConfirm struct {
	ValsetNonce         uint64 `protobuf:"varint,1,opt,name=valset_nonce,json=valsetNonce,proto3" json:"valset_nonce,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,2,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *EventValsetConfirm) Reset()         { *m = EventValsetConfirm{} }
func (m *EventValsetConfirm) String() string { return proto.CompactTextString(m) }
func (*EventValsetConfirm) ProtoMessage()    {}
func (*EventValsetConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{6}
}
func (m *EventValsetConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValsetConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValsetConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValsetConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValsetConfirm.Merge(m, src)
}
func (m *EventValsetConfirm) XXX_Size() int {
	return m.Size()
}
func (m *EventValsetConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValsetConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_EventValsetConfirm proto.InternalMessageInfo

func (m *EventValsetConfirm) GetValsetNonce() uint64 {
	if m != nil {
		return m.ValsetNonce
	}
	return 0
}

func (m *EventValsetConfirm) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

type EventSendToEth struct {
	OutgoingTxId uint64                                  `protobuf:"varint,1,opt,name=outgoing_tx_id,json=outgoingTxId,proto3" json:"outgoing_tx_id,omitempty"`
	Sender       string                                  `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	Receiver     string                                  `protobuf:"bytes,3,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Amount       github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,4,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"amount"`
	BridgeFee    github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,5,opt,name=bridge_fee,json=bridgeFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"bridge_fee"`
}

func (m *EventSendToEth) Reset()         { *m = EventSendToEth{} }
func (m *EventSendToEth) String() string { return proto.CompactTextString(m) }
func (*EventSendToEth) ProtoMessage()    {}
func (*EventSendToEth) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{7}
}
func (m *EventSendToEth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSendToEth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSendToEth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSendToEth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSendToEth.Merge(m, src)
}
func (m *EventSendToEth) XXX_Size() int {
	return m.Size()
}
func (m *EventSendToEth) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSendToEth.DiscardUnknown(m)
}

var xxx_messageInfo_EventSendToEth proto.InternalMessageInfo

func (m *EventSendToEth) GetOutgoingTxId() uint64 {
	if m != nil {
		return m.OutgoingTxId
	}
	return 0
}

func (m *EventSendToEth) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EventSendToEth) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

type EventConfirmBatch struct {
	BatchNonce          uint64 `protobuf:"varint,1,opt,name=batch_nonce,json=batchNonce,proto3" json:"batch_nonce,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,2,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *EventConfirmBatch) Reset()         { *m = EventConfirmBatch{} }
func (m *EventConfirmBatch) String() string { return proto.CompactTextString(m) }
func (*EventConfirmBatch) ProtoMessage()    {}
func (*EventConfirmBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{8}
}
func (m *EventConfirmBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventConfirmBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventConfirmBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventConfirmBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventConfirmBatch.Merge(m, src)
}
func (m *EventConfirmBatch) XXX_Size() int {
	return m.Size()
}
func (m *EventConfirmBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventConfirmBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EventConfirmBatch proto.InternalMessageInfo

func (m *EventConfirmBatch) GetBatchNonce() uint64 {
	if m != nil {
		return m.BatchNonce
	}
	return 0
}

func (m *EventConfirmBatch) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

type EventAttestationVote struct {
	EventNonce    uint64 `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	AttestationId []byte `protobuf:"bytes,2,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	Voter         string `protobuf:"bytes,3,opt,name=voter,proto3" json:"voter,omitempty"`
}

func (m *EventAttestationVote) Reset()         { *m = EventAttestationVote{} }
func (m *EventAttestationVote) String() string { return proto.CompactTextString(m) }
func (*EventAttestationVote) ProtoMessage()    {}
func (*EventAttestationVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{9}
}
func (m *EventAttestationVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAttestationVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAttestationVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAttestationVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAttestationVote.Merge(m, src)
}
func (m *EventAttestationVote) XXX_Size() int {
	return m.Size()
}
func (m *EventAttestationVote) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAttestationVote.DiscardUnknown(m)
}

var xxx_messageInfo_EventAttestationVote proto.InternalMessageInfo

func (m *EventAttestationVote) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *EventAttestationVote) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

func (m *EventAttestationVote) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

type EventDepositClaim struct {
	EventNonce          uint64                `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	EventHeight         uint64                `protobuf:"varint,2,opt,name=event_height,json=eventHeight,proto3" json:"event_height,omitempty"`
	AttestationId       []byte                `protobuf:"bytes,3,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	EthereumSender      string                `protobuf:"bytes,4,opt,name=ethereum_sender,json=ethereumSender,proto3" json:"ethereum_sender,omitempty"`
	CosmosReceiver      string                `protobuf:"bytes,5,opt,name=cosmos_receiver,json=cosmosReceiver,proto3" json:"cosmos_receiver,omitempty"`
	TokenContract       string                `protobuf:"bytes,6,opt,name=token_contract,json=tokenContract,proto3" json:"token_contract,omitempty"`
	Amount              cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	OrchestratorAddress string                `protobuf:"bytes,8,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
	Data                string                `protobuf:"bytes,9,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *EventDepositClaim) Reset()         { *m = EventDepositClaim{} }
func (m *EventDepositClaim) String() string { return proto.CompactTextString(m) }
func (*EventDepositClaim) ProtoMessage()    {}
func (*EventDepositClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{10}
}
func (m *EventDepositClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDepositClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDepositClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDepositClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDepositClaim.Merge(m, src)
}
func (m *EventDepositClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventDepositClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDepositClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventDepositClaim proto.InternalMessageInfo

func (m *EventDepositClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *EventDepositClaim) GetEventHeight() uint64 {
	if m != nil {
		return m.EventHeight
	}
	return 0
}

func (m *EventDepositClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

func (m *EventDepositClaim) GetEthereumSender() string {
	if m != nil {
		return m.EthereumSender
	}
	return ""
}

func (m *EventDepositClaim) GetCosmosReceiver() string {
	if m != nil {
		return m.CosmosReceiver
	}
	return ""
}

func (m *EventDepositClaim) GetTokenContract() string {
	if m != nil {
		return m.TokenContract
	}
	return ""
}

func (m *EventDepositClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

func (m *EventDepositClaim) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type EventWithdrawClaim struct {
	EventNonce          uint64 `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	EventHeight         uint64 `protobuf:"varint,2,opt,name=event_height,json=eventHeight,proto3" json:"event_height,omitempty"`
	AttestationId       []byte `protobuf:"bytes,3,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	BatchNonce          uint64 `protobuf:"varint,4,opt,name=batch_nonce,json=batchNonce,proto3" json:"batch_nonce,omitempty"`
	TokenContract       string `protobuf:"bytes,5,opt,name=token_contract,json=tokenContract,proto3" json:"token_contract,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,6,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *EventWithdrawClaim) Reset()         { *m = EventWithdrawClaim{} }
func (m *EventWithdrawClaim) String() string { return proto.CompactTextString(m) }
func (*EventWithdrawClaim) ProtoMessage()    {}
func (*EventWithdrawClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{11}
}
func (m *EventWithdrawClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdrawClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdrawClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdrawClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdrawClaim.Merge(m, src)
}
func (m *EventWithdrawClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdrawClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdrawClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdrawClaim proto.InternalMessageInfo

func (m *EventWithdrawClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *EventWithdrawClaim) GetEventHeight() uint64 {
	if m != nil {
		return m.EventHeight
	}
	return 0
}

func (m *EventWithdrawClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

func (m *EventWithdrawClaim) GetBatchNonce() uint64 {
	if m != nil {
		return m.BatchNonce
	}
	return 0
}

func (m *EventWithdrawClaim) GetTokenContract() string {
	if m != nil {
		return m.TokenContract
	}
	return ""
}

func (m *EventWithdrawClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

type EventERC20DeployedClaim struct {
	EventNonce          uint64 `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	EventHeight         uint64 `protobuf:"varint,2,opt,name=event_height,json=eventHeight,proto3" json:"event_height,omitempty"`
	AttestationId       []byte `protobuf:"bytes,3,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	CosmosDenom         string `protobuf:"bytes,4,opt,name=cosmos_denom,json=cosmosDenom,proto3" json:"cosmos_denom,omitempty"`
	TokenContract       string `protobuf:"bytes,5,opt,name=token_contract,json=tokenContract,proto3" json:"token_contract,omitempty"`
	Name                string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Symbol              string `protobuf:"bytes,7,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Decimals            uint64 `protobuf:"varint,8,opt,name=decimals,proto3" json:"decimals,omitempty"`
	OrchestratorAddress string `protobuf:"bytes,9,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *EventERC20DeployedClaim) Reset()         { *m = EventERC20DeployedClaim{} }
func (m *EventERC20DeployedClaim) String() string { return proto.CompactTextString(m) }
func (*EventERC20DeployedClaim) ProtoMessage()    {}
func (*EventERC20DeployedClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{12}
}
func (m *EventERC20DeployedClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventERC20DeployedClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventERC20DeployedClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventERC20DeployedClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventERC20DeployedClaim.Merge(m, src)
}
func (m *EventERC20DeployedClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventERC20DeployedClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventERC20DeployedClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventERC20DeployedClaim proto.InternalMessageInfo

func (m *EventERC20DeployedClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *EventERC20DeployedClaim) GetEventHeight() uint64 {
	if m != nil {
		return m.EventHeight
	}
	return 0
}

func (m *EventERC20DeployedClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

func (m *EventERC20DeployedClaim) GetCosmosDenom() string {
	if m != nil {
		return m.CosmosDenom
	}
	return ""
}

func (m *EventERC20DeployedClaim) GetTokenContract() string {
	if m != nil {
		return m.TokenContract
	}
	return ""
}

func (m *EventERC20DeployedClaim) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventERC20DeployedClaim) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *EventERC20DeployedClaim) GetDecimals() uint64 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *EventERC20DeployedClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

type EventValsetUpdateClaim struct {
	EventNonce          uint64                `protobuf:"varint,1,opt,name=event_nonce,json=eventNonce,proto3" json:"event_nonce,omitempty"`
	EventHeight         uint64                `protobuf:"varint,2,opt,name=event_height,json=eventHeight,proto3" json:"event_height,omitempty"`
	AttestationId       []byte                `protobuf:"bytes,3,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	ValsetNonce         uint64                `protobuf:"varint,4,opt,name=valset_nonce,json=valsetNonce,proto3" json:"valset_nonce,omitempty"`
	ValsetMembers       []*BridgeValidator    `protobuf:"bytes,5,rep,name=valset_members,json=valsetMembers,proto3" json:"valset_members,omitempty"`
	RewardAmount        cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=reward_amount,json=rewardAmount,proto3,customtype=cosmossdk.io/math.Int" json:"reward_amount"`
	RewardToken         string                `protobuf:"bytes,7,opt,name=reward_token,json=rewardToken,proto3" json:"reward_token,omitempty"`
	OrchestratorAddress string                `protobuf:"bytes,8,opt,name=orchestrator_address,json=orchestratorAddress,proto3" json:"orchestrator_address,omitempty"`
}

func (m *EventValsetUpdateClaim) Reset()         { *m = EventValsetUpdateClaim{} }
func (m *EventValsetUpdateClaim) String() string { return proto.CompactTextString(m) }
func (*EventValsetUpdateClaim) ProtoMessage()    {}
func (*EventValsetUpdateClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{13}
}
func (m *EventValsetUpdateClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValsetUpdateClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValsetUpdateClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValsetUpdateClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValsetUpdateClaim.Merge(m, src)
}
func (m *EventValsetUpdateClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventValsetUpdateClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValsetUpdateClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventValsetUpdateClaim proto.InternalMessageInfo

func (m *EventValsetUpdateClaim) GetEventNonce() uint64 {
	if m != nil {
		return m.EventNonce
	}
	return 0
}

func (m *EventValsetUpdateClaim) GetEventHeight() uint64 {
	if m != nil {
		return m.EventHeight
	}
	return 0
}

func (m *EventValsetUpdateClaim) GetAttestationId() []byte {
	if m != nil {
		return m.AttestationId
	}
	return nil
}

func (m *EventValsetUpdateClaim) GetValsetNonce() uint64 {
	if m != nil {
		return m.ValsetNonce
	}
	return 0
}

func (m *EventValsetUpdateClaim) GetValsetMembers() []*BridgeValidator {
	if m != nil {
		return m.ValsetMembers
	}
	return nil
}

func (m *EventValsetUpdateClaim) GetRewardToken() string {
	if m != nil {
		return m.RewardToken
	}
	return ""
}

func (m *EventValsetUpdateClaim) GetOrchestratorAddress() string {
	if m != nil {
		return m.OrchestratorAddress
	}
	return ""
}

type EventCancelSendToEth struct {
	OutgoingTxId uint64 `protobuf:"varint,1,opt,name=outgoing_tx_id,json=outgoingTxId,proto3" json:"outgoing_tx_id,omitempty"`
}

func (m *EventCancelSendToEth) Reset()         { *m = EventCancelSendToEth{} }
func (m *EventCancelSendToEth) String() string { return proto.CompactTextString(m) }
func (*EventCancelSendToEth) ProtoMessage()    {}
func (*EventCancelSendToEth) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{14}
}
func (m *EventCancelSendToEth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCancelSendToEth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCancelSendToEth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCancelSendToEth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCancelSendToEth.Merge(m, src)
}
func (m *EventCancelSendToEth) XXX_Size() int {
	return m.Size()
}
func (m *EventCancelSendToEth) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCancelSendToEth.DiscardUnknown(m)
}

var xxx_messageInfo_EventCancelSendToEth proto.InternalMessageInfo

func (m *EventCancelSendToEth) GetOutgoingTxId() uint64 {
	if m != nil {
		return m.OutgoingTxId
	}
	return 0
}

type EventSubmitBadSignatureEvidence struct {
	BadEthSignature        string `protobuf:"bytes,1,opt,name=bad_eth_signature,json=badEthSignature,proto3" json:"bad_eth_signature,omitempty"`
	BadEthSignatureSubject string `protobuf:"bytes,2,opt,name=bad_eth_signature_subject,json=badEthSignatureSubject,proto3" json:"bad_eth_signature_subject,omitempty"`
}

func (m *EventSubmitBadSignatureEvidence) Reset()         { *m = EventSubmitBadSignatureEvidence{} }
func (m *EventSubmitBadSignatureEvidence) String() string { return proto.CompactTextString(m) }
func (*EventSubmitBadSignatureEvidence) ProtoMessage()    {}
func (*EventSubmitBadSignatureEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{15}
}
func (m *EventSubmitBadSignatureEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSubmitBadSignatureEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSubmitBadSignatureEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSubmitBadSignatureEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSubmitBadSignatureEvidence.Merge(m, src)
}
func (m *EventSubmitBadSignatureEvidence) XXX_Size() int {
	return m.Size()
}
func (m *EventSubmitBadSignatureEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSubmitBadSignatureEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_EventSubmitBadSignatureEvidence proto.InternalMessageInfo

func (m *EventSubmitBadSignatureEvidence) GetBadEthSignature() string {
	if m != nil {
		return m.BadEthSignature
	}
	return ""
}

func (m *EventSubmitBadSignatureEvidence) GetBadEthSignatureSubject() string {
	if m != nil {
		return m.BadEthSignatureSubject
	}
	return ""
}

type EventValidatorSlash struct {
	Power            int64  `protobuf:"varint,1,opt,name=power,proto3" json:"power,omitempty"`
	Reason           string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	ConsensusAddress string `protobuf:"bytes,3,opt,name=consensus_address,json=consensusAddress,proto3" json:"consensus_address,omitempty"`
	OperatorAddress  string `protobuf:"bytes,4,opt,name=operator_address,json=operatorAddress,proto3" json:"operator_address,omitempty"`
	Moniker          string `protobuf:"bytes,5,opt,name=moniker,proto3" json:"moniker,omitempty"`
}

func (m *EventValidatorSlash) Reset()         { *m = EventValidatorSlash{} }
func (m *EventValidatorSlash) String() string { return proto.CompactTextString(m) }
func (*EventValidatorSlash) ProtoMessage()    {}
func (*EventValidatorSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{16}
}
func (m *EventValidatorSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventValidatorSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventValidatorSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventValidatorSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventValidatorSlash.Merge(m, src)
}
func (m *EventValidatorSlash) XXX_Size() int {
	return m.Size()
}
func (m *EventValidatorSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_EventValidatorSlash.DiscardUnknown(m)
}

var xxx_messageInfo_EventValidatorSlash proto.InternalMessageInfo

func (m *EventValidatorSlash) GetPower() int64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *EventValidatorSlash) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventValidatorSlash) GetConsensusAddress() string {
	if m != nil {
		return m.ConsensusAddress
	}
	return ""
}

func (m *EventValidatorSlash) GetOperatorAddress() string {
	if m != nil {
		return m.OperatorAddress
	}
	return ""
}

func (m *EventValidatorSlash) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

type EventDepositReceived struct {
	// Ethereum sender address
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Injective receiver address
	Receiver string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	// Coin deposited to Injective
	Amount github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"amount"`
}

func (m *EventDepositReceived) Reset()         { *m = EventDepositReceived{} }
func (m *EventDepositReceived) String() string { return proto.CompactTextString(m) }
func (*EventDepositReceived) ProtoMessage()    {}
func (*EventDepositReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{17}
}
func (m *EventDepositReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDepositReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDepositReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDepositReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDepositReceived.Merge(m, src)
}
func (m *EventDepositReceived) XXX_Size() int {
	return m.Size()
}
func (m *EventDepositReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDepositReceived.DiscardUnknown(m)
}

var xxx_messageInfo_EventDepositReceived proto.InternalMessageInfo

func (m *EventDepositReceived) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EventDepositReceived) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

type EventWithdrawalsCompleted struct {
	// token denom of each withdrawal
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// individual withdrawals
	Withdrawals []*Withdrawal `protobuf:"bytes,2,rep,name=withdrawals,proto3" json:"withdrawals,omitempty"`
}

func (m *EventWithdrawalsCompleted) Reset()         { *m = EventWithdrawalsCompleted{} }
func (m *EventWithdrawalsCompleted) String() string { return proto.CompactTextString(m) }
func (*EventWithdrawalsCompleted) ProtoMessage()    {}
func (*EventWithdrawalsCompleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{18}
}
func (m *EventWithdrawalsCompleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdrawalsCompleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdrawalsCompleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdrawalsCompleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdrawalsCompleted.Merge(m, src)
}
func (m *EventWithdrawalsCompleted) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdrawalsCompleted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdrawalsCompleted.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdrawalsCompleted proto.InternalMessageInfo

func (m *EventWithdrawalsCompleted) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *EventWithdrawalsCompleted) GetWithdrawals() []*Withdrawal {
	if m != nil {
		return m.Withdrawals
	}
	return nil
}

type Withdrawal struct {
	// Injective sender address
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Ethereum receiver address
	Receiver string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	// Amount of tokens withdrawn to Ethereum
	Amount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *Withdrawal) Reset()         { *m = Withdrawal{} }
func (m *Withdrawal) String() string { return proto.CompactTextString(m) }
func (*Withdrawal) ProtoMessage()    {}
func (*Withdrawal) Descriptor() ([]byte, []int) {
	return fileDescriptor_95f217691d2f42c2, []int{19}
}
func (m *Withdrawal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Withdrawal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Withdrawal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Withdrawal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Withdrawal.Merge(m, src)
}
func (m *Withdrawal) XXX_Size() int {
	return m.Size()
}
func (m *Withdrawal) XXX_DiscardUnknown() {
	xxx_messageInfo_Withdrawal.DiscardUnknown(m)
}

var xxx_messageInfo_Withdrawal proto.InternalMessageInfo

func (m *Withdrawal) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Withdrawal) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func init() {
	proto.RegisterType((*EventAttestationObserved)(nil), "injective.peggy.v1.EventAttestationObserved")
	proto.RegisterType((*EventBridgeWithdrawCanceled)(nil), "injective.peggy.v1.EventBridgeWithdrawCanceled")
	proto.RegisterType((*EventOutgoingBatch)(nil), "injective.peggy.v1.EventOutgoingBatch")
	proto.RegisterType((*EventOutgoingBatchCanceled)(nil), "injective.peggy.v1.EventOutgoingBatchCanceled")
	proto.RegisterType((*EventValsetUpdateRequest)(nil), "injective.peggy.v1.EventValsetUpdateRequest")
	proto.RegisterType((*EventSetOrchestratorAddresses)(nil), "injective.peggy.v1.EventSetOrchestratorAddresses")
	proto.RegisterType((*EventValsetConfirm)(nil), "injective.peggy.v1.EventValsetConfirm")
	proto.RegisterType((*EventSendToEth)(nil), "injective.peggy.v1.EventSendToEth")
	proto.RegisterType((*EventConfirmBatch)(nil), "injective.peggy.v1.EventConfirmBatch")
	proto.RegisterType((*EventAttestationVote)(nil), "injective.peggy.v1.EventAttestationVote")
	proto.RegisterType((*EventDepositClaim)(nil), "injective.peggy.v1.EventDepositClaim")
	proto.RegisterType((*EventWithdrawClaim)(nil), "injective.peggy.v1.EventWithdrawClaim")
	proto.RegisterType((*EventERC20DeployedClaim)(nil), "injective.peggy.v1.EventERC20DeployedClaim")
	proto.RegisterType((*EventValsetUpdateClaim)(nil), "injective.peggy.v1.EventValsetUpdateClaim")
	proto.RegisterType((*EventCancelSendToEth)(nil), "injective.peggy.v1.EventCancelSendToEth")
	proto.RegisterType((*EventSubmitBadSignatureEvidence)(nil), "injective.peggy.v1.EventSubmitBadSignatureEvidence")
	proto.RegisterType((*EventValidatorSlash)(nil), "injective.peggy.v1.EventValidatorSlash")
	proto.RegisterType((*EventDepositReceived)(nil), "injective.peggy.v1.EventDepositReceived")
	proto.RegisterType((*EventWithdrawalsCompleted)(nil), "injective.peggy.v1.EventWithdrawalsCompleted")
	proto.RegisterType((*Withdrawal)(nil), "injective.peggy.v1.Withdrawal")
}

func init() { proto.RegisterFile("injective/peggy/v1/events.proto", fileDescriptor_95f217691d2f42c2) }

var fileDescriptor_95f217691d2f42c2 = []byte{
	// 1340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xcf, 0xda, 0x4e, 0xd2, 0xbc, 0x38, 0x4e, 0x3a, 0xcd, 0xb7, 0x5f, 0x37, 0xa8, 0x8e, 0xbb,
	0x6d, 0x49, 0x00, 0xd5, 0x6e, 0x8b, 0x7a, 0x40, 0xe2, 0x40, 0xe3, 0x06, 0x1a, 0x7e, 0xb4, 0xd2,
	0x26, 0x14, 0x89, 0x8b, 0x35, 0xde, 0x79, 0xf5, 0x4e, 0xe3, 0xdd, 0x31, 0x3b, 0x63, 0xa7, 0x39,
	0x73, 0xe1, 0xc0, 0x01, 0x09, 0x71, 0xe5, 0x7f, 0xe0, 0xc0, 0x9f, 0x80, 0x54, 0x6e, 0x3d, 0x22,
	0x0e, 0x15, 0x6a, 0xfe, 0x03, 0x24, 0x2e, 0x9c, 0xd0, 0xce, 0xcc, 0x6e, 0x9c, 0xac, 0x2d, 0xd2,
	0x14, 0xca, 0xc9, 0x9e, 0x37, 0xef, 0xbd, 0x79, 0xf3, 0x79, 0x9f, 0x79, 0xef, 0x2d, 0xac, 0xf2,
	0xe8, 0x11, 0xfa, 0x8a, 0x0f, 0xb1, 0xd9, 0xc7, 0x6e, 0x77, 0xbf, 0x39, 0xbc, 0xd1, 0xc4, 0x21,
	0x46, 0x4a, 0x36, 0xfa, 0xb1, 0x50, 0x82, 0x90, 0x4c, 0xa1, 0xa1, 0x15, 0x1a, 0xc3, 0x1b, 0x2b,
	0xcb, 0x5d, 0xd1, 0x15, 0x7a, 0xbb, 0x99, 0xfc, 0x33, 0x9a, 0x2b, 0x57, 0xc6, 0xb8, 0xa2, 0x4a,
	0xa1, 0x54, 0x54, 0x71, 0x11, 0x59, 0xad, 0xda, 0x18, 0x2d, 0xb5, 0xdf, 0x47, 0x7b, 0x9e, 0xfb,
	0xbb, 0x03, 0xd5, 0xcd, 0x24, 0x80, 0xdb, 0x87, 0xa6, 0xf7, 0x3b, 0x12, 0xe3, 0x21, 0x32, 0x72,
	0x17, 0x96, 0x46, 0x3c, 0xb6, 0x13, 0xbb, 0xaa, 0x53, 0x77, 0xd6, 0x2b, 0x37, 0x2f, 0x36, 0xf2,
	0x71, 0x36, 0x5a, 0x3d, 0xca, 0xc3, 0x9d, 0xfd, 0x3e, 0x7a, 0x8b, 0x23, 0x66, 0x89, 0x80, 0xac,
	0xc1, 0x62, 0x27, 0xe6, 0xac, 0x8b, 0x6d, 0x5f, 0x44, 0x2a, 0xa6, 0xbe, 0xaa, 0x16, 0xea, 0xce,
	0xfa, 0x9c, 0x57, 0x31, 0xe2, 0x96, 0x95, 0x92, 0xd7, 0x0f, 0x15, 0x03, 0xca, 0xa3, 0x36, 0x67,
	0xd5, 0x62, 0xdd, 0x59, 0x2f, 0x79, 0x0b, 0x56, 0x31, 0x91, 0x6e, 0x31, 0x72, 0x15, 0x2a, 0xa3,
	0xa1, 0x71, 0x56, 0x2d, 0xd5, 0x9d, 0xf5, 0xb2, 0xb7, 0x30, 0x22, 0xdd, 0x62, 0x64, 0x19, 0xa6,
	0x23, 0x11, 0xf9, 0x58, 0x9d, 0xd6, 0x4e, 0xcc, 0xc2, 0x8d, 0xe0, 0x35, 0x7d, 0xe7, 0x0d, 0xed,
	0xf2, 0x33, 0xae, 0x02, 0x16, 0xd3, 0xbd, 0x16, 0x8d, 0x7c, 0xec, 0x21, 0x1b, 0x17, 0xac, 0x73,
	0xd2, 0x60, 0x0b, 0x63, 0x82, 0x75, 0x7f, 0x72, 0x80, 0xe8, 0x03, 0xef, 0x0f, 0x54, 0x57, 0xf0,
	0xa8, 0xbb, 0x41, 0x95, 0x1f, 0x24, 0xc1, 0x31, 0x8c, 0x44, 0x68, 0xbd, 0x9b, 0x05, 0xb9, 0x01,
	0xcb, 0x22, 0xf6, 0x03, 0x94, 0x2a, 0xa6, 0x4a, 0xc4, 0x6d, 0xca, 0x58, 0x8c, 0x52, 0x5a, 0xbc,
	0xce, 0x8d, 0xee, 0xdd, 0x36, 0x5b, 0x64, 0x15, 0xe6, 0x3b, 0x89, 0xc7, 0xb6, 0xb9, 0xab, 0x01,
	0x0c, 0xb4, 0xe8, 0x5e, 0x22, 0x21, 0x97, 0x61, 0xc1, 0x28, 0x28, 0x1e, 0xa2, 0x18, 0x28, 0x0d,
	0x56, 0xc9, 0x2b, 0x6b, 0xe1, 0x8e, 0x91, 0x91, 0x3a, 0x94, 0xad, 0xd2, 0xe3, 0x36, 0x67, 0xb2,
	0x3a, 0x5d, 0x2f, 0x66, 0x6e, 0x76, 0x1e, 0x6f, 0x31, 0xe9, 0x7e, 0xef, 0xc0, 0x4a, 0xfe, 0x1e,
	0xff, 0x1a, 0x6e, 0xe4, 0x02, 0x9c, 0x31, 0x11, 0x65, 0x2c, 0x98, 0xd5, 0xeb, 0xd1, 0xc4, 0x96,
	0x46, 0x13, 0xfb, 0x5d, 0xc1, 0xb2, 0xf9, 0x01, 0xed, 0x49, 0x54, 0x9f, 0xf6, 0x19, 0x55, 0xe8,
	0xe1, 0x17, 0x03, 0x94, 0x8a, 0x5c, 0x82, 0xf2, 0x50, 0x8b, 0x2d, 0x4c, 0x8e, 0xb6, 0x9c, 0x37,
	0xb2, 0x0c, 0x27, 0xab, 0x12, 0x20, 0xef, 0x06, 0xca, 0x86, 0x65, 0xed, 0xee, 0x6a, 0x19, 0xf9,
	0x10, 0x2a, 0x56, 0x29, 0xc4, 0xb0, 0x83, 0xb1, 0xac, 0x16, 0xeb, 0xc5, 0xf5, 0xf9, 0x9b, 0x97,
	0xc7, 0xbd, 0x09, 0x43, 0xb1, 0x07, 0xb4, 0xc7, 0x59, 0x92, 0x31, 0xcf, 0xfa, 0xff, 0xc4, 0x58,
	0x92, 0x0d, 0x58, 0x88, 0x71, 0x8f, 0xc6, 0xac, 0x4d, 0x43, 0x31, 0x88, 0x4c, 0x62, 0xe6, 0x36,
	0x2e, 0x3e, 0x79, 0xb6, 0x3a, 0xf5, 0xeb, 0xb3, 0xd5, 0xff, 0xf9, 0x42, 0x86, 0x42, 0x4a, 0xb6,
	0xdb, 0xe0, 0xa2, 0x19, 0x52, 0x15, 0x34, 0xb6, 0x22, 0xe5, 0x95, 0x8d, 0xcd, 0x6d, 0x6d, 0x92,
	0xdc, 0xcb, 0xfa, 0x50, 0x62, 0x17, 0x23, 0x4d, 0xf5, 0x39, 0x6f, 0xde, 0xc8, 0x76, 0x12, 0x91,
	0xfb, 0x83, 0x03, 0x17, 0x35, 0x2e, 0xdb, 0xa8, 0xee, 0xe7, 0x09, 0x84, 0x92, 0xbc, 0x05, 0x67,
	0x87, 0x69, 0x90, 0x19, 0xe5, 0x4c, 0xf6, 0x96, 0xb2, 0x8d, 0x94, 0x6f, 0xa7, 0xa0, 0xe8, 0x75,
	0x58, 0x16, 0x7d, 0x34, 0xea, 0xa8, 0x82, 0xcc, 0xa4, 0xa8, 0x4d, 0x48, 0xba, 0xb7, 0xa9, 0x02,
	0x6b, 0xe1, 0x3e, 0xb2, 0x6f, 0xc6, 0xa4, 0xb2, 0x25, 0xa2, 0x87, 0x3c, 0x0e, 0x4f, 0x92, 0xc4,
	0x17, 0x8f, 0xce, 0xfd, 0xb2, 0x00, 0x15, 0x8b, 0x4f, 0xc4, 0x76, 0xc4, 0xa6, 0x0a, 0xc8, 0x15,
	0xa8, 0x08, 0xcb, 0x72, 0xf3, 0x20, 0xec, 0x51, 0xe5, 0x54, 0x9a, 0x3c, 0x09, 0x72, 0x1e, 0x66,
	0x24, 0x46, 0x0c, 0x63, 0xeb, 0xdd, 0xae, 0xc8, 0x0a, 0x9c, 0x89, 0xd1, 0x47, 0x3e, 0xc4, 0xd8,
	0x5e, 0x31, 0x5b, 0x93, 0x0f, 0x60, 0xe6, 0x48, 0xb2, 0x9b, 0x36, 0xd9, 0x6b, 0x5d, 0xae, 0x82,
	0x41, 0xa7, 0xe1, 0x8b, 0xb0, 0x69, 0xf2, 0x6e, 0x7f, 0xae, 0x49, 0xb6, 0x6b, 0x8b, 0x76, 0x4b,
	0xf0, 0xc8, 0xb3, 0xe6, 0xe4, 0x1e, 0x80, 0x7d, 0x46, 0x0f, 0xd1, 0x54, 0xb8, 0x53, 0x38, 0x9b,
	0x33, 0x2e, 0xde, 0x47, 0x74, 0xbb, 0x70, 0x56, 0x83, 0x60, 0xb1, 0x36, 0x45, 0xea, 0x58, 0x6d,
	0x71, 0x72, 0xb5, 0xe5, 0x14, 0x70, 0x2b, 0x58, 0x3e, 0xde, 0x73, 0x1e, 0x08, 0x85, 0xc9, 0x59,
	0xba, 0x19, 0x1e, 0x3d, 0x4b, 0x8b, 0xcc, 0x59, 0xf9, 0xaa, 0x5f, 0x98, 0x50, 0xf5, 0x87, 0x42,
	0x65, 0xd0, 0x9b, 0x85, 0xfb, 0x47, 0xc1, 0xde, 0xef, 0x0e, 0xf6, 0x85, 0xe4, 0x4a, 0xb7, 0xab,
	0xbf, 0x3f, 0xf3, 0x12, 0x94, 0x8d, 0xc2, 0x91, 0x92, 0x60, 0x8c, 0x6c, 0x45, 0xc8, 0x87, 0x55,
	0x1c, 0x17, 0xd6, 0x1a, 0x2c, 0xa2, 0x0a, 0x30, 0xc6, 0x41, 0xd8, 0xb6, 0xac, 0x29, 0x99, 0xfa,
	0x98, 0x8a, 0xb7, 0x0d, 0x7b, 0xd6, 0x60, 0xd1, 0x24, 0xab, 0x9d, 0x91, 0xc8, 0x3c, 0xea, 0x8a,
	0x11, 0x7b, 0x29, 0x95, 0xae, 0x42, 0x45, 0xbf, 0xf9, 0xc3, 0x82, 0x3b, 0xa3, 0xf5, 0x16, 0xb4,
	0x34, 0xab, 0xb7, 0xb7, 0x32, 0xc6, 0xcd, 0x9e, 0xa4, 0xbc, 0xa4, 0xfc, 0x9a, 0x94, 0xd9, 0x33,
	0x93, 0x9f, 0x39, 0x81, 0x12, 0xa3, 0x8a, 0x56, 0xe7, 0xb4, 0x8a, 0xfe, 0xef, 0xfe, 0x99, 0x76,
	0xbf, 0xac, 0xd1, 0xbe, 0x6a, 0xe0, 0x8f, 0x71, 0xb8, 0x94, 0xe3, 0x70, 0x1e, 0xc7, 0xe9, 0x71,
	0x38, 0x4e, 0x02, 0x64, 0x66, 0x32, 0xd5, 0x7f, 0x2e, 0xc0, 0xff, 0xf5, 0xe5, 0x37, 0xbd, 0xd6,
	0xcd, 0xeb, 0x77, 0xb0, 0xdf, 0x13, 0xfb, 0xc8, 0x5e, 0x39, 0x02, 0x97, 0xa0, 0x6c, 0x19, 0x65,
	0x26, 0x0e, 0xc3, 0xbb, 0x79, 0x23, 0xbb, 0xa3, 0xe7, 0x8e, 0x13, 0x62, 0x40, 0xa0, 0x14, 0xd1,
	0x10, 0xed, 0x9d, 0xf5, 0x7f, 0x5d, 0x05, 0xf7, 0xc3, 0x8e, 0xe8, 0x19, 0x7e, 0x79, 0x76, 0x95,
	0x54, 0x41, 0x86, 0x3e, 0x0f, 0x69, 0xcf, 0x90, 0xa6, 0xe4, 0x65, 0xeb, 0x89, 0x58, 0xce, 0x4d,
	0xc6, 0xf2, 0xeb, 0x22, 0x9c, 0xcf, 0x75, 0xf7, 0xff, 0x02, 0xca, 0x23, 0x1d, 0xa8, 0x94, 0xef,
	0x40, 0xf9, 0x09, 0x61, 0xfa, 0x9f, 0x9b, 0x10, 0x66, 0x5e, 0x7e, 0x42, 0x98, 0xcd, 0x4d, 0x08,
	0xa7, 0x78, 0xeb, 0xee, 0xbb, 0xb6, 0x8a, 0x9b, 0xf9, 0xef, 0x05, 0x3b, 0xa7, 0xfb, 0x95, 0x03,
	0xab, 0xa6, 0xe5, 0x0e, 0x3a, 0x21, 0x57, 0x1b, 0x94, 0x6d, 0xf3, 0x6e, 0x44, 0xd5, 0x20, 0xc6,
	0xcd, 0x21, 0x67, 0x98, 0xe0, 0xf8, 0x26, 0x9c, 0xed, 0x50, 0xa6, 0xe7, 0x05, 0x99, 0x6e, 0xda,
	0xa1, 0x64, 0xb1, 0x43, 0xd9, 0xa6, 0x0a, 0x32, 0x1b, 0xf2, 0x0e, 0x5c, 0xc8, 0xe9, 0xb6, 0xe5,
	0xa0, 0x93, 0xe0, 0x6d, 0x7b, 0xd1, 0xf9, 0x63, 0x36, 0xdb, 0x66, 0xd7, 0xfd, 0xd1, 0x81, 0x73,
	0x29, 0xaf, 0x4c, 0x12, 0xb6, 0x7b, 0x54, 0xea, 0xf9, 0xbc, 0x2f, 0xf6, 0x30, 0xd6, 0x47, 0x16,
	0x3d, 0xb3, 0x48, 0xc8, 0x1e, 0x23, 0x95, 0x22, 0x4a, 0x5b, 0xbe, 0x59, 0x25, 0x13, 0x94, 0x2f,
	0x22, 0x89, 0x91, 0x1c, 0xc8, 0x63, 0xe3, 0xcd, 0x52, 0xb6, 0x91, 0xd6, 0xc9, 0x37, 0x60, 0x29,
	0x1b, 0x87, 0x52, 0x5d, 0xf3, 0x26, 0x17, 0x53, 0x79, 0xaa, 0x5a, 0x85, 0xd9, 0x50, 0x44, 0x7c,
	0x37, 0x6b, 0x02, 0xe9, 0xd2, 0xfd, 0xd6, 0xb1, 0x19, 0xb0, 0x0d, 0xcd, 0xb6, 0x85, 0xd1, 0xa9,
	0xc4, 0x99, 0x38, 0x95, 0x14, 0x26, 0x4e, 0x25, 0xc5, 0x97, 0x9a, 0x4a, 0x5c, 0x09, 0x17, 0x8e,
	0x54, 0x7b, 0xda, 0x93, 0x2d, 0x11, 0xf6, 0x7b, 0xa8, 0x90, 0x4d, 0xf8, 0xe4, 0x79, 0x0f, 0xe6,
	0xf7, 0x0e, 0xb5, 0xab, 0x05, 0xfd, 0x58, 0x6a, 0xe3, 0x1e, 0xcb, 0xa1, 0x53, 0x6f, 0xd4, 0xc4,
	0xdd, 0x03, 0x38, 0xdc, 0x3a, 0xd5, 0xfd, 0x6f, 0x1d, 0xbb, 0xff, 0xc9, 0x7a, 0xe4, 0x06, 0x3e,
	0x79, 0x5e, 0x73, 0x9e, 0x3e, 0xaf, 0x39, 0xbf, 0x3d, 0xaf, 0x39, 0xdf, 0x1c, 0xd4, 0xa6, 0x9e,
	0x1e, 0xd4, 0xa6, 0x7e, 0x39, 0xa8, 0x4d, 0x7d, 0xfe, 0xd1, 0x08, 0x70, 0x5b, 0xe9, 0x4d, 0x3e,
	0xa6, 0x1d, 0xd9, 0xcc, 0xee, 0x75, 0xcd, 0x17, 0x31, 0x8e, 0x2e, 0x93, 0xef, 0x9e, 0x66, 0x28,
	0xd8, 0xa0, 0x87, 0xd2, 0x7e, 0xaf, 0x6b, 0x84, 0x3b, 0x33, 0xfa, 0x6b, 0xfd, 0xed, 0xbf, 0x02,
	0x00, 0x00, 0xff, 0xff, 0xb0, 0x7a, 0xbb, 0x0c, 0x40, 0x10, 0x00, 0x00,
}

func (m *EventAttestationObserved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAttestationObserved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAttestationObserved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x22
	}
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0x12
	}
	if m.AttestationType != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AttestationType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBridgeWithdrawCanceled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBridgeWithdrawCanceled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBridgeWithdrawCanceled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutgoingBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutgoingBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutgoingBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchTxIds) > 0 {
		dAtA2 := make([]byte, len(m.BatchTxIds)*10)
		var j1 int
		for _, num := range m.BatchTxIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintEvents(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if m.BatchTimeout != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchNonce))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutgoingBatchCanceled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutgoingBatchCanceled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutgoingBatchCanceled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x18
	}
	if m.BridgeChainId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BridgeChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BridgeContract) > 0 {
		i -= len(m.BridgeContract)
		copy(dAtA[i:], m.BridgeContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValsetUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValsetUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValsetUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardToken) > 0 {
		i -= len(m.RewardToken)
		copy(dAtA[i:], m.RewardToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RewardToken)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.RewardAmount.Size()
		i -= size
		if _, err := m.RewardAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ValsetMembers) > 0 {
		for iNdEx := len(m.ValsetMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValsetMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ValsetHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ValsetHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.ValsetNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ValsetNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventSetOrchestratorAddresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetOrchestratorAddresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetOrchestratorAddresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorEthAddress) > 0 {
		i -= len(m.OperatorEthAddress)
		copy(dAtA[i:], m.OperatorEthAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OperatorEthAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValsetConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValsetConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValsetConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.ValsetNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ValsetNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventSendToEth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSendToEth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSendToEth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BridgeFee.Size()
		i -= size
		if _, err := m.BridgeFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.OutgoingTxId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OutgoingTxId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventConfirmBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventConfirmBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventConfirmBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.BatchNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventAttestationVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAttestationVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAttestationVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x12
	}
	if m.EventNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventDepositClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDepositClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDepositClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.TokenContract) > 0 {
		i -= len(m.TokenContract)
		copy(dAtA[i:], m.TokenContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TokenContract)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CosmosReceiver) > 0 {
		i -= len(m.CosmosReceiver)
		copy(dAtA[i:], m.CosmosReceiver)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CosmosReceiver)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EthereumSender) > 0 {
		i -= len(m.EthereumSender)
		copy(dAtA[i:], m.EthereumSender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.EthereumSender)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventWithdrawClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdrawClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdrawClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TokenContract) > 0 {
		i -= len(m.TokenContract)
		copy(dAtA[i:], m.TokenContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TokenContract)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BatchNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BatchNonce))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventERC20DeployedClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventERC20DeployedClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventERC20DeployedClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Decimals != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TokenContract) > 0 {
		i -= len(m.TokenContract)
		copy(dAtA[i:], m.TokenContract)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TokenContract)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CosmosDenom) > 0 {
		i -= len(m.CosmosDenom)
		copy(dAtA[i:], m.CosmosDenom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CosmosDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventValsetUpdateClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValsetUpdateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValsetUpdateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrchestratorAddress) > 0 {
		i -= len(m.OrchestratorAddress)
		copy(dAtA[i:], m.OrchestratorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OrchestratorAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RewardToken) > 0 {
		i -= len(m.RewardToken)
		copy(dAtA[i:], m.RewardToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RewardToken)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.RewardAmount.Size()
		i -= size
		if _, err := m.RewardAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.ValsetMembers) > 0 {
		for iNdEx := len(m.ValsetMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValsetMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ValsetNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ValsetNonce))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EventNonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.EventNonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventCancelSendToEth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCancelSendToEth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCancelSendToEth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutgoingTxId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OutgoingTxId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventSubmitBadSignatureEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSubmitBadSignatureEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSubmitBadSignatureEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BadEthSignatureSubject) > 0 {
		i -= len(m.BadEthSignatureSubject)
		copy(dAtA[i:], m.BadEthSignatureSubject)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BadEthSignatureSubject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BadEthSignature) > 0 {
		i -= len(m.BadEthSignature)
		copy(dAtA[i:], m.BadEthSignature)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BadEthSignature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventValidatorSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventValidatorSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventValidatorSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ConsensusAddress) > 0 {
		i -= len(m.ConsensusAddress)
		copy(dAtA[i:], m.ConsensusAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ConsensusAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Power != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventDepositReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDepositReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDepositReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventWithdrawalsCompleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdrawalsCompleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdrawalsCompleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Withdrawals) > 0 {
		for iNdEx := len(m.Withdrawals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Withdrawals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Withdrawal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventAttestationObserved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestationType != 0 {
		n += 1 + sovEvents(uint64(m.AttestationType))
	}
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	return n
}

func (m *EventBridgeWithdrawCanceled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	return n
}

func (m *EventOutgoingBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BatchNonce != 0 {
		n += 1 + sovEvents(uint64(m.BatchNonce))
	}
	if m.BatchTimeout != 0 {
		n += 1 + sovEvents(uint64(m.BatchTimeout))
	}
	if len(m.BatchTxIds) > 0 {
		l = 0
		for _, e := range m.BatchTxIds {
			l += sovEvents(uint64(e))
		}
		n += 1 + sovEvents(uint64(l)) + l
	}
	return n
}

func (m *EventOutgoingBatchCanceled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BridgeContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BridgeChainId != 0 {
		n += 1 + sovEvents(uint64(m.BridgeChainId))
	}
	if m.BatchId != 0 {
		n += 1 + sovEvents(uint64(m.BatchId))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	return n
}

func (m *EventValsetUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValsetNonce != 0 {
		n += 1 + sovEvents(uint64(m.ValsetNonce))
	}
	if m.ValsetHeight != 0 {
		n += 1 + sovEvents(uint64(m.ValsetHeight))
	}
	if len(m.ValsetMembers) > 0 {
		for _, e := range m.ValsetMembers {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	l = m.RewardAmount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.RewardToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSetOrchestratorAddresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OperatorEthAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventValsetConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValsetNonce != 0 {
		n += 1 + sovEvents(uint64(m.ValsetNonce))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSendToEth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutgoingTxId != 0 {
		n += 1 + sovEvents(uint64(m.OutgoingTxId))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.BridgeFee.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventConfirmBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchNonce != 0 {
		n += 1 + sovEvents(uint64(m.BatchNonce))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventAttestationVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovEvents(uint64(m.EventNonce))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventDepositClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovEvents(uint64(m.EventNonce))
	}
	if m.EventHeight != 0 {
		n += 1 + sovEvents(uint64(m.EventHeight))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.EthereumSender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.CosmosReceiver)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TokenContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventWithdrawClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovEvents(uint64(m.EventNonce))
	}
	if m.EventHeight != 0 {
		n += 1 + sovEvents(uint64(m.EventHeight))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BatchNonce != 0 {
		n += 1 + sovEvents(uint64(m.BatchNonce))
	}
	l = len(m.TokenContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventERC20DeployedClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovEvents(uint64(m.EventNonce))
	}
	if m.EventHeight != 0 {
		n += 1 + sovEvents(uint64(m.EventHeight))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.CosmosDenom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TokenContract)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovEvents(uint64(m.Decimals))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventValsetUpdateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventNonce != 0 {
		n += 1 + sovEvents(uint64(m.EventNonce))
	}
	if m.EventHeight != 0 {
		n += 1 + sovEvents(uint64(m.EventHeight))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ValsetNonce != 0 {
		n += 1 + sovEvents(uint64(m.ValsetNonce))
	}
	if len(m.ValsetMembers) > 0 {
		for _, e := range m.ValsetMembers {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	l = m.RewardAmount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.RewardToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OrchestratorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventCancelSendToEth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutgoingTxId != 0 {
		n += 1 + sovEvents(uint64(m.OutgoingTxId))
	}
	return n
}

func (m *EventSubmitBadSignatureEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BadEthSignature)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.BadEthSignatureSubject)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventValidatorSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Power != 0 {
		n += 1 + sovEvents(uint64(m.Power))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ConsensusAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventDepositReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *EventWithdrawalsCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Withdrawals) > 0 {
		for _, e := range m.Withdrawals {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventAttestationObserved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAttestationObserved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAttestationObserved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			m.AttestationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttestationType |= ClaimType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBridgeWithdrawCanceled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBridgeWithdrawCanceled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBridgeWithdrawCanceled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutgoingBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutgoingBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutgoingBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNonce", wireType)
			}
			m.BatchNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchTimeout", wireType)
			}
			m.BatchTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BatchTxIds = append(m.BatchTxIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BatchTxIds) == 0 {
					m.BatchTxIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BatchTxIds = append(m.BatchTxIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchTxIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutgoingBatchCanceled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutgoingBatchCanceled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutgoingBatchCanceled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeChainId", wireType)
			}
			m.BridgeChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BridgeChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValsetUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValsetUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValsetUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValsetNonce", wireType)
			}
			m.ValsetNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValsetNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValsetHeight", wireType)
			}
			m.ValsetHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValsetHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValsetMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValsetMembers = append(m.ValsetMembers, &BridgeValidator{})
			if err := m.ValsetMembers[len(m.ValsetMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetOrchestratorAddresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetOrchestratorAddresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetOrchestratorAddresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorEthAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorEthAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValsetConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValsetConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValsetConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValsetNonce", wireType)
			}
			m.ValsetNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValsetNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSendToEth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSendToEth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSendToEth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingTxId", wireType)
			}
			m.OutgoingTxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutgoingTxId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BridgeFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventConfirmBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventConfirmBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventConfirmBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNonce", wireType)
			}
			m.BatchNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAttestationVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAttestationVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAttestationVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDepositClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDepositClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDepositClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventHeight", wireType)
			}
			m.EventHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthereumSender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthereumSender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosReceiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosReceiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdrawClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdrawClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdrawClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventHeight", wireType)
			}
			m.EventHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNonce", wireType)
			}
			m.BatchNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventERC20DeployedClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventERC20DeployedClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventERC20DeployedClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventHeight", wireType)
			}
			m.EventHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValsetUpdateClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValsetUpdateClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValsetUpdateClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNonce", wireType)
			}
			m.EventNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventHeight", wireType)
			}
			m.EventHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = append(m.AttestationId[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationId == nil {
				m.AttestationId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValsetNonce", wireType)
			}
			m.ValsetNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValsetNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValsetMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValsetMembers = append(m.ValsetMembers, &BridgeValidator{})
			if err := m.ValsetMembers[len(m.ValsetMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrchestratorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrchestratorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCancelSendToEth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCancelSendToEth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCancelSendToEth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingTxId", wireType)
			}
			m.OutgoingTxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutgoingTxId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSubmitBadSignatureEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSubmitBadSignatureEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSubmitBadSignatureEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadEthSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadEthSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadEthSignatureSubject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadEthSignatureSubject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventValidatorSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventValidatorSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventValidatorSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDepositReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDepositReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDepositReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdrawalsCompleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdrawalsCompleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdrawalsCompleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Withdrawals = append(m.Withdrawals, &Withdrawal{})
			if err := m.Withdrawals[len(m.Withdrawals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Withdrawal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Withdrawal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Withdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
